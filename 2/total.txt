이 문서는...
리눅스 2 과정에 대한 모든 문서들이 집합돼있습니다.

문서 총합해서 몇자나오는지 궁금했습니다

그리고 이 문서는 직접적으로 열람하는것이 아니라
키워드 검색을 통해, 관련된 단어들을 찾고, 관련된 파일을 바로 찾을 수 있게 하기 위함입니다.

사실 어떻게 쓰든 상관 없습니다.


시작하겠습니다.


    데몬 프로세스 제어


    데몬 프로세스 제어

    -데몬 프로세스 : 서비스의 동작을 제어하는 프로세스
        데몬 프로세스를 실행시켜서 서비스를 동작시킬 수 있고, 종료시켜서 서비스를 종료시킬 수 있다.
    -제어 멍령
        systemctl {start | stop | restart | status | enable | disable } <데몬명>
            start   : 실행
            stop    : 정지
            restart : 재실행(정지 -> 실행)
            status  : 상태 확인
            enable  : 부팅 시 데몬 프로세스 자동 실행
            disable : enable 헤제

    예시 :
        remote access - telnet
        -초창기부터 사용되던 원격 접속 Protocol
        -CLI  환경으로 사용됨
        -거의 모든 OS에서 사용 가능하지만 보안성이 낮음(비 암호화 통신이므로 가급적 사용하지 않는다.)
        -정보
            패키지  : telnet-*
            데몬    : telnet.socket
            (기본적으로 데몬은 .service 확장자가 자동으로 붙지만 telnet은 CentOS 7 버전부터 통신 socket으로 취급함)

            방화벽  : port=23/tcp, service=telnet
            설정파일: 없음(service가 아니기때문에 설정 파일은 존재하지 않는다.)





방화벽

    firewall(방화벽)
    - 장치의 네트워크 통신의 보안성을 높이는 요소
        > 장치간의 통신에서 무조건 고려해야 한다

    - 방화벽은 inbound와 outbound로 분류
        > inbound(장치에 들어오는) 트래픽은 기본적으로 모두 차단
        outbound(장치에서 나가는) 트래픽은 모두 허용

        > 방화벽에 예외 규칙을 추가하여 규칙에 부합하는 트래픽은 허용

    - CentOS는 6 버전 까지는 iptables 방화벽을 사용하다가
    7 버전 부터는 firewalld 방화벽을 사용

    - firewalld 사용 방법
    1. 예외 규칙 작성
        firewall-cmd [--permanent] < add or remove target >

            --permanent	: 모든 interface를 대상으로 방화벽 규칙 적용

            add or remove target은 add는 규칙 추가, remove는 규칙 제거를 기본으로
            port나 service 등을 기준으로 방화벽의 예외 규칙 제어
            ex>	add-port	: 예외 규칙에 port 추가
                remove-port	: 예외 규칙에서 port 제거
                add-service	: 예외 규칙에 service 추가
                remove-serivce	: 예외 규칙에서 service 제거

    2. 예외 규칙 적용
        firewall-cmd --reload

    3. 예외 규칙 확인
        firewall-cmd --list-all

    다른 사용자 권한 획득 명령어
    - sudo
        특정 명령어를 입력할 때 다른 사용자(보통은 관리자)의 권한을 획득하여 명령을 동작
        sudo 명령어를 사용하는 일반 사용자 계정의 정보를 수정하고 /etc/sudoers 파일을 편집하여 사용
        권한을 획득한 terminal이 종료되면 획득한 권한 폐기

    - su
        현재 접속을 유지한 상태로 다른 사용자(보통은 관리자)로 추가 접속하여 사용
        su 명령어만 입력하면 환경 변수 등의 개인 환경을 먼저 접속했던 사용자의 개인 환경으로 유지
        su - 입력하면 개인 환경을 추가 접속하는 사용자의 환경으로 변경

    remote access - ssh

    - secure shell; 보호된 shell

    - 암호화 된 통신을 제공하는 protocol
        > key 교환을 통해 암호화 key를 생성하고, 암호화 key를 이용하여 주고받는 데이터를 암호화/복호화

    - CLI 환경의 원격 연결

    - version 1과 version 2가 있으며 현재는 version 2를 사용

    - Linux는 기본적으로 ssh가 설치되어 있고, 자동으로 동작하도록 되어있다

    - 정보
        패키지	: openssh-*
        데몬	: sshd
        방화벽	: port=22/tcp, service=ssh
        설정파일	: /etc/ssh/sshd_config

    - 접속 명령어
        ssh <접속할 IP>
            : 명령어를 입력한 사용자와 동일한 이름의 상대 컴퓨터의 계정으로 접속
            (사용자 계정 지정이 불가능)

        ssh -l <계정명> <접속할 IP>
            : 상대 컴퓨터에 해당 계정으로 접속

        ssh <계정명>@<접속할 IP>
            : 상대 컴퓨터에 해당 계정으로 접속


FTP

    FTP
    - File Transfer Protocol; 파일 전송 프로토콜

    - client가 FTP server에 접속하여 자신의 파일을 server에 넘겨주거나(upload)
    server에 있는 파일을 내 컴퓨터로 전송(download)

    - ftp 프로그램도 여러가지가 있으며 수업에서는 vsftpd 사용

    - ftp server는 두 가지로 분류
        로컬 ftp server	: ftp server가 설치된 OS의 사용자 계정들이 접속하는 ftp
        익명 ftp server	: 누구나 접근 가능한 ftp

    - 정보
        패키지	: vsftpd-*
        데몬	: vsftpd
        방화벽	: service=ftp, port=20,21,random/tcp	* 가급적 예외 규칙을 port로 작성하지 않는다
        설정파일	: /etc/vsftpd/vsftpd.conf



DB.txt
    DB server
        - Database server, 데이터베이스 모아놓은 서버
        - 인터넷의 보급, 스마트폰의 개발 및 보급에 따라 인터넷의 활용이 급속도로 늘어났고, 무수히 많은 데이터 생성
            > 많은 데이터들을 효율적으로 저장 및 관리하기 위해 database 를 사용
        -CentOS 는 6 버전까지는 mysql 이라는 DB 서버를 사용했으나
            mysql 이 유료화되면서 CentOS 7 버전부터는 mysql 의 마이너 카피인 mariadb(마리아디비)를 사용
        
        - 정보
            패키지  : mariadb-*
            데몬    : mariadb
            방화벽  : service=mysql
            설정파일: /etc/my.cnf       << DB server 동작 자체에 영향을 끼칩니다
                    (database) mysql  << DB server 내부에서 각종 설정들
        -접속 명령어
            mysql -u <DB server 계정> -p [<사용할 database 이름>]
            mysql -u root -p mysql

            ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)
            같은 오류가 발생하는 이유는 데몬이 실행중이지 않기 때문일 수도 있습니다.

        - 설치
            yum -y install mariadb-*

        - 용어 정리
            SQL문   : DBserver 의 제어를 위한 명령어 
            database: table 들의 집합체
            table   : 실제 데이터가 들어잇는 최소 단위
            field   : table 에 저장되는 데이터들의 종류 (= column)
            value   : field 에 맞춰서 table 에 저장되는 데이터
            


DHCP.txt
    DHCP
        설치
            yum -y install dhcp-*

        - Dynamic Host Configuration Protocol
            > 자동으로 host에게 IP 주소를 할당하는 서비스
        
        - 동작 순서(사용되는 패킷 종류) >> DORA 패킷을 주고 받아 IP 할당함 
            * client에 IP 가 없는 상태로 진행
                Discover    : client -> broadcast, 네트워크에서 DHCP 서버를 찾는 패킷
                Offer       : server -> broadcast, discover 패킷을 받은 server가 전송하는 패킷('어떤 ip 를 줄수 있는가에 대한 패킷) 해당 ip를 자신의 내부(DHCP database)에서 임시 할당 상태로 분류
                Request     : client -> broadcast, 제일 먼저 받은 offer를 '사용하겠다'라고 알려주는 패킷
                Ack         : server -> broadcast, offer가 채용된 server에서 IP 정도 및 옵션들을 알려주는 패킷 (offer가 채용되지 못한 server는 임시 할당 상태인 IP를 다시 미할당으로 분류

                이 후에 ack 패킷을 받은 client는 IP 정보와 각종 옵션들을 자신의 IP 설정에 적용
        - client 가 할당받은 IP는 영구적용되지 않는다
            > 따라서 임대 기간이 존재하고, 기간 만료 전 갱신 작업을 위하여 기존 IP를 계속 사용한다
        - 정보
            패키지  : dhcp-*
            데몬    : dhcpd
            방화벽  : service=dhcp
            설정파일: /etc/dhcp/dhcpd.conf
    
DNS.txt 
    DNS
        -Domain Name Service / Domain Name System

        -Internet 에 존재하는 무수히 많은 서버들을 쉽게 기억할 수 있도록 문자주소(FQDN)를 이용한 접근을 도와주는 서버
            > 문자주소(FQDN) <-> IP address 상호 변환
                * FQDN 은 일반적으로 말하는 도메인 주소 
                    > host name 과 domain name 으로 구성, 일반적으로 domain anme 은 한 회사의 네트워크, host name 은 각 서버 장치 (예시 : www.google.com 이라는 주소가 있다면 www 가 host name, google.com 이 domain name)

                    > 영문자 및 숫자를 사용한 이름으로 서버에 대한 접근이 가능함
        
        - InterNIC 에서 관리하는 Domain Namespace 라는 트리 구조에 맞춰서 FQDN 이 구성
            > DNS 서버는 Namespace 최상단 부터 각 계층별 nameserver 를 거쳐가면서 FQDN 에 대한 IP 주소를 탐색한다
        
        - 정보
            패키지  : bind-*
            데몬    : name
            방화벽  : port=53/tcp , service=dns
            설정파일: /etc/named.conf

        Domain Namespace 구조
            -효율적인 관리를 위해 최상단에 위치한 root domain 에서 top-level domain 으로, top-level domain은 second-level domain 으로 각각 위임 처리를 하고, second-level domain 에서 목적지 FQDN 의 IP 를 확인

            -구조 예시
                .       - com   - naver
                                - google    - www
                                            - drive
                                            - news
                                - nate
                        - net
                        - org
                [root   [top    [second     [host
                domain] level   level       name]
                        domain] doamin]
            
            - root domain
                InterNIC 에서 관리하는 Doamin Namespace 의 최상위 서버
                전 세계에 총 13 개가 있으며 a ~ m 까지 이름을 붙여서 관리함

            - top-level domain
                FQDN 의 마지막 한 단어 (예시. com, net, org 등등)
            
            - second-level domain
                일반적으로 각 회사에서 관리하는 nameserver

                host name 의 정보를 record 로 가지고 있다   *record : DNS server 에서 사용하는 자원
                (예시 : google.com, naver.com)




    DNS server 의 역할

        yum -y install bind-*
        를 입력하고 시작해주시기 바랍니다.

        1. IP address 와 FQDN 을 상호 변환
            ex. 사용자가 client 에 FQDN 을 입력하면
                1) client 장치는 자신의 cache 확인(hosts 파일 확인 -> DNS cache 확인)
                2) IP 설정 중 DNS IP 를 확인하여 해당 DNS server 에 FQDN 을 질의
                3) DNS server 는 자신의 zone 영역 확인 -> cache 확인(zone 영역 : nameserver 구성에 관련된 영역)
                4) root hint 를 확인하여 root domain 에 FQDN을 질의 
                    -> root domain 은 FQDN 을 확인하여 top-level domain 의 IP 를 돌려준다 
                5) top-level domain 에 FQDN 을 질의
                    -> top-level domain 은 FQDN 을 확인하여 second-level domain 의 IP를 돌려준다
                6) second-level domain 에 FQDN 을 질의
                    -> second-level domain 은 FQDN 을 확인하여 host name 을 갖고 있는지 확인하고 FQDN 에 매핑된 IP 를 돌려준다
                7) DNS server 는 4 ~ 6 과정에서 알아낸 서버들의 IP 를 자신의 cache 에 저장
                8) client 에게 FQDN 에 대한 IP 를 전송
                9) client 는 자신의 cache 에 해당 IP 를 저장 -> 알게된 IP 로 연결 시도
            * 위의 과정에서 3 ~ 8 과정이 DNS server 의 일반적인 동작

            * root hint 를
                a ~ m 까지의 모든 root domain 의 IP 주소를 갖고있는 파일

        2. nameserver 구성
            DNS server 를 설치하면 nameserver 를 구성할 수 있는(= zone 영역을 만들 수 있는 )파일이 함께 설치된다.
                > zone 영역을 구성하여 DNS server 를 nameserver 로 사용할 수 있다
            root domain, top-level domain, second-level domain 등은 각각이 하나의 nameserver

    Linux에 기본적으로 존재하는 DNS 관련 파일
        1. /etc/hosts
            IP주소  문자주소 
            컴퓨터에 문자주소가 입력된면 hosts 파일에서 매핑되어 있는 IP 주소로 연결 

        2. /etc/resolv.conf
            nameserver <DNS IP>
            network 데몬이 설정될 때 마다 IP 설정 중 DNS 주소 정보가 기록됨
                > 해당 컴퓨터에서 DNS 서버를 찾아갈 때 resolv.conf 에 적힌 주소로 찾아감
            *DNS 주소 예시
                168.126.63.1    : KT DNS
                8.8.8.8         : Google DNS


firewall.txt
    firewall(방화벽)
    - 장치의 네트워크 통신의 보안성을 높이는 요소
        > 장치간의 통신에서 무조건 고려해야 한다

    - 방화벽은 inbound와 outbound로 분류
        > inbound(장치에 들어오는) 트래픽은 기본적으로 모두 차단
        outbound(장치에서 나가는) 트래픽은 모두 허용

        > 방화벽에 예외 규칙을 추가하여 규칙에 부합하는 트래픽은 허용

    - CentOS는 6 버전 까지는 iptables 방화벽을 사용하다가
    7 버전 부터는 firewalld 방화벽을 사용

    - firewalld 사용 방법
    1. 예외 규칙 작성
        firewall-cmd [--permanent] < add or remove target >

            --permanent	: 모든 interface를 대상으로 방화벽 규칙 적용

            add or remove target은 add는 규칙 추가, remove는 규칙 제거를 기본으로
            port나 service 등을 기준으로 방화벽의 예외 규칙 제어
            ex>	add-port	: 예외 규칙에 port 추가
                remove-port	: 예외 규칙에서 port 제거
                add-service	: 예외 규칙에 service 추가
                remove-serivce	: 예외 규칙에서 service 제거

    2. 예외 규칙 적용
        firewall-cmd --reload

    3. 예외 규칙 확인
        firewall-cmd --list-all


    시나리오 예시 :
    문제 : telnet 으로 비 암호화 통신을 하기 위해서 예외 규칙에 포트를 넣어야 한다.
    정보 : telnet이 이용하는 well-known 포트는 tcp 프로토콜 23번 포트에 해당한다.
    해결 :

    firewall-cmd --list-all
    이 명령어를 통해서 이미 telnet이 예외처리 되어있는지 확인한다.


    [root@server ~]# firewall-cmd --list-all
    public (active)
    target: default
    icmp-block-inversion: no
    interfaces: ens32
    sources:
    services: dhcpv6-client ftp ssh
    ports: 23/tcp
    protocols:
    masquerade: no
    forward-ports:
    source-ports:
    icmp-blocks:
    rich rules:

    위와 같은 결과가 나왔는데 'ports: 23/tcp'를 잘 보면 이미 tcp프로토콜의 23번 포트가 추가되어 있는것을 확인 할 수 있다.

    만약 여기서
    public (active)
    target: default
    icmp-block-inversion: no
    interfaces: ens32
    sources:
    services: dhcpv6-client ftp ssh
    ports: 
    protocols:
    masquerade: no
    forward-ports:
    source-ports:
    icmp-blocks:
    rich rules:
    이러한 결과가 나왔다면
    23/tcp 같은 예외 처리 된 포트(port)가 없다는 뜻이므로 후처리를 해줘야한다.

    firewall-cmd --permanent --add-port=23/tcp
    firewall-cmd    : 방화벽 관련 명령어
    --permanent     : 모든 interfaces(인터페이스)를 대상으로 방화벽 규칙 적용 예정
    --add-port      : 예외 규칙에 port 추가
    =               : 추가할 포트는
    23/tcp          : tcp 프로토콜의 23번 포트(telnet의 well-known 포트)
    라는 의미의 명령어를 입력해준다.

    firewall-cmd --reload
    이 명령어를 통해서 다시 전체적인 네트워크 시스템을 재시작해준다.


mariadb.txt
    이 문서는
    mysql 의 mariadb 에 관한 내용을 다루는
    전체적인 명령어 체계와 예시를 서술합니다.

    ;
        모든 명령어 및 행동에는 끝에 세미콜론(;)을 붙혀야 합니다.

    탈출
        \c
        '> 나 -> 같은 구문만 나오고, 다른 명령어를 입력할 수 없는 경우 \c 를 입력해서 탈출할 수 있습니다.

    접속
        mysql -u <DB server 계정> -p [<사용할 database 이름>]
        mysql -u root -p mysql

        ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)
        같은 오류가 발생하는 이유는 데몬이 실행중이지 않기 때문일 수도 있습니다.

    변경점 저장
        systemctl restart mariadb
        로 데몬 재실행을 시켜줘야합니다.

    한글
        
        insert into tbtest values (1,'홍','논현','010-1234-5678');
        위와같은 구문처런 특정 삽입문에 한글을 넣게 된다면 깨진채로 들어가는 경우가 생길 수 있습니다.

        이 아래의 내용은 한글 깨짐 증상을 없애기 위해서 한글을 세팅하는 방법에 대한 내용입니다.

        vi /etc/my.cnf
        로 파일을 열어서
        # instructions in http://fedoraproject.org/wiki/Systemd
        같은 내용이 적힌 주석 아래에
        character-set-server = utf8
        collation-server = utf8_general_ci
        을 입력해주고 나와서
        
        systemctl restart mariadb
        으로 데몬을 재실행해줍니다.

        그리고 자신이 사용할 db 에 들어가서
        alter database dbtest default character set utf8;
        입력하고
        commit;
        이라고 입력해줍니다.

        이러한 변경점들은 '이미 만들어진' table 에서는 적용되지 않으니, 이미 만들어진 테이블에 대해서도 utf8 을 적용시키고 싶다면

        alter table tbtest modify name char(14) char set utf8;
        alter table [테이블 이름] modify [필드 이름] [자료형]([필드 크기]) [자료형] set utf8;
        이렇게 필드마다 전부 바꿔줘야합니다.




    화면 청소
        system clear;
        을 입력해서 명령어로 화면을 청소해줄 수도 있지만

        ctrl + L
        단축키로 청소할 수도 있습니다.

    select version(), current_date, current_time;
        서버에 세팅된 날짜와 시간을 볼 수 있게 해주는 명령어
        버전의 경우에는 유틸리티를 사용하기 위해서 반드시 알고있어야하는 요소입니다.

    출력
        show [객체]
        예시 :
        show databases;
        show tables; -> 내가 현재 사용중인 데이터베이스 내부에 있는 table 목록을 보여줌(맨 밑줄에 24 rows in set 같은 내용으로 갯수를 알려줌)
        
    db table과 user table을 사용할 예정
    user table에서 사용자 관리와 DB 서버 전체를 관리함
    db table은 특정 DB 에 대한 권한을 관리함

    생성
        create database [DB 이름];
        create database db_ghd;
        데이터베이스 만드는 명령어

        create table [table 이름] ([컬럼명] [형식]([byte 단위의 수용량]))
        create table tb_ghd (num int(3), name char(20));
        tb_ghd 이라는 이름의 table에다가
        num 이라는 정수형 3 byte 까지 받을 수 있는 컬럼 하나와
        name 이라는 문자형 20 byte 까지 받을 수 있는 컬럼 하나를 포함하여 생성한다는 내용입니다.

        근데 우리가 배우는 숫자 체계에서 int 형식의 변수는 4 byte, 문자는 2 byte 로 배우게 되는데
        데이터베이스에 경우에는 조금 다르게 '자릿수'와 '크기'의 개념으로써 들어가게 됩니다.
        그러니까 위에 적힌 num int(3) 은 0~999 까지 받는다는 내용이고, name char(20) 은 눈에 보이지 않는 끝자리의 온점 하나(.)를 제외한 영어, 특수문자 등등의 아스키코드에서 사용되는 문자들을 19개까지 넣을 수 있다는 내용입니다.

        create table tb_ghd;
        table 만드는 명령어
        다만, 모든 table은 하나 이상의 컬럼이 필요하기 때문에 이 명령어만 쓰고서는 아무것도 할 수 없거나, 필연적으로 에러가 따라붙습니다.

    전환 or 사용
        use [목표물];
        use db_ghd;
        db_ghd 을 사용하는 상태로 전환시키기
        이 use 명령어 뒤에 들어가는건 무조건 DB 이름이여야한다.

    정보 확인
        desc [DB 이름];
        desc db_ghd;

        MariaDB [dbitbank]> desc db_ghd;
        +-------+----------+------+-----+---------+-------+
        | Field | Type     | Null | Key | Default | Extra |
        +-------+----------+------+-----+---------+-------+
        | num   | int(3)   | YES  |     | NULL    |       |
        | name  | char(20) | YES  |     | NULL    |       |
        +-------+----------+------+-----+---------+-------+
        2 rows in set (0.00 sec)
        
        이런식으로 출력될 수 있는데 각 값들에 대한 내용을 출력합니다.
        field : field 이름
        Type    : field 자료형과 길이
        Null    : Null 값 허용 여부
        Key     : 키 지정 관련 여부
        Default : 기본값 지정 여부
        Extra   : 기타사항
        이 desc 명령어 뒤에 들어가는건 무조건 table 이름이여야한다.

    삭제
        drop [db 이름];
        drop [table 이름];

        delete from [table 이름] where [조건식];
        delete from user where user=' ';
        user table 에서 user 컬럼의 값이 ' ' 인 유저를 삭제한다. 

    추가
        insert

        insert into user(host, user, password) values ('localhost','userghd',password('ghdwpaks'));

        user 라는 table 에 있는 host 에는 'localhost' 라는 값을, user 에는 'userghd' 라는 값을, password 에는 'ghdwpaks' 이라는 값을 넣어준다는 내용입니다.
        지정해주지 않은 내용은 기본(default)값이 들어가게 되며, primary 같은 기본키마저 비워버리는 경우에는 오류가 뜨게 됩니다.


        insert into db values ('localhost','db_ghd','ghduser','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y');
        이번 경우에는 따로 지정을 해주지 않고, 컬럼값 전부를 넣은 명령어의 모습입니다.



        
    수정
        update [table 이름];
        update user set password=password('ghdwpaks') where user='root';
        
        user table 에 있는 password 컬럼을 password 컬럼형식으로 된 'ghdwpaks' 으로 바꾸는데, user 컬럼의 값이 root 인 경우에만 바꾸겠다.

    alter
        alter table [table  이름]
        기본적으로 이 명령어 토대를 기본으로 돌아간다.

        table 의 field 이름을 바꾸고싶은 경우에는 change 라고 적어준다.
        alter table [table  이름] change [기존 이름] [수정 후 이름] [자료형]([field 크기]);
        alter table tbtest change old age int(3);
        tbtest 라는 이름의 table 에 있는 old 라는 이름의 field 를 age 인 이름의 int(정수형) 3자리수의 field 로 바꿔준다는 내용이다.

        table 의 특정 field 를 지우고싶다면
        alter table [talbe 이름] drop [field 이름];
        형식으로 작성해주면 되는데, 예시는 아래와 같다.

        alter table tbtest drop addr;
        tbtest 라는 테이블에서 addr 이라는 필드를 없앤다는 내용이다




        table 에 field 를 추가하고싶은 경우에는 add 라는 구문을 쓴다.

        alter talbe [table  이름] add [field 이름] [자료형]([field 크기]) {first} {after [field 이름]};
        이와 같은 형식을 가지고있는데 예시 하나를 들자면

        alter table tbtest add age int(3) after name;
        tbtest 라는 table 에 age 라는 이름의 int(정수) 형식의 3자리 크기의 field 를 name 이라는 field 다음에 넣는다. 라는 내용이다.
        



        table 의 자료형만 바꿀때는 modify 라는 구문을 적어준다.
        (alter table tbtest modify)
        그리고 자료형을 바꿀 field 이름과
        어떤 자료형으로 바꿀것인지에 관한 내용을 적어준다.
        (alter table tbtest modify phone char(14);)

        마지막으로, 형식은 다음과 같다.
        alter table [table  이름] modify [field 이름] [자료형]([길이]){,[field 이름] [자료형]([길이])};

    update
        update [table  이름] set [field 이름]=[값];
        기본적으로 이 명령어 토대 뒤에 조건을 달아서 쓰는게 일반적이다.

        update tbtest set phone='010-1111-1111' where num=1;
        이 구문은 tbtest 라는 table 에 num 값이 1인 컬럼의 phone field 값을 '010-1111-1111' 으로 바꾼다는 내용이다.


    user
        이 부분은  mariadb 를 사용하면 대부분 따라오는 mysql 이라는 db 에 관한 내용입니다.
        그 mysql 이라는 db 안에 있는 user 이라는 table 에 관한 내용입니다.
        desc user; 이라고 입력하고서, user table 에 있는 정보들을 출력하면

        MariaDB [mysql]> desc user;
        +------------------------+-----------------------------------+------+-----+---------+-------+
        | field                | Type                              | Null | Key | Default | Extra |
        +------------------------+-----------------------------------+------+-----+---------+-------+
        | Host                   | char(60)                          | NO   | PRI |         |       |
        | User                   | char(16)                          | NO   | PRI |         |       |
        | Password               | char(41)                          | NO   |     |         |       |
        | Select_priv            | enum('N','Y')                     | NO   |     | N       |       |
        | Insert_priv            | enum('N','Y')                     | NO   |     | N       |       |
        | Update_priv            | enum('N','Y')                     | NO   |     | N       |       |
        | Delete_priv            | enum('N','Y')                     | NO   |     | N       |       |
        | Create_priv            | enum('N','Y')                     | NO   |     | N       |       |
        | Drop_priv              | enum('N','Y')                     | NO   |     | N       |       |
        | Reload_priv            | enum('N','Y')                     | NO   |     | N       |       |
        | Shutdown_priv          | enum('N','Y')                     | NO   |     | N       |       |
        | Process_priv           | enum('N','Y')                     | NO   |     | N       |       |
        | File_priv              | enum('N','Y')                     | NO   |     | N       |       |
        | Grant_priv             | enum('N','Y')                     | NO   |     | N       |       |
        | References_priv        | enum('N','Y')                     | NO   |     | N       |       |
        | Index_priv             | enum('N','Y')                     | NO   |     | N       |       |
        | Alter_priv             | enum('N','Y')                     | NO   |     | N       |       |
        | Show_db_priv           | enum('N','Y')                     | NO   |     | N       |       |
        | Super_priv             | enum('N','Y')                     | NO   |     | N       |       |
        | Create_tmp_table_priv  | enum('N','Y')                     | NO   |     | N       |       |
        | Lock_tables_priv       | enum('N','Y')                     | NO   |     | N       |       |
        | Execute_priv           | enum('N','Y')                     | NO   |     | N       |       |
        | Repl_slave_priv        | enum('N','Y')                     | NO   |     | N       |       |
        | Repl_client_priv       | enum('N','Y')                     | NO   |     | N       |       |
        | Create_view_priv       | enum('N','Y')                     | NO   |     | N       |       |
        | Show_view_priv         | enum('N','Y')                     | NO   |     | N       |       |
        | Create_routine_priv    | enum('N','Y')                     | NO   |     | N       |       |
        | Alter_routine_priv     | enum('N','Y')                     | NO   |     | N       |       |
        | Create_user_priv       | enum('N','Y')                     | NO   |     | N       |       |
        | Event_priv             | enum('N','Y')                     | NO   |     | N       |       |
        | Trigger_priv           | enum('N','Y')                     | NO   |     | N       |       |
        | Create_tablespace_priv | enum('N','Y')                     | NO   |     | N       |       |
        | ssl_type               | enum('','ANY','X509','SPECIFIED') | NO   |     |         |       |
        | ssl_cipher             | blob                              | NO   |     | NULL    |       |
        | x509_issuer            | blob                              | NO   |     | NULL    |       |
        | x509_subject           | blob                              | NO   |     | NULL    |       |
        | max_questions          | int(11) unsigned                  | NO   |     | 0       |       |
        | max_updates            | int(11) unsigned                  | NO   |     | 0       |       |
        | max_connections        | int(11) unsigned                  | NO   |     | 0       |       |
        | max_user_connections   | int(11)                           | NO   |     | 0       |       |
        | plugin                 | char(64)                          | NO   |     |         |       |
        | authentication_string  | text                              | NO   |     | NULL    |       |
        +------------------------+-----------------------------------+------+-----+---------+-------+
        42 rows in set (0.00 sec)
        이와같은 컬럼들이 나오게 되는데, 이번에 서술할 내용은
        
        | Host                   | char(60)                          | NO   | PRI |         |       |
        | User                   | char(16)                          | NO   | PRI |         |       |
        | Password               | char(41)                          | NO   |     |         |       |
        이 부분에 집중되어 있습니다.
        
        위에서 차례대로

        Host 에서 사용하는 User 의 Password 가 무엇인지에 관한 내용입니다.

        그리고 그 아래에 있는 priv 관련 컬럼들이 있는데
        [sql 명령어]_priv
        같은 형식을 취하고 있습니다.
        이것들은 Host 에 접속하는 user 가 어떤 권한을 가지고 있는지에 관한 내용들입니다.
        
        
        앞서 말했던 Host , User , Password 에 관해서 출력하면 다음과 같이 나올 수 있습니다.
        MariaDB [mysql]> select host , user, password from user;
        +-----------+------+----------+
        | host      | user | password |
        +-----------+------+----------+
        | localhost | root |          |
        | server    | root |          |
        | 127.0.0.1 | root |          |
        | ::1       | root |          |
        | localhost |      |          |
        | server    |      |          |
        +-----------+------+----------+
        6 rows in set (0.00 sec)

        여러개의 root 사용자도 host 에 따라 여러개로 들어가있는것을 볼 수 있는데, 아무것도 설정해주지 않은 상태라면 대부분 루프 백 주소의 정보를 담고있습니다.

        
        MariaDB [mysql]> select host, user, password from user;
        +-----------+------+-------------------------------------------+
        | host      | user | password                                  |
        +-----------+------+-------------------------------------------+
        | localhost | root | *E1B74369B47EB3AD8EF858144E1A0364E3259329 |
        | server    | root | *E1B74369B47EB3AD8EF858144E1A0364E3259329 |
        | 127.0.0.1 | root | *E1B74369B47EB3AD8EF858144E1A0364E3259329 |
        | ::1       | root | *E1B74369B47EB3AD8EF858144E1A0364E3259329 |
        | localhost |      |                                           |
        | server    |      |                                           |
        +-----------+------+-------------------------------------------+
        6 rows in set (0.00 sec)
        MariaDB [mysql]>
        아니면 이렇게 유저의 패스워드가 이상하게 출력되는 경우가 있는데, 이러한 경우는 이상하게 값이 입력됐거나, 출력된게 아니라
        암호화가 들어가면서 저렇게 보일뿐입니다.


NFS.txt
    NFS
        -Network FileSyste; 네트워크를 통해 다른 장치의 파티션을 마운트함
        -최초에는 Unix 중에 하나가 사용하던 서비스(service)
            >유용성이 굉장히 높아서 다른 OS에서도 사용하기 시작함
        -정보
            패키지  : nfs-* (CentOS 7 이상부터는 단일 패키지로 구성됨)
            데몬    : nfs
            방화벽  : service=nfs
            설정파일: /etc/exprots
            
        -설치 방법
            rpm -qa | grep nfs
            또는
            yum install nfs-utils

PHPmyadmin.txt
    phpmyadmin
        - mariadb(mysql) 서버를 web page 를 이용한 GUI 환경으로 제공
        - php 언어로 작성됐기 때문에 web server 사용자 내지 개발자가 php 언어를 알고있어야한다.
        - DB server 와 web server 가 같은 장치에 설치되어 있어야 사용 가능

        -설치
            https://www.phpmyadmin.net
            에 접속한 다음 상단 메뉴 바에 맨 오른쪽에 있을 Download 버튼을 눌러서 페이지를 이동해야합니다.

            그 아래에 
            Older Releases 라고 비교적 큰 폰트로 써져있는 문단에서 'You can find older releases on separate files page. You can also get them from our Git repository (check developer information for instructions). Older releases are unsupported.' 이라고 적혀있고, 'separate files page'라는 문단이 하이퍼링크로 걸려있을텐데, 그곳으로 들어가줍니다.

            Releases 라는 항목이 4.4.15.10 라고 되어있는 곳으로 가서 오른쪽에 있는 zip 파일 하이퍼링크를 타고 다운로드를 해줍니다.


            리눅스 환경에서는
            yum -y install vsftpd-*
            systemctl restart vsftpd
            firewall-cmd --permanent --add-service=ftp
            firewall-cmd --reload


            윈도우 CMD 환경에서
            (서버 아이피가 192.168.127.128 인경우)
            다운로드 해준 파일이 있는 디렉터리로 이동해서
            ftp 192.168.127.128
            ftp 에 접속해준다.

            
            main 으로 접속해주고
            cd public_html
            put phpMy*
            를 입력해서, 다운로드한 파일을 ftp 로 전송해주고
            
            quit
            나옵니다

            다시 리눅스로 돌아와서,
            cd ~main/public_html 
            이동하고

            unzip php*
            다운로드 받은 파일을 풀어주고

            mv phpmyadmin-4.4.15.10-all-languages db
            그 파일의 이름 db 로 바꿔준다

            
ping.txt
    ping
    내 장치와 목적지 장치 간의 네트워크 통신 상태 확인
    기본적으로 무한정 지속됨

    형식 : ping [옵션] <목적지 IP>

    *옵션
    -c  : 횟수 지정
    -i   : ping 트래픽 사이에 간격 지정(DOS 공격을 방지하기 위해서 0.5초 아래의 짧은 간격은 관리자만 사용이 가능하다.)
    -s   : 트래픽에 더미값을 추가하여 크기를 지정한다.

    예시 모음 :
    ping 192.168.127.128
    ping -c 5 192.168.127.128
    ping -c 5 -i 0.1 192.168.127.128




    예시 : ping 192.168.127.128
    결과 :
    [root@server ~]# ping 192.168.127.128
    PING 192.168.127.128 (192.168.127.128) 56(84) bytes of data.
    64 bytes from 192.168.127.128: icmp_seq=1 ttl=64 time=0.023 ms
    64 bytes from 192.168.127.128: icmp_seq=2 ttl=64 time=0.037 ms
    64 bytes from 192.168.127.128: icmp_seq=3 ttl=64 time=0.036 ms
    64 bytes from 192.168.127.128: icmp_seq=4 ttl=64 time=0.049 ms
    64 bytes from 192.168.127.128: icmp_seq=5 ttl=64 time=0.038 ms
    64 bytes from 192.168.127.128: icmp_seq=6 ttl=64 time=0.036 ms
    ^C
    --- 192.168.127.128 ping statistics ---
    6 packets transmitted, 6 received, 0% packet loss, time 5009ms
    rtt min/avg/max/mdev = 0.023/0.036/0.049/0.009 ms
    [root@server ~]#


    예시 : ping -c 5 192.168.127.128
    결과 :
    [root@server ~]# ping -c 5 192.168.127.128
    PING 192.168.127.128 (192.168.127.128) 56(84) bytes of data.
    64 bytes from 192.168.127.128: icmp_seq=1 ttl=64 time=0.024 ms
    64 bytes from 192.168.127.128: icmp_seq=2 ttl=64 time=0.046 ms
    64 bytes from 192.168.127.128: icmp_seq=3 ttl=64 time=0.089 ms
    64 bytes from 192.168.127.128: icmp_seq=4 ttl=64 time=0.055 ms
    64 bytes from 192.168.127.128: icmp_seq=5 ttl=64 time=0.054 ms

    --- 192.168.127.128 ping statistics ---
    5 packets transmitted, 5 received, 0% packet loss, time 4027ms
    rtt min/avg/max/mdev = 0.024/0.053/0.089/0.022 ms


    예시 : ping -c 5 -i 0.1 192.168.127.128
    결과 : 
    PING 192.168.127.128 (192.168.127.128) 56(84) bytes of data.
    64 bytes from 192.168.127.128: icmp_seq=1 ttl=64 time=0.024 ms
    64 bytes from 192.168.127.128: icmp_seq=2 ttl=64 time=0.036 ms
    64 bytes from 192.168.127.128: icmp_seq=3 ttl=64 time=0.044 ms
    64 bytes from 192.168.127.128: icmp_seq=4 ttl=64 time=0.037 ms
    64 bytes from 192.168.127.128: icmp_seq=5 ttl=64 time=0.037 ms

    --- 192.168.127.128 ping statistics ---
    5 packets transmitted, 5 received, 0% packet loss, time 422ms
    rtt min/avg/max/mdev = 0.024/0.035/0.044/0.009 ms



samba.txt
    samba
    -공유 폴더 제공 서비스
    -익명 공유, 사용자 지정 공유, 그룹 지정 공유의 종류가 있음
    -정보
        패키지  :samba
        데몬    :smb
        방화벽  : service=samba
        설정파일: /etc/samba/smb.conf

    -설치
        yum -y install samba-*

        apt-get -y install samba
        yum install samba
        
scp.txt
    scp : ssh + rcp
    rcp : remote copy

    rcp 원본 <상대방 IP>:복사할_위치 : 내 컴퓨터에 있는 파일을 상대방 컴퓨터에 복사
    rcp <상대방 IP>:원본 복사할_위치 : 상대방 컴퓨터에 있는 파일을 내 컴퓨터에 복사

    scp 원본 <상대방 IP>:복사할_위치 : 내 컴퓨터에 있는 파일을 상대방 컴퓨터에 복사
    scp <상대방 IP>:원본 복사할_위치 : 상대방 컴퓨터에 있는 파일을 내 컴퓨터에 복사


ssh.txt
    remote access - ssh

    - secure shell; 보호된 shell

    - 암호화 된 통신을 제공하는 protocol
        > key 교환을 통해 암호화 key를 생성하고, 암호화 key를 이용하여 주고받는 데이터를 암호화/복호화

    - CLI 환경의 원격 연결

    - version 1과 version 2가 있으며 현재는 version 2를 사용

    - Linux는 기본적으로 ssh가 설치되어 있고, 자동으로 동작하도록 되어있다

    - 정보
        패키지	: openssh-*
        데몬	: sshd
        방화벽	: port=22/tcp, service=ssh
        설정파일	: /etc/ssh/sshd_config

    - 접속 명령어
        ssh <접속할 IP>
            : 명령어를 입력한 사용자와 동일한 이름의 상대 컴퓨터의 계정으로 접속
            (사용자 계정 지정이 불가능)

        ssh -l <계정명> <접속할 IP>
            : 상대 컴퓨터에 해당 계정으로 접속

        ssh <계정명>@<접속할 IP>
            : 상대 컴퓨터에 해당 계정으로 접속

    예시 :
    ssh 192.168.127.128
    지금 접속하고 있는 계정 이름으로 192.168.127.128 에 접속을 시도합니다.

    ssh -l itbank 192.168.127.128
    itbank 라는 이름의 계정으로 192.168.127.128에 접속을 시도합니다.

    ssh itbank@192.168.127.128
    itbank 라는 이름의 계정으로 192.168.127.128에 접속을 시도합니다.



su.txt
    다른 사용자 권한 획득 명령어
    - sudo
        특정 명령어를 입력할 때 다른 사용자(보통은 관리자)의 권한을 획득하여 명령을 동작
        sudo 명령어를 사용하는 일반 사용자 계정의 정보를 수정하고 /etc/sudoers 파일을 편집하여 사용
        권한을 획득한 terminal이 종료되면 획득한 권한 폐기
        
    - su
        현재 접속을 유지한 상태로 다른 사용자(보통은 관리자)로 추가 접속하여 사용
        su 명령어만 입력하면 환경 변수 등의 개인 환경을 먼저 접속했던 사용자의 개인 환경으로 유지
        su - 입력하면 개인 환경을 추가 접속하는 사용자의 환경으로 변경





telnet.txt
    remote access - telnet
    -초창기부터 사용되던 원격 접속 protocol
    -CLI 환경으로 사용함
    -거의 모든 OS에서 사용 가능하지만 보안성이 낮음(비 암호화 통신이므로 가급적 사용하지 않는다.)
    -정보
    패키지  : telnet-*
    데몬    : telnet.socket (기본적으로 데몬은 .service 확장자가 자동으로 붙지만 telnet은 CentOS 7 버전부터 통신 socket으로 취급함.)
    방화벽 : port=23/tcp, service=telnet
    설정파일    : 없다.(service가 아니기 때문에 설정파일 자체가 없다.)



tranceroute.txt
    traceroute
    내 장치와 목적지 IP 사이에 몇개의 네트워크(= router = 라우터)가 있는지 확인한다.
    최대 30hop(홉)까지 확인하는데, 전 세계 어디에 있어도 20개를 초과하는 일이 흔하지 않으면 더군다나 30개의 홉을 초과하는일은 더더욱 없다.(단, 중간에 있는 router가 자신의 정보를 알려주지 않거나 통신이 안되면 hop을 추가한다.)

    형식 : traceroute <목적지 IP>



    예시 모음 :
    traceroute 192.168.127.128


    예시 : traceroute 192.168.127.128
    결과 :
    [root@server ~]# traceroute 192.168.127.128
    traceroute to 192.168.127.128 (192.168.127.128), 30 hops max, 60 byte packets
    1  server (192.168.127.128)  0.026 ms  0.008 ms  0.007 ms
    주석 : 이번에는 '1  server (192.168.127.128)  0.026 ms  0.008 ms  0.007 ms'이라는 행 이외에는 다른 것을 찾아볼 수 없는데, 이는 로컬호스트로 연결해서 그러하다.




Web_Server.txt
    Web Server
        - Client 에게 web page 를 제공해주는 서버
            > Client 가 web browser 프로그램을 이용하여 seb server에 접근하면 접근한 client 에게 알맞는 web page 를 전송하고, client 는 전송받은 페이지를 browser 에 출력하는 맥락
        - web server 프로그램은 여러 종류가 있으며 대표적으로는 apache web server 가 있다. (점유율이 가장 높고, 거의 대부분의 운영체제에서 사용 가능한 web server 이다.)
        -정보   
            패키지  : httpd-*
            데몬    : httpd
            방화벽  : port=80/tcp , service=http
            설정파일: /etc/httpd/conf/httpd.conf
        -설치
            yum -y install httpd-*


XpressEngine.txt
    XpressEngine

        -기능
            php 언어로 만들어진 web page 제공
            web page 의 내용문들을 DB server 에 저장할 수 있게 해줌


            저장된 데이터를 불러와서 언제든지 web page 를 복구할 수 있게 해줌


            DB server 와 web server 가 서로 다른 장치에 있어도 사용 가능
            web server 는 한국에, DB server 은 외국에 구성할수 있는 기능 제공

            
            core 와 각종 module 로 구성됨
            core 설치 후 필요한 module 을 조합하여 web page 를 생성함


            DB 에 저장할때는 테이블 접두사를 이용하여 저장된 정보를 분류
            core 설치 시 출력되는 table 접두사가 해당 database 에 없으면 table 전부 생성 가능
            database 에 해당 접두사가 붙어있는 table 들이 있다면 그 내용을 불러온다


        -설치
            https://xe1.xpressengine.com 접속
            상단 바에 Download 항목에 마우스를 올렸을때 나오는 'XE 자료실' 과 '마켓 허브' 중에 'XE 자료실' 선택

            XE core 다운로드 버튼 클릭
            다운로드 버튼 클릭

            안될 경우에는 아까 보였던 GitHub project 버튼을 클릭해서 Git hub 에서 다운로드받기
            (*https://korbillgates.tistory.com/215 발췌 '깃허브 코드 다운로드'키워드)

            FTP 로 리눅스에게 파일 전달
            (* p5 vsftpd , p5 vsftpd 2 conf 에 이와 동일할 상황에 대한 대처방법이 서술되어있습니다)

            unzip xpressengine-master.zip
            압축 풀기 (Complete 또는 Success 출력이 안돼도 괜찮습니다.)

            
            [root@server public_html]# ll
            합계 49832
            drwxr-xr-x 11 root root     4096  1월 23  2017 db
            -rw-r--r--  1 root root       12  1월  2 14:38 index.html
            -rw-rw-r--  1 main main       21  1월  4 06:11 ini.txt
            -rw-r--r--  1 main main 10580812  1월  4 05:53 phpMyAdmin-4.4.15.10-all-languages.zip
            drwxr-xr-x 15 root root     4096 11월  5 20:59 xpressengine-master
            -rw-r--r--  1 main main 40422146  1월  5 20:13 xpressengine-master.zip
            [root@server public_html]#
            압축파일에서 zip 파일 확장자만 없어진 채로 디렉터리파일이 생기는것을 볼 수 있습니다.
            (*이후 과정에서 이걸 브라우저에 입력해야하니 mv 명령어를 통해 디렉터리명을 바꿔줘야 편해집니다.)








f1_sshd_config.txt
    통상적으로는 /etc/ssh/sshd_config 라는 경로에 저장되어있는
    ssh 와 관련된 데이터를 다루는 파일이다.

    38번 행에
    #PermitRootLogin yes
    #뒤에 공백이 있으면 그냥 예시문이고
    공백이 없으면 실질적으로 바로 적용시킬 수 있는 값이다.


    #이 써져있는 곳은 기본적으로 주석이 맞다.
    다만 이 # 기호 뒤에 공백이 있느냐 없느냐에 따라서 조금씩 결과나 역할이 달라진다.

    주석기호(#)뒤에 공백이 있는것은 그저 설명이다. 주석 이외에 역할을 하지는 않는다.
    주석기호 뒤에 공백이 없는 것은 실질적으로 적용되는 값이다.
    주석기호 뒤에 공백이 없을 경우, 실질적으로 적용되는 값이 있기도 하고 없기도 한데
    이는 man 명령을 통해서 알 수 있다.

    man sshd_config

    위의 명령어를 입력하면 기본값이 어디인지, 어떻게 적용되어 있는지 알 수 있다.
    예를 들면 Port(포트)에 대해서 궁금하다면 위의 명령어를 입력해서 sshd_config 에 관해 열람하고 실질적으로 확인하면 된다.



    19번 행 부근에
    #ListenAddress 0.0.0.0
    이라고 되어 있는 부분의 의미는 
    '모든 아이피로 접속 가능하다.'라는 의미의 구문을
    주석처리 해놓은것이다
    ListenAddress 192.168.127.128
    으로 되어 있으면
    '192.168.127.128'로만 접속 가능하다.
    라는 뜻이다.
    기본적인 개념으로서는 '나에게 접근할 수 있는 길'자체를 제한함으로써 보안성을 높이는것이다.


    20번때 부근에
    HostKey /etc/ssh/ssh_host_rsa_key 같은 문항들이 있는데
    이는 ssh 관련 프로세스를 사용 또는 활용할때 쓰일
    키값들을 설정해주는 곳이다.
    그냥 그렇다고 알아만 두면 된다고 한다.


    28번 행 부근에
    #RekeyLimit default none
    이라고 되어 있는 곳이 있는데
    기본적으로 대칭키 암호화 방식으로써는
    아무리 ssh가 암호화된 통신방식이라고 해도
    같은 키만 계속 쓰면 결국에는 보안에 허점이 점점 커지기 마련이니
    주기적으로 새 키로 갈아주는 것을 관리하는 문항이라고 한다.

    30번 부근에 
    #Logging
    #SyslogFacility AUTH
    SyslogFacility AUTHPRIV

    # Authentication:
    같은 문항들이 있는데
    '로그'(기록)에 관련한 설정 부분인데
    SyslogFacility뒤에 AUTH(어젠트케이션[Authentication])과 AUTHPRIV(어젠트케이션 프라이빗[ Authentication Private]) 이 두가지가 있다
    현재는 AUTHPRIV만 사용한다.

    33번 부근에
    #LogLevel INFO
    라는 곳에는 로그을 어느정도로 많이 남기느냐에 대한것이다.

    37번쯤에
    #LoginGraceTime 2m
    이라는 곳이 있는데
    로그인 대기시간을 나타낸다.(s = second, m = minute)

    38번 행에
    #PermitRootLogin yes
    라고 되어있는데,
    putty나 telnet으로 접속할때 root로 바로 접속할 수 있는지에 관한 정보를 담았다.
    yes로 되어있을때는 root로 접근이 가능하지만 no로 되어있을때는 불가능하다.

    39번 행에
    #StrictModes yes
    라는 부분은 '암호를 입력하지 않고도 접속할 수 있는지'에 관한 부분이다.

    40번 행에
    #MaxAuthTries 6
    이 부분은 최대 몇번 암호를 입력할 수 있는지에 관한 내용이다. 6번째로 올바른 암호를 입력하는것에 실패했다면 연결이 끊긴다.

    41번 행에
    #MaxSessions 10
    최대로 몇개까지의 연결을 할 수 있게 할건지에 관한 설정이다.
    10이라면 최대 10개의 단말기와 연결될 수 있다.

    그 바로 밑에 이러한 구문에는
    #PubkeyAuthentication yes
    공개키를 이용한 인증을 허용할건지에 관한 내용이다.


    123번 행 쯔음에
    #Banner none
    이라는 부분은 경고문 또는 안내문에 관한 사항이다.






f2_vsftpd_conf.txt
    이 문서는
    ftp에 관한 내용을 다루는
    /etc/vsftpd/vsftpd.conf 에 대해 서술합니다.

    12번행 즈음에 있는
    anonymous_enable = YES
    는, 알려지지 않은 사용자(어나니머스)의 출입을 허가하는지에 관한 내용입니다

    16번행 쯤에 있는
    local_enable=YES
    는, 로컬 사용자(root,itbank,ghdwpaks 등등의 알려지고, 등록된 사용자)의 출입을 허가하는지에 관한 내용입니다.

    19번행 쯤에 있는
    write_enable=YES 는
    로컬 사용자에게 뭔가 작성할 권한을 주는가에 대한 내용입니다.

    23번행 쯤에 있는
    local_umask=022 는
    생성되는 파일과 폴더의 허가권에 대한 내용입니다.

    29번
    anon_mkdir_write_enable=YES
    어나니머스(신원 미확인)유저가 폴더나 파일을 만드는것에 대한 권한을 설정합니다.

    33번 행 쯤에 있는
    #anon_mkdir_write_enable=YES
    어나니머스(신원 미확인)유저가 mkdir을 통해 폴더를 만들 수 있게 허락해주는지에 관한 내용입니다.

    43번 행에 있는
    connect_from_port_20=YES
    20번 포트를 사용할건지에 관한 내용입니다.(TCP의 ftp 포트)


    48번 행에 있는
    chown_uploads=YES
    위에 29번 행과 33번 행의 설정값들을 조정하여 익명 사용자가 업로드를 할 수 있게 해줬을 경우(익명 사용자는 소유권이 이상하게 기본설정 돼있기 때문에),익명사용자의 의도대로 소유권을 바꿔줄것인지에 관한 내용입니다. 

    49번 행에 있는
    chown_username=whoever
    48번 행에 있는 chown_uploads에 관한 설정을 끝마쳤으면 설정해주는 곳입니다. 직접적으로 사용할때는 주석처리 된 #과 whoever을 지워주고, whoever이 있는 자리에 '특정 사용자'를 적어넣습니다. 기본적인 소유권을 '특정 사용자'로 바꿔줍니다.

    60번 행에 있는
    idle_session_timeout=600
    세션 연결에 대한 유효기간입니다.

    63번 행에 있는
    data_connection_timeout=120
    데이터 전송 이후 120초 동안 세션을 연결한다는 뜻입니다.

    87번 행에 있는
    ftpd_banner=Welcome to blah FTP service.
    는 사용자들이 ftp 서버에 접속했을때 최초로 표시되는 안내문(배너)입니다.

    91번 행에 있는
    deny_email_enable=YES
    익명 사용자가 대부분 이메일을 입력하고 접속을 하는데, 특정 이메일 주소가 접속을 하는것을 차단하는것에 대한 스위치 설정입니다.

    93번 행에 있는
    banned_email_file=/etc/vsftpd/banned_emails
    위에 91번 행에서 설정한 값과 연결되어 있는데, 어떤 이메일을 차단할건지에 관한 목록을 기록한 파일의 경로를 나타냅니다.

    101번 행에 있는
    chroot_local_user=YES
    로컬 사용자 격리에 대한 스위치 문장입니다. YES라고 하면 격리를 하겠다는것이고, NO로 되어있거나 주석처리 되어있으면 하지 않는다는 의미입니다.

    102번 행에 있는
    chroot_list_enable=YES
    는 위의 chroot_local_user와 같은 값으로 설정해놓는게 좋습니다. 거의 비슷한 역할을 수행합니다.


    104번 행에 있는
    chroot_list_file=/etc/vsftpd/chroot_list
    는, 로컬 사용자들을 격리하는것에 대한 설정입니다.
    만약 /etc/vsftpd/chroot_list 같은 경로가 없거나, 로컬 사용자의 권한으로써 열어볼 수 없는 경우에는 접속 자체가 차단됩니다.
    어나니머스(익명 또는 알려지지 않은)사용자에 대한 별 다른 조치를 하지 않은 리눅스 서버에 들어가보면 기본적으로 최상위 디렉토리에 접근할 수 있는것처럼 보이게 됩니다.
    하지만 이것은 진짜로 최상위 디렉토리에 접근하는것이 아니라 /var/ftp/에 접속하는것이며(대부분은 여기에 pub이라는 디렉토리 하나만 존재합니다.)실질적으로는 최상위 디렉토리에 접근 할 수 있도록 설정되어있는것이 아닙니다.
    이렇게 익명 사용자의 활동 및 탐색범위에 대한 설정은 이들을 격리하는 역할을 하며, 이들이 시스템의 치명적이고 중요한 부분에 접근하지 못하도록 막습니다.
    이것을 로컬 사용자에게도 똑같이 적용시킵니다.
    (*500 OOPS: vftpd: refusing to run with writable root inside chroot() 같은 오류문이 나올경우 allow_writeable_chroot=YES 라는 구문을 밑줄에 추가하여 오류 재발을 방지해야합니다.)


    110번 행의
    ls_recurse_enable=YES
    ls 명령어의 recurse(-R)옵션을 사용할 수 있게 할것인지에 관한 내용입니다. 이게 중요한 이유는 ls의 R의 옵션이 '하위 디렉토리 및 파일까지 전부 출력한다'에 관한 내용인데, 만약 최상위 폴더에 접근이 가능할 경우 ls -lR / 같은 명령어를 통해 시스템의 전체적인 구조를 알 수 있게 돼버리기 때문에 통제해야하는 요소들 중에 등록됐습니다. 이외의 이유로써는 리눅스 서버의 연산력을 분포시켜 DDOS, DOS 공격을 방지하기 위함입니다.
    기본적으로는 주석처리로 막혀있으며, -R 옵션을 사용할 수 있게 해주려면 주석을 풀거나 NO로 되어있는것을 YES로 바꿔주면 됩니다.

    115번 행의
    listen=0
    데몬을 사용하는 종류는 크게 두가지가 있다.
    일반 데몬과 스탠드 얼론 데몬이다.
    일반 데몬은 기본적으로 슈퍼 데몬이라는 상위 데몬에 종속되어서 사용되는 데몬이다.
    스탠드 얼론 데몬은 반대로 종속되지 않는 데몬이다.
    이 listen은 이 ftp 데몬을 일반 데몬으로 사용할건지, 스탠드 얼론 데몬으로 사용할건지에 관한 스위치입니다. YES로 되어어있다면 스탠드 얼론으로 사용되고, NO로 되어있거나 주석처리가 되어있으면 다른 데몬에 종속되어 사용되는것을 뜻합니다. centOS 6버전 대에서는 네트워크 슈퍼데몬 XID라는것이 있어서 NO로 되어있으면 기본적으로 이것에 종속되어있었지만, CentOS 6에서는 YES로 표기되어 기본적으로 스탠드 얼론 데몬으로써 사용되었습니다. 다만
    CentOS 7 버전으로 올라오면서 Systemd가 메인 프로세스가 되면서 이 Systemd에 종속되어 사용됩니다. 하지만 IPv4의 보안상의 이유로써 NO로 되어있거나 주석처리가 되어있었으므로 이 아래의

    124번 행에서는
    listen_ipv6=YES
    IPv6를 통한 ftp데몬을 스탠드 얼론 데몬으로 사용함을 뜻합니다.


    (*

    [root@server /]# cat /etc/vsftpd/vsftpd.conf
    # Example config file /etc/vsftpd/vsftpd.conf
    #
    # The default compiled in settings are fairly paranoid. This sample file
    # loosens things up a bit, to make the ftp daemon more usable.
    # Please see vsftpd.conf.5 for all compiled in defaults.
    #
    # READ THIS: This example file is NOT an exhaustive list of vsftpd options.
    # Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's
    # capabilities.
    #
    # Allow anonymous FTP? (Beware - allowed by default if you comment this out).
    anonymous_enable=YES
    #
    # Uncomment this to allow local users to log in.
    # When SELinux is enforcing check for SE bool ftp_home_dir
    local_enable=YES
    #
    # Uncomment this to enable any form of FTP write command.
    write_enable=YES
    #
    # Default umask for local users is 077. You may wish to change this to 022,
    # if your users expect that (022 is used by most other ftpd's)
    local_umask=022
    #
    # Uncomment this to allow the anonymous FTP user to upload files. This only
    # has an effect if the above global write enable is activated. Also, you will
    # obviously need to create a directory writable by the FTP user.
    # When SELinux is enforcing check for SE bool allow_ftpd_anon_write, allow_ftpd_full_access
    #anon_upload_enable=YES
    #
    # Uncomment this if you want the anonymous FTP user to be able to create
    # new directories.
    #anon_mkdir_write_enable=YES
    #
    # Activate directory messages - messages given to remote users when they
    # go into a certain directory.
    dirmessage_enable=YES
    #
    # Activate logging of uploads/downloads.
    xferlog_enable=YES
    #
    # Make sure PORT transfer connections originate from port 20 (ftp-data).
    connect_from_port_20=YES
    #
    # If you want, you can arrange for uploaded anonymous files to be owned by
    # a different user. Note! Using "root" for uploaded files is not
    # recommended!
    #chown_uploads=YES
    #chown_username=whoever
    #
    # You may override where the log file goes if you like. The default is shown
    # below.
    #xferlog_file=/var/log/xferlog
    #
    # If you want, you can have your log file in standard ftpd xferlog format.
    # Note that the default log file location is /var/log/xferlog in this case.
    xferlog_std_format=YES
    #
    # You may change the default value for timing out an idle session.
    #idle_session_timeout=600
    #
    # You may change the default value for timing out a data connection.
    #data_connection_timeout=120
    #
    # It is recommended that you define on your system a unique user which the
    # ftp server can use as a totally isolated and unprivileged user.
    #nopriv_user=ftpsecure
    #
    # Enable this and the server will recognise asynchronous ABOR requests. Not
    # recommended for security (the code is non-trivial). Not enabling it,
    # however, may confuse older FTP clients.
    #async_abor_enable=YES
    #
    # By default the server will pretend to allow ASCII mode but in fact ignore
    # the request. Turn on the below options to have the server actually do ASCII
    # mangling on files when in ASCII mode. The vsftpd.conf(5) man page explains
    # the behaviour when these options are disabled.
    # Beware that on some FTP servers, ASCII support allows a denial of service
    # attack (DoS) via the command "SIZE /big/file" in ASCII mode. vsftpd
    # predicted this attack and has always been safe, reporting the size of the
    # raw file.
    # ASCII mangling is a horrible feature of the protocol.
    #ascii_upload_enable=YES
    #ascii_download_enable=YES
    #
    # You may fully customise the login banner string:
    #ftpd_banner=Welcome to blah FTP service.
    #
    # You may specify a file of disallowed anonymous e-mail addresses. Apparently
    # useful for combatting certain DoS attacks.
    #deny_email_enable=YES
    # (default follows)
    #banned_email_file=/etc/vsftpd/banned_emails
    #
    # You may specify an explicit list of local users to chroot() to their home
    # directory. If chroot_local_user is YES, then this list becomes a list of
    # users to NOT chroot().
    # (Warning! chroot'ing can be very dangerous. If using chroot, make sure that
    # the user does not have write access to the top level directory within the
    # chroot)
    chroot_local_user=YES
    chroot_list_enable=YES
    # (default follows)
    chroot_list_file=/etc/vsftpd/chroot_list
    allow_writeable_chroot=YES
    #
    # You may activate the "-R" option to the builtin ls. This is disabled by
    # default to avoid remote users being able to cause excessive I/O on large
    # sites. However, some broken FTP clients such as "ncftp" and "mirror" assume
    # the presence of the "-R" option, so there is a strong case for enabling it.
    #ls_recurse_enable=YES
    #
    # When "listen" directive is enabled, vsftpd runs in standalone mode and
    # listens on IPv4 sockets. This directive cannot be used in conjunction
    # with the listen_ipv6 directive.
    listen=NO
    #
    # This directive enables listening on IPv6 sockets. By default, listening
    # on the IPv6 "any" address (::) will accept connections from both IPv6
    # and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6
    # sockets. If you want that (perhaps because you want to listen on specific
    # addresses) then you must run two copies of vsftpd with two configuration
    # files.
    # Make sure, that one of the listen options is commented !!
    listen_ipv6=YES

    pam_service_name=vsftpd
    userlist_enable=YES
    tcp_wrappers=YES

    )








f3_fstab.txt
    이 문서는
    오토 마운트(auto mount)에 관한 내용을 다루는
    /etc/fstab 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.
    (*
    #
    # /etc/fstab
    # Created by anaconda on Tue Nov  9 05:29:34 2021
    #
    # Accessible filesystems, by reference, are maintained under '/dev/disk'
    # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
    #
    /dev/mapper/centos-root /                       xfs     defaults        0 0
    UUID=432824f7-0783-4b09-9f14-9755d311b8dc /boot                   xfs     defaults        0 0
    /dev/mapper/centos-swap swap                    swap    defaults        0 0
    /dev/sda1       /test/Linux     xfs     defaults        0 0
    )

    auto mount
    - 기본적으로 마운트 된 모든 장치는 시스템 종료 시 전부 마운트 해제
        > 시스템 부팅 시 자동으로 마운트 되도록 설정 되어있는 장치들만 마운트 된 상태로 부팅

    - 오토 마운트 설정하는 파일 : /etc/fstab
        > OS를 설치하면 자동으로 생성되고 설정 되어있는 파일

    - /etc/fstab 파일 내용 형식

        장치명   마운트포인트   장치의 fstype   마운트 옵션   dump 운용   부팅 시 fsck 동작

        * 형식 설명
        장치명		: 오토마운트 할 장치의 이름을 절대경로로 작성
                현재는 기본 설정된 장치들이 장치명이 아닌 UUID 값으로 작성
                (UUID : 장치의 고유 값, IDE 관련 버그 때문에 UUID가 기본)

        마운트포인트	: 장치를 마운트 할 디렉토리를 절대경로로 작성

        장치의 fstype	: 마운트 할 장치의 파일시스템 형식을 작성

        마운트 옵션	: 오토마운트를 하면서 적용시킬 옵션 작성(defaults : 기본적인 옵션들을 모아놓은 옵션)

        dump 운용	: 장치의 dump를 사용할 것인지 확인(0 : 사용 안 함, 1 : 사용)
                단, CentOS 7 버전부터는 0으로 고정(systemd가 알아서 사용)

        부팅 시 fsck 동작	: 부팅 시 filesystem(= partition)의 상태가 정상인지 확인
                (0 : 사용 안 함, 1 : root partition = /, 2 : other partition)
                단, CentOS 7 버전부터는 0으로 고정(systemd가 알아서 check)

    의미 해석

    /dev/sda1       /test/Linux     xfs     defaults        0 0
    장치명          : /dev/sda1
    마운트 포인트   : /test/Linux
    장치의 fs type  : xfs
    마운트 옵션     : default
    dump 운용       : 0
    부팅시 fsck 동작: 0





f4_auto_master.txt
    이 문서는
    오토 마운트(auto mount)에 관한 내용을 다루는
    /etc/auto.master 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.


    (데몬)서비스 자체에 대한 정보를 다루는
    autofs.conf 파일에 비해
    auto.master 파일은 실질적인 마운트에 관한 내용을 다룹니다.
    핵심입니다.


    /misc /etc/auto.misc
    오토마운트 포인트들을 기록해놓은 파일의 경로에 대한 기록파일입니다.
    '오토마운트를 하면 장치가 어딘가에 마운트 되잖아요? 그 장치가 마운트 되는 마운트포인트들을 /misc 에 저장을 하고 그 /misc 에 만들어진 마운트 포인트들은 /etc/auto.misc 파일에 기록됩니다.'


f4_auto_misc.txt
    이 문서는
    오토 마운트(auto mount)에 관한 내용을 다루는
    /etc/auto.master 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.


    (데몬)서비스 자체에 대한 정보를 다루는
    autofs.conf 파일에 비해
    auto.master 파일은 실질적인 마운트에 관한 내용을 다룹니다.
    auto.misc 파일은 오토마운트 포인트들을 기록해놓은 파일의 경로에 대한 기록파일입니다.
    핵심입니다.

    이 파일 끝에는
    nfs_auto    -rw,hard,intr   192.168.127.128:/nfs
    이런식의 구문을 적을수 있습니다. 해석은 아래와 같습니다.

    nfs_auto    : 마운트 포인트 실질적인 경로는 /misc/nfs_auto 로 됩니다.(디렉토리입니다.)
    -rw         : read , write 를 하겠다는 의미입니다. 읽기 전용은 ro(read only) 로 적어야합니다.
    ,           : 구분자
    hard        : soft와 hard가 있습니다. hard라면 연결이 끊긴다면 연결 시도를 더 하지 않고 그저 끊어버립니다. soft라면 연결이 끊길경우 연결을 계속해서 시도합니다.
    ,           : 구분자
    intr        : 비정상 종료가 발생했을 경우, 연결을 유지한다는 내용입니다.
    192.168.127.128:/nfs : 장치명입니다. 서버가 공유해주는 디렉토리에 대한 부분입니다.



f4_autofs_conf.txt
    이 문서는
    오토 마운트(auto mount)에 관한 내용을 다루는
    /etc/autofs.conf 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.

    master_map_name = auto.master
    auto.master은 자동으로 마운트될 장치에 대한 각종 장치들에 대한 정보가 담깁니다. 구문은 분산되어 있는 autofs 서비스 파일의 일부를 나타냅니다. 데몬 동작 또는 서비스 동작에 대한 설정 내용은 autofs.conf 안에 들어가있다. 

    timeout = 300
    마운트 이후 아무것도 하지 않았을때, 마운트가 해제되는 시간을 나타냅니다.

    51번 행 쯤에
    browse_mode = no
    마운트 된 것들을 보여줍니다. 기본설정은 보안상으로 no 로써 보여주지 않습니다. 이 browse_mode 가 정상적으로 설정되어 있지 않으면, 자동(auto)마운트를 했다 하더라도 정상적으로 사용할 수 없습니다.

f4_exports
    이 문서는
    원격 파티션 공유 nfs 에 관한 내용을 다루는
    /etc/exports 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.
    https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hanajava&logNo=220422771247
    와
    https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=musalyh&logNo=220710277058
    와
    https://fliedcat.tistory.com/174
    으로부터 발췌하여 작성했습니다.

    해당 exports 문서는 nfs에서 다루는 파티션 공유에 대한 내용이 기술되어 있어야만 하는 파일입니다.

    예를 들어
    /nfs    192.168.10.129(rw,no_root_squash,sync)
    입력되어 있다면 뜻은 아래와 같습니다 .

    /nfs            : 제공자 측에서 제공해줄 파티션이 마운트된 파일 위치
    192.168.10.129  : 사용자 측의 아이피
    rw              : 작업 형식. 일고, 쓰는것 모두를 허용한다는 내용이다.
    no_root_squash  : client의 root를 서버의 root로 매핑 (최상위 관리자 접속으로 시도하는 경우, 상대방의 최상위 관리자의 이름이 어떻게 되든지간에 '최상위 관리자'라는 것에 맞춰 연결해줌)
    sync            : 파일 시스템이 변경되면 즉시 동기화


    이외에도 괄호 안에 담기는것들에 관해서는 다음과 같은 내용또한 있습니다.
    ro          : read only
    rw          : read and write
    root_squash : client의 root를 서버의 nobody로 매핑 (상대방이 나에게 접속할때 root 로써 접근하게 되면 최상위 관리자 root로는 받지 않는다는 내용. 일반 사용자인 root로써 접근하게 됨)
    no_root_squash : client의 root를 서버의 root로 매핑 (상대방이 나에게 접속할때 root 로써 접근하게 되면 내 root권한에 맞춰 root의 사용권을 넘김)
    all_squash  : root를 제외하고 서버와 클라이언트 사용자를 동일한 권한으로 설정함. (* 모든 uid, gid를 익명사용자에게 매핑합니다. 디폴트 값입니다.)
    no_all_squash : no_root_squash 와 동일, 디폴트 값이다.
    insecure    : 인증되지 않은 접근이 가능함.
    noaccess    : 지정된 디렉토리는 접근을 금지함
    secure      : client 마운트 요청시 포트를 1024 이하로 설정함. 이는 well known 포트만을 사용하기 위함임.
    sync        : 파일 시스템이 변경되면 즉시 동기화


f5_exports.txt
    이 문서는
    원격 파티션 공유 nfs 에 관한 내용을 다루는
    /etc/exports 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.
    https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hanajava&logNo=220422771247
    와
    https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=musalyh&logNo=220710277058
    와
    https://fliedcat.tistory.com/174
    으로부터 발췌하여 작성했습니다.

    해당 exports 문서는 nfs에서 다루는 파티션 공유에 대한 내용이 기술되어 있어야만 하는 파일입니다.

    예를 들어
    /nfs    192.168.10.129(rw,no_root_squash,sync)
    입력되어 있다면 뜻은 아래와 같습니다 .

    /nfs            : 제공자 측에서 제공해줄 파티션이 마운트된 파일 위치
    192.168.10.129  : 사용자 측의 아이피
    rw              : 작업 형식. 일고, 쓰는것 모두를 허용한다는 내용이다.
    no_root_squash  : client의 root를 서버의 root로 매핑 (최상위 관리자 접속으로 시도하는 경우, 상대방의 최상위 관리자의 이름이 어떻게 되든지간에 '최상위 관리자'라는 것에 맞춰 연결해줌)
    sync            : 파일 시스템이 변경되면 즉시 동기화


    이외에도 괄호 안에 담기는것들에 관해서는 다음과 같은 내용또한 있습니다.
    ro          : read only
    rw          : read and write
    root_squash : client의 root를 서버의 nobody로 매핑 (상대방이 나에게 접속할때 root 로써 접근하게 되면 최상위 관리자 root로는 받지 않는다는 내용. 일반 사용자인 root로써 접근하게 됨)
    no_root_squash : client의 root를 서버의 root로 매핑 (상대방이 나에게 접속할때 root 로써 접근하게 되면 내 root권한에 맞춰 root의 사용권을 넘김)
    all_squash  : root를 제외하고 서버와 클라이언트 사용자를 동일한 권한으로 설정함. (* 모든 uid, gid를 익명사용자에게 매핑합니다. 디폴트 값입니다.)
    no_all_squash : no_root_squash 와 동일, 디폴트 값이다.
    insecure    : 인증되지 않은 접근이 가능함.
    noaccess    : 지정된 디렉토리는 접근을 금지함
    secure      : client 마운트 요청시 포트를 1024 이하로 설정함. 이는 well known 포트만을 사용하기 위함임.
    sync        : 파일 시스템이 변경되면 즉시 동기화



f6_samba_smb_conf.txt
    (*
    현재 실전 테스트 결과, 자격증명을 요구하는 오류가 발생됨이 확인됐습니다.
    이러한 경우, 현재 최선으로써는
    root를 제외한, samba 를 제공하는 리눅스에 등록된 아무 사용자의 정보를 입력하여 로그안하는것 뿐입니다.
    사용자 계정 생성 : useradd
    사용자 계정 정보 : id [사용자 아이디]
    새로운 오류 해결이 발견되는 즉시 업데이트를 하겠습니다.
    )
    이 문서는
    공유 폴더 제공 서비스(samba)에 관한 내용을 다루는
    /etc/samba/smb.conf 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.
    https://blog.naver.com/ncloud24/221499582757
    으로부터 발췌했습니다.

    (*

    # See smb.conf.example for a more detailed config file or
    # read the smb.conf manpage.
    # Run 'testparm' to verify the config is correct after
    # you modified it.

    [global]
            workgroup = WORKGROUP
            security = user
            map to guest = bad user

            passdb backend = tdbsam

            printing = cups
            printcap name = cups
            load printers = yes
            cups options = raw

    [homes]
            comment = Home Directories
            valid users = %S, %D%w%S
            browseable = No
            read only = No
            inherit acls = Yes

    [printers]
            comment = All Printers
            path = /var/tmp
            printable = Yes
            create mask = 0600
            browseable = No

    [print$]
            comment = Printer Drivers
            path = /var/lib/samba/drivers
            write list = @printadmin root
            force group = @printadmin
            create mask = 0664
            directory mask = 0775

    )

    이번 정보분석에서는 

    [global]
            workgroup = WORKGROUP
            security = user
            map to guest = bad user

            passdb backend = tdbsam

            printing = cups
            printcap name = cups
            load printers = yes
            cups options = raw


    [AnonShare]
            comment = for anonymous
            path = /samba/anon
            guest ok = Yes


    [UserShare]
            comment = for local user
            path = /samba/itbank
            read only = No
            writeable = Yes
            valid users = @itbank


    구문을 중심으로 확인해보겠습니다.

    [global]    : 전체적으로 적용되는 사항
    workgroup   : 
    map to guest: 익명 사용자의 대우
    guest ok    : 익명 사용자의 접근 가능 여부
    read only   : 오직 읽기만 가능(쓰기 불가능)하게 설정할것인지
    valid users : 연결할 사용자 여부

    이외의 속성으로는 다음과같은것들이 있습니다.

    comment     = share #코멘트
    path        = /home #공유 디렉토리의 경로
    public      = no #guest 접속 허용 여부를 확인합니다.
    writable    = yes # 쓰기 여부를 확인합니다.
    printable   = no # 프린터 사용 여부를 확인합니다. 
    write list  = root # 접속할 계정을 선택합니다. 여러개인 경우 띄어쓰기로 구분합니다.
    create mask = 0777 # 생성 권한을 선택합니다.
    directory mask  = 0777 # 디렉토리 권한을 선택합니다.




f7_host.txt
    이 문서는
    도메인 평문 제공 서비스(DNS)에 관한 내용을 다루는
    /etc/hosts 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.

    127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
    ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6

    '
    192.168.127.128     www.naver.com
    www.naver.com 이 입력되면
    192.168.127.128 으로 연결한다는 내용이다.
    '

    127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
    ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6


    같은 구문이 적혀있을겁니다.

    지금 위와 같은 구문의 대부분의 의미는 루프 백(Loop back) 주소 입니다.
    127.0.0.1 이나 localhost 같은 의미이고, 대부분 그렇게 적혀있는것을 알 수 있습니다.
    루프 백 아이피 : 내가 어떤 아이피를 쓰고있던간에, 내 자신을 찾아갈 수 있게 해줌

    띄어쓰기로 구분된 단어 하나하나가 전부 다 각각의 문자주소(FQDN)가 된다.
    그 FQDN에 대한 아이피 주소가 루프 벡 주소가 된다는 내용이다.

    우리가 컴퓨터에다가 localhost 문자를 입력했을때, 나 자신을 찾아갈 수 있는 이유가 저 loop back 주소(IP)가 매핑이 되었기 때문이다

    127.0.0.1
    IPv4의 루프 벡에서 사용되는 주소

    ::1 
    IPv6의 루프 벡에서 사용되는 주소


    이 아래에는 실질적인 사용이 아닌, 이 hosts 파일에 대한 의미가 담겨있습니다.
    기본적으로 리눅스를 사용하는 한 pc의 이 hosts 파일이 변조된다면 굉장히 위험한 이유는 링크를 타던, 직접입력을 하던, FQDN 가 쓰인다면 모든 상황에서 적용을 받게 됩니다.
    '의도치 않은 사이트에 접속한다.'라는 상황으로 인해 벌어질수 있는 수많은 상황에 대한 서술은 하지 않겠습니다.


f8_resolv_conf.txt
    이 문서는
    도메인 평문 제공 서비스(DNS)에 관한 내용을 다루는
    /etc/resolv.conf 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.

    '
    # Generated by NetworkManager
    nameserver 192.168.127.2
    '

    기본적인 형식은 nameserver 이라는 단어 뒤에 주소가 들어가있는 형식입니다.
    예시 :

    nameserver 192.168.127.2
    nameserver 168.126.63.1

    www.ghdwpaks.com
    이라는 주소에 대한 정보를 검색하는 상황에서

    위와같이 적혀있다면
    192.168.127.2
    를 거친다음, 관련 정보를 찾아내지 못하면

    168.126.63.1
    를 거친다음, 관련정보를 찾아낸다면 해당 정보를 통해 찾아가고
    그렇지 못한다면 신호 없을을 반환합니다.




f9_hosts.txt
    이 문서는
    도메인 평문 제공 서비스(DNS)에 관한 내용을 다루는
    /etc/hosts 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.

    127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
    ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

    위와 같은 내용은... 루프 백에 관한것이기 때문에 여러가지가 써져있고,

    192.168.127.128     www.naver.com www.google.com
    같은 내용을 추가하고, DNS 서비스를 초기화시키면

    브라우저로 접속하거나 나 ping 을 보낼때
    www.naver.com
    또는
    www.google.com
    으로 접속하려 한다면

    192.168.127.128 로 연결됩니다.

    신호가 없거나, 응답이 없다면 크게 문제가 있는게 아니라
    해당 아이피를 가진 기기에서 웹페이지를 열지 않았기 때문입니다.





f10_dhcpd_conf.txt
    이 문서는
    아이피 동적 할당을 뜻하는 DHCP(Dynamic Host Configuration Protocol)에 관한 내용을 다루는
    /etc/dhcp/dhcpd.conf 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.


    #
    # DHCP Server Configuration file.
    #   see /usr/share/doc/dhcp*/dhcpd.conf.example
    #   see dhcpd.conf(5) man page
    #


    입력 예시 :
    subnet 192.168.127.0 netmask 255.255.255.0 {
        range dynamic-bootp 192.168.127.201 192.168.127.220;
        option subnet-amsk 255.255.255.0;
        option routers 192.168.127.2;
        option domain-name-servers 192.168.127.2;
        default-lease-time 345600;
        max-lease-time 691200;
    }

    이번에 관리하는 네트워크 아이디는 192.168.127.0 이고, 서브넷마스크는 255.255.255.0 이다.
    관리하는 아이피의 범위는 192.168.127.201 부터 192.168.127.220 까지 이며
    분배되는 각 주소들의 서브넷 마스크는 255.255.255.0 이다.
    각 주소들의 게이트웨이는 192.168.127.2이다.
    FQDN 을 가져오는 DNS 의 주소는 192.168.127.2 이다.
    최소 사용 시간은 345600 초 이며 (96시간, 4일)
    최대 사용 시간은 694200 초 이다 (192시간, 8일)

    subnet [1] netmask [2] {
        range dynamic-bootp [3-1] [3-2];
        option subnet-mask [4];
        option routers [5];
        option domain-name-servers [6];
        default-lease-time [7];
        max-lease-time [8];
    }
    [1] 장치에서 관리하는 네트워크 아이디
    [2] '장치에서 관리하는 네트워크 아이디' 에 대한 서브넷 마스크
    [3] 분배할 실질적인 주소를 나타낸다.
    (*[3-1]부터 [3-2] 까지 분배하는것을 타나낸다.)
    [4] 분배될 주소들의 서브넷 마스크를 나타낸다.
    [5] 게이트웨이를 나타낸다.
    [6] DNS 의 아이피를 나타낸다.
    [7] 최소 사용 시간. 이 시간이 초과하게 된다면, 갱신을 시도하게 된다. 이 시간이 지나고 나면 다시 갱신을 시도하는데, 이 갱신에 성공하게 되면 사용시간이 없어지게 된다.(0으로 돌아게 된다.)
    [8] 최대 사용 시간. 이 시간까지 갱신에 실패하게 된다면 



f11_dhcpd_leases.txt
    이 문서는
    아이피 동적 할당을 뜻하는 DHCP(Dynamic Host Configuration Protocol)에 대한
    현재 할당되어있는 아이피 정보를 담고있는 
    /var/lib/dhcpd/dhcpd.leases 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.

    (*
    # The format of this file is documented in the dhcpd.leases(5) manual page.
    # This lease file was written by isc-dhcp-4.2.5

    server-duid "\000\001\000\001)Y\007z\000\014)\335\306\344";

    lease 192.168.127.201 {
    starts 5 2021/12/24 22:45:10;
    ends 2 2021/12/28 22:45:10;
    cltt 5 2021/12/24 22:45:10;
    binding state active;
    next binding state free;
    rewind binding state free;
    hardware ethernet 00:50:56:c0:00:08;
    uid "\001\000PV\300\000\010";
    client-hostname "DESKTOP-HCB8KMM";
    }
    lease 192.168.127.202 {
    starts 5 2021/12/24 22:50:14;
    ends 2 2021/12/28 22:50:14;
    cltt 5 2021/12/24 22:50:14;
    binding state active;
    next binding state free;
    rewind binding state free;
    hardware ethernet 00:0c:29:a6:38:e5;
    }
    lease 192.168.127.202 {
    starts 5 2021/12/24 22:50:27;
    ends 2 2021/12/28 22:50:27;
    cltt 5 2021/12/24 22:50:27;
    binding state active;
    next binding state free;
    rewind binding state free;
    hardware ethernet 00:0c:29:a6:38:e5;
    }

    )

    이번 학습상황에서는

    lease 192.168.127.202 {
    starts 5 2021/12/24 22:50:27;
    ends 2 2021/12/28 22:50:27;
    cltt 5 2021/12/24 22:50:27;
    binding state active;
    next binding state free;
    rewind binding state free;
    hardware ethernet 00:0c:29:a6:38:e5;
    }

    를 예로 들겠습니다.

    lease 192.168.127.202 {
    와
    hardware ethernet 00:0c:29:a6:38:e5;
    을 잘 보면 되는데,

    00:0c:29:a6:38:e5 이라는 MAC 주소를 가진 객체에게 
    192.168.127.202 이라는 주소를 줬다는것을 뜻합니다.


    lease [] {
    starts 5 2021/12/24 22:50:27;
    ends 2 2021/12/28 22:50:27;
    cltt 5 2021/12/24 22:50:27;
    binding state active;
    next binding state free;
    rewind binding state free;
    hardware ethernet 00:0c:29:a6:38:e5;
    }



f12_namend_ca.txt
    이 문서는
    데몬에 관한 내용을 다루는
    /var/named/named.ca 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.

    (*
    ; <<>> DiG 9.11.3-RedHat-9.11.3-3.fc27 <<>> +bufsize=1200 +norec @a.root-servers.net
    ; (2 servers found)
    ;; global options: +cmd
    ;; Got answer:
    ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 46900
    ;; flags: qr aa; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 27

    ;; OPT PSEUDOSECTION:
    ; EDNS: version: 0, flags:; udp: 1472
    ;; QUESTION SECTION:
    ;.                              IN      NS

    ;; ANSWER SECTION:
    .                       518400  IN      NS      a.root-servers.net.
    .                       518400  IN      NS      b.root-servers.net.
    .                       518400  IN      NS      c.root-servers.net.
    .                       518400  IN      NS      d.root-servers.net.
    .                       518400  IN      NS      e.root-servers.net.
    .                       518400  IN      NS      f.root-servers.net.
    .                       518400  IN      NS      g.root-servers.net.
    .                       518400  IN      NS      h.root-servers.net.
    .                       518400  IN      NS      i.root-servers.net.
    .                       518400  IN      NS      j.root-servers.net.
    .                       518400  IN      NS      k.root-servers.net.
    .                       518400  IN      NS      l.root-servers.net.
    .                       518400  IN      NS      m.root-servers.net.

    ;; ADDITIONAL SECTION:
    a.root-servers.net.     518400  IN      A       198.41.0.4
    b.root-servers.net.     518400  IN      A       199.9.14.201
    c.root-servers.net.     518400  IN      A       192.33.4.12
    d.root-servers.net.     518400  IN      A       199.7.91.13
    e.root-servers.net.     518400  IN      A       192.203.230.10
    f.root-servers.net.     518400  IN      A       192.5.5.241
    g.root-servers.net.     518400  IN      A       192.112.36.4
    h.root-servers.net.     518400  IN      A       198.97.190.53
    i.root-servers.net.     518400  IN      A       192.36.148.17
    j.root-servers.net.     518400  IN      A       192.58.128.30
    k.root-servers.net.     518400  IN      A       193.0.14.129
    l.root-servers.net.     518400  IN      A       199.7.83.42
    m.root-servers.net.     518400  IN      A       202.12.27.33
    a.root-servers.net.     518400  IN      AAAA    2001:503:ba3e::2:30
    b.root-servers.net.     518400  IN      AAAA    2001:500:200::b
    c.root-servers.net.     518400  IN      AAAA    2001:500:2::c
    d.root-servers.net.     518400  IN      AAAA    2001:500:2d::d
    e.root-servers.net.     518400  IN      AAAA    2001:500:a8::e
    f.root-servers.net.     518400  IN      AAAA    2001:500:2f::f
    g.root-servers.net.     518400  IN      AAAA    2001:500:12::d0d
    h.root-servers.net.     518400  IN      AAAA    2001:500:1::53
    i.root-servers.net.     518400  IN      AAAA    2001:7fe::53
    j.root-servers.net.     518400  IN      AAAA    2001:503:c27::2:30
    k.root-servers.net.     518400  IN      AAAA    2001:7fd::1
    l.root-servers.net.     518400  IN      AAAA    2001:500:9f::42
    m.root-servers.net.     518400  IN      AAAA    2001:dc3::35

    ;; Query time: 24 msec
    ;; SERVER: 198.41.0.4#53(198.41.0.4)
    ;; WHEN: Thu Apr 05 15:57:34 CEST 2018
    ;; MSG SIZE  rcvd: 811
    )

    이 전체적인 파일 내용 중에서

    ;; ANSWER SECTION:
    .                       518400  IN      NS      a.root-servers.net.
    .                       518400  IN      NS      b.root-servers.net.
    .                       518400  IN      NS      c.root-servers.net.
    .                       518400  IN      NS      d.root-servers.net.
    .                       518400  IN      NS      e.root-servers.net.
    .                       518400  IN      NS      f.root-servers.net.
    .                       518400  IN      NS      g.root-servers.net.
    .                       518400  IN      NS      h.root-servers.net.
    .                       518400  IN      NS      i.root-servers.net.
    .                       518400  IN      NS      j.root-servers.net.
    .                       518400  IN      NS      k.root-servers.net.
    .                       518400  IN      NS      l.root-servers.net.
    .                       518400  IN      NS      m.root-servers.net.

    ANSWER 섹션이라고 해서 a 부터 m 까지 root-servers.net 이라는 내용으로 루트 서버들이 전부 적혀있는것을 확인할 수 있습니다.

    ;; ADDITIONAL SECTION:
    a.root-servers.net.     518400  IN      A       198.41.0.4
    b.root-servers.net.     518400  IN      A       199.9.14.201
    c.root-servers.net.     518400  IN      A       192.33.4.12
    d.root-servers.net.     518400  IN      A       199.7.91.13
    e.root-servers.net.     518400  IN      A       192.203.230.10
    f.root-servers.net.     518400  IN      A       192.5.5.241
    g.root-servers.net.     518400  IN      A       192.112.36.4
    h.root-servers.net.     518400  IN      A       198.97.190.53
    i.root-servers.net.     518400  IN      A       192.36.148.17
    j.root-servers.net.     518400  IN      A       192.58.128.30
    k.root-servers.net.     518400  IN      A       193.0.14.129
    l.root-servers.net.     518400  IN      A       199.7.83.42
    m.root-servers.net.     518400  IN      A       202.12.27.33
    a.root-servers.net.     518400  IN      AAAA    2001:503:ba3e::2:30
    b.root-servers.net.     518400  IN      AAAA    2001:500:200::b
    c.root-servers.net.     518400  IN      AAAA    2001:500:2::c
    d.root-servers.net.     518400  IN      AAAA    2001:500:2d::d
    e.root-servers.net.     518400  IN      AAAA    2001:500:a8::e
    f.root-servers.net.     518400  IN      AAAA    2001:500:2f::f
    g.root-servers.net.     518400  IN      AAAA    2001:500:12::d0d
    h.root-servers.net.     518400  IN      AAAA    2001:500:1::53
    i.root-servers.net.     518400  IN      AAAA    2001:7fe::53
    j.root-servers.net.     518400  IN      AAAA    2001:503:c27::2:30
    k.root-servers.net.     518400  IN      AAAA    2001:7fd::1
    l.root-servers.net.     518400  IN      AAAA    2001:500:9f::42
    m.root-servers.net.     518400  IN      AAAA    2001:dc3::35

    이 부분에는 a.root domain 부터 m.root domain 까지의 실제 IP 들이 적혀있습니다.
    이들은 root domain 를 찾아갈 수 있는 힌트들이 됩니다.


f12_named_conf.txt
    
    이 /etc/named.conf 파일 자체는 DNS 서버 역할에 대한 설정파일입니다.

    이 파일의 주석은 // 으로 구성됩니다.

    (*

    //
    // named.conf
    //
    // Provided by Red Hat bind package to configure the ISC BIND named(8) DNS
    // server as a caching only nameserver (as a localhost DNS resolver only).
    //
    // See /usr/share/doc/bind*/sample/ for example named configuration files.
    //
    // See the BIND Administrator's Reference Manual (ARM) for details about the
    // configuration located in /usr/share/doc/bind-{version}/Bv9ARM.html

    options {
            listen-on port 53 { 127.0.0.1; };
            listen-on-v6 port 53 { ::1; };
            directory       "/var/named";
            dump-file       "/var/named/data/cache_dump.db";
            statistics-file "/var/named/data/named_stats.txt";
            memstatistics-file "/var/named/data/named_mem_stats.txt";
            recursing-file  "/var/named/data/named.recursing";
            secroots-file   "/var/named/data/named.secroots";
            allow-query     { localhost; };

            /*
            - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
            - If you are building a RECURSIVE (caching) DNS server, you need to enable
            recursion.
            - If your recursive DNS server has a public IP address, you MUST enable access
            control to limit queries to your legitimate users. Failing to do so will
            cause your server to become part of large scale DNS amplification
            attacks. Implementing BCP38 within your network would greatly
            reduce such attack surface
            */
            recursion yes;

            dnssec-enable yes;
            dnssec-validation yes;

            /* Path to ISC DLV key */
            bindkeys-file "/etc/named.root.key";

            managed-keys-directory "/var/named/dynamic";

            pid-file "/run/named/named.pid";
            session-keyfile "/run/named/session.key";
    };

    logging {
            channel default_debug {
                    file "data/named.run";
                    severity dynamic;
            };
    };

    zone "." IN {
            type hint;
            file "named.ca";
    };

    include "/etc/named.rfc1912.zones";
    include "/etc/named.root.key";
    )

    =====================================================================================================
    이 파일의 주석은 // 으로 구성됩니다.


    options {
            listen-on port 53 { 127.0.0.1; };
            listen-on-v6 port 53 { ::1; };
            directory       "/var/named";
            dump-file       "/var/named/data/cache_dump.db";
            statistics-file "/var/named/data/named_stats.txt";
            memstatistics-file "/var/named/data/named_mem_stats.txt";
            recursing-file  "/var/named/data/named.recursing";
            secroots-file   "/var/named/data/named.secroots";
            allow-query     { localhost; };

            /*
            - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
            - If you are building a RECURSIVE (caching) DNS server, you need to enable
            recursion.
            - If your recursive DNS server has a public IP address, you MUST enable access
            control to limit queries to your legitimate users. Failing to do so will
            cause your server to become part of large scale DNS amplification
            attacks. Implementing BCP38 within your network would greatly
            reduce such attack surface
            */
            recursion yes;

            dnssec-enable yes;
            dnssec-validation yes;

            /* Path to ISC DLV key */
            bindkeys-file "/etc/named.root.key";

            managed-keys-directory "/var/named/dynamic";

            pid-file "/run/named/named.pid";
            session-keyfile "/run/named/session.key";
    };

    파일 내용들 중, 이 부분은 옵션을 담당합니다.

    listen-on port 53 { 127.0.0.1; };
    이 구문을
    listen-on port 53 { any; };
    로 바꿔주면
    '누구나 내 53 번 포트로 들어올 수 있게 하겠다'라는 내용으로 바뀌게 됩니다.


    그 바로 아래에 있는
    listen-on-v6 port 53 { ::1; };
    이 구문은, 위와 같은 내용을 IPv6 에도 적용시킨다는 내용입니다.


    allow-query     { localhost; };
    라는 구문의 뜻은, DNS 질의를 누구에게 허용해줄것이냐? 라는 내용입니다.
    allow-query 와 listen-on port 53 은 거의 같은 구문이라고 보시면 되고
    이들의 설정값을 똑같이 맞춰주는게 웬만해서는 좋습니다.


    recursion yes;
    이 구문은 이 DNS 서버를 외부에서 누구나 접근할 수 있게 하느냐에 대한 내용입니다.


    directory       "/var/named";
    dump-file       "/var/named/data/cache_dump.db";
    statistics-file "/var/named/data/named_stats.txt";
    memstatistics-file "/var/named/data/named_mem_stats.txt";
    recursing-file  "/var/named/data/named.recursing";
    secroots-file   "/var/named/data/named.secroots";
    와 같이, 파일의 경로가 절대경로로 정해져 있는것을 쉽게 볼 수 있습니다.
    이렇지 않은 경우들이 있는경우,

    directory       "/var/named";
    "/var/named" 안에 들어있다는 뜻입니다.




    logging {
            channel default_debug {
                    file "data/named.run";
                    severity dynamic;
            };
    };
    이 부분은 로그를 기록하는 로깅 영역을 담당합니다.

    file "data/named.run";
    문장을 보면, 파일의 경로가 절대경로로 설정되어있지 않는것을 볼 수 있습니다.
    그래서 기본적으로는
    "/var/named"
    경로에 있는 파일 안에 있습니다.


    zone "." IN {
            type hint;
            file "named.ca";
    };
    이 부분은 root 힌트 영역입니다.
    자세한 내용은 f12_named_ca 에서 다룹니다.



    이 영역의 기본 형식은
    zone "[zone name]" IN {
            [option];
    };

    그래서 위의 구문을 해석해보자면
    "/var/named" 안에 들어있고
    hint 영역이라고 이름지어져 있으며
    namde.ca 안에 들어있다고 합니다.



    include "/etc/named.rfc1912.zones";
    include "/etc/named.root.key";
    이 부분은 참조 영역을 나타냅니다

    앞으로 알아볼 내용은 
    include "/etc/named.rfc1912.zones";
    을 중점으로 알아보겠습니다 



f12_named_rfc.txt
    이 문서는
    도메인 평문 제공 서비스(DNS)에 관한 내용을 다루는
    /etc/named.rfc1912.zones 에 대해 서술합니다.

    이 파일은 rfc 형식에 맞춰 zone 들에 대한 내용이 모여있습니다

    파일 내용 예시에 대한 내용은 아래와 같습니다.

    (*

    // named.rfc1912.zones:
    //
    // Provided by Red Hat caching-nameserver package
    //
    // ISC BIND named zone configuration for zones recommended by
    // RFC 1912 section 4.1 : localhost TLDs and address zones
    // and http://www.ietf.org/internet-drafts/draft-ietf-dnsop-default-local-zones-02.txt
    // (c)2007 R W Franks
    //
    // See /usr/share/doc/bind*/sample/ for example named configuration files.
    //

    zone "localhost.localdomain" IN {
            type master;
            file "named.localhost";
            allow-update { none; };
    };

    zone "localhost" IN {
            type master;
            file "named.localhost";
            allow-update { none; };
    };

    zone "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa" IN {
            type master;
            file "named.loopback";
            allow-update { none; };
    };

    zone "1.0.0.127.in-addr.arpa" IN {
            type master;
            file "named.loopback";
            allow-update { none; };
    };

    zone "0.in-addr.arpa" IN {
            type master;
            file "named.empty";
            allow-update { none; };
    };

    )

    여기서


    zone "linux.edu" IN {
            type master;
            file "linux.edu.zone";
            allow-update {any;};
            allow-transfer {any;};
    };


    위와같은 영역을 '정방향 조회'라고 합니다.
    FQDN -> IP address


    zone "127.168.192.in-addr.arpa" IN {
            type master;
            file "192.168.127.zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    위와같은 영역을 '역방향 조회'라고 합니다
    IP address -> FQDN

    위와같은 '정방향 조회' 또는 '역방향 조회'에 써져있는 zone 의 이름은
    저런 형식을 쓰자고 이미 약속이 되어있다. 꼭 지켜주길 바랍니다.

    특히 '역방향 조회'의 경우에는 더더욱 잘 지켜주길 바랍니다.

    type
            이 zone 들에 대해서 'type' 이라는 항목도 있는데,
            master 영역이 있고
            slave 영역이 있습니다.

            대충 이름지어서 master 이라고 쓰는게 아닙니다

            master 영역은 '주 영역'으로써 읽고 쓰기가 자유로운 영역을 뜻합니다.
            slave 영역은 '보조 영역'으로써 읽기 전용 영역을 뜻합니다. 대부분 '주 영역' 정보를 복사해서 구성이 되므로 간단히 '주 영역의 읽기 전용 복사본'이라고 생각해도 된다.

    file
            기본적으로 이 구문 뒤에 적히는 것들은 절대 주소가 아닌 경로들 (상대경로)이므로 /var/named 안에 위치해야합니다.
            해당 zone 에 대한 상세한 설정을 담고있는 역할이 있습니다.

    allow-update
            보조 영역을 위한 항목
            주 영역에 업데이트가 발생했을때 보조영역에게 소식을 전하겠다. 라고 하는 내용입니다.

    allow-transfer
            영역 전송에 대한 항목
            



f12_zone.txt
    이 문서는
    DNS 에 관한 내용을 다루는
    '/var/named 안에 있는 zone 으로 끝나는 파일들' 에 대해 서술합니다.
    경우에 따라서 /var/named 안에 없을 수도 있으나

    zone 으로 끝나는 파일들은 변함없습니다.
    (*파일 검색 예시 : ls *.zone)

    파일 내용 예시에 대한 내용은 아래와 같습니다.

    [root@server named]# cat 192.168.127.zone
    $TTL 1D
    @       IN SOA  linux.edu.              root(
                                            0       ; serial
                                            1D      ; refresh
                                            1H      ; retry
                                            1W      ; expire
                                            3H )    ; minimum
            IN      NS      linux.edu.
            IN      A       192.168.127.128

    128     IN      PTR     www.linux.edu.
    [root@server named]#


    [root@server named]# cat linux.edu.zone
    $TTL 86400
    @       IN SOA  linux.edu.              root(
                                            0       ; serial
                                            86400   ; refresh
                                            3600    ; retry
                                            604800  ; expire
                                            10800 ) ; minimum
            IN      NS      linux.edu.
            IN      A       192.168.127.128

    www     IN      A       192.168.127.128
    [root@server named]#

    1D = 86400
    1H = 3600
    1W = 604800
    3H = 10800
    입니다. 따라서
    이 두 파일의 다른점은 마지막 줄 하나뿐입니다.

    이 파일에는 크게 3가지 영역이 있습니다.

    [root@server named]# cat 192.168.127.zone
    $TTL 1D                                 |
    @       IN SOA  linux.edu.              |root(
                                            |0       ; serial
                                            |1D      ; refresh
                                            |1H      ; retry
                                            |1W      ; expire
                                            |3H )    ; minimum
    ----------------------------------------|---------------------
            IN      NS      linux.edu.      |
            IN      A       192.168.127.128 |
                                            |
    128     IN      PTR     www.linux.edu.  |
    [root@server named]#                    |

    ===============================================================================================

    [root@server named]# cat linux.edu.zone
    $TTL 86400
    @       IN SOA  linux.edu.              |root(
                                            |0       ; serial
                                            |86400   ; refresh
                                            |3600    ; retry
                                            |604800  ; expire
                                            |10800 ) ; minimum
    ----------------------------------------|-------------------
            IN      NS      linux.edu.      |
            IN      A       192.168.127.128 |
                                            |
    www     IN      A       192.168.127.128 |
    [root@server named]#                    |

    대충 절취선으로 자르자면 다음과 같이 나눌 수 있습니다.

    왼쪽 위 부분
        $TTL 1D
        $TTL 86400
        생존시간을 나타냅니다. 이 파일이 얼마나 유지되는지에 관한 내용입니다.

        @
        는 구분자로써 그냥 들어갑니다.

        IN
        인터넷에서 사용된다는 내용의 클래스 정보입니다.

        SOA
        시작과 인증에 대한 정보입니다.

        linux.edu.
        SOA에게 인증받을 주소입니다. 그리고 그 주소에 대한 정고는 '오른쪽 위'와 '왼쪽 아래'에 있는 섹션들에 적혀있습니다.

    왼쪽 아래 부분
        '레코드'라고 합니다.
        
        이 중에서 nameserver 영역과 host 영역이 있는데
        nameserver 는
            IN      NS      linux.edu.
            IN      A       192.168.127.128
        같은 영역입니다.
        

        IN      NS      linux.edu.
        IN      A       192.168.127.128
        에서, NS 는 뒤에 따라붙는 'linux.edu.'라는 문장이 N(ame)S(erver) 형식이라는 의미를 담고있습니다.
        에서, A 는 뒤에 따라붙는 'linux.edu.' 라는 문장이 A(ddress) 형식이라는 의미를 담고있습니다.


        Second-level 도메인 주소를 적어놓고, 그에 대응하는 IPv4 주소를 적어놓은것입니다.
        (*Second-level 는 DNS.txt 파일에 서술되어있습니다.)

        
        host 는
            www     IN      A       192.168.127.128
            또는
            128     IN      PTR     www.linux.edu.
        같은 영역을 뜻합니다.
        
        zone "linux.edu" + www = www.linux.edu
        같은 서식으로써 우리가 사용하는 URL 이 사용됩니다.

        zone "127.168.192.in-addr.arpa" + 128 >> 192.168.127.128 
        같은 서식으로써, 우리가 사용하는 IPv4가 됩니다.

    오른쪽 위 부분
        시간 의 영역입니다.
        root(
        0       ; serial
        86400   ; refresh
        3600    ; retry
        604800  ; expire
        10800 ) ; minimum
        이라는 정보를 예로 들자면

        [1] (
        [2]      ;serial
        [3]      ;refresh
        [4]      ;retry
        [5]      ;expire
        [6] )    ;minimum

        기본적으로 이 모든 구문은 [1] 자리에 있는 계정의 권한으로 모든것이 진행된다는 이야기입니다. 이번 구문에는 root 의 계정의 권한으로써 이 DNS 정보가 작성되었다는것을 뜻합니다.

        내부에 들어가는 값은
        [2] 와 [3],[4],[5] 와 [6] 으로써 3등분 해서 인식하면 됩니다.
        serial  : 일련번호
        refresh : 갱신 시도 주기            (정보의 생존 시간에 관련된 내용)
        retry   : 갱신 재시도 주기          (정보의 생존 시간에 관련된 내용)
        expire  : 갱신 실패 시 파기 시점    (정보의 생존 시간에 관련된 내용)
        minimum : 정보의 최소 생존 시간

        serial 은 '원칙적으로, 정보가 바뀐다면 + 1 을 해야한다.'라고 합니다. 이것은 master zone 과 slave zone 의 연관성에 대해 간섭하는 정보로써 serial 앞에 적힌 숫자를 통해 업데이트가 되었는지, 얼마나 되었는지 구분할 수 있는 척도가 됩니다.

        refresh 은 앞에 적힌 시간 이후에 갱신을 시도합니다. 만약에 갱신에 성공하면 0초부터 다시 시작합니다. 
        retry 는 refresh 에서 갱신에 실패한다면 retry 시간 이후에 다시, 계속해서 시도합니다.
        expire 은 앞에 적힌 시간 안에 갱신에 실패한다면, 정보를 파기한다는 내용입니다.



f13_httpd_conf.txt
    이 문서는
    httpd 웹 서버에 관한 내용을 다루는
    /etc/httpd/conf/httpd.conf 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.

    [root@server home]# /etc/httpd/conf/httpd.conf 
    #
    # This is the main Apache HTTP server configuration file.  It contains the
    # configuration directives that give the server its instructions.
    # See <URL:http://httpd.apache.org/docs/2.4/> for detailed information.
    # In particular, see
    # <URL:http://httpd.apache.org/docs/2.4/mod/directives.html>
    # for a discussion of each configuration directive.
    #
    # Do NOT simply read the instructions in here without understanding
    # what they do.  They're here only as hints or reminders.  If you are unsure
    # consult the online docs. You have been warned.
    #
    # Configuration and logfile names: If the filenames you specify for many
    # of the server's control files begin with "/" (or "drive:/" for Win32), the
    # server will use that explicit path.  If the filenames do *not* begin
    # with "/", the value of ServerRoot is prepended -- so 'log/access_log'
    # with ServerRoot set to '/www' will be interpreted by the
    # server as '/www/log/access_log', where as '/log/access_log' will be
    # interpreted as '/log/access_log'.

    #
    # ServerRoot: The top of the directory tree under which the server's
    # configuration, error, and log files are kept.
    #
    # Do not add a slash at the end of the directory path.  If you point
    # ServerRoot at a non-local disk, be sure to specify a local disk on the
    # Mutex directive, if file-based mutexes are used.  If you wish to share the
    # same ServerRoot for multiple httpd daemons, you will need to change at
    # least PidFile.
    #
    ServerRoot "/etc/httpd"

    #
    # Listen: Allows you to bind Apache to specific IP addresses and/or
    # ports, instead of the default. See also the <VirtualHost>
    # directive.
    #
    # Change this to Listen on specific IP addresses as shown below to
    # prevent Apache from glomming onto all bound IP addresses.
    #
    #Listen 12.34.56.78:80
    Listen 80

    #
    # Dynamic Shared Object (DSO) Support
    #
    # To be able to use the functionality of a module which was built as a DSO you
    # have to place corresponding `LoadModule' lines at this location so the
    # directives contained in it are actually available _before_ they are used.
    # Statically compiled modules (those listed by `httpd -l') do not need
    # to be loaded here.
    #
    # Example:
    # LoadModule foo_module modules/mod_foo.so
    #
    Include conf.modules.d/*.conf

    #
    # If you wish httpd to run as a different user or group, you must run
    # httpd as root initially and it will switch.
    #
    # User/Group: The name (or #number) of the user/group to run httpd as.
    # It is usually good practice to create a dedicated user and group for
    # running httpd, as with most system services.
    #
    User apache
    Group apache

    # 'Main' server configuration
    #
    # The directives in this section set up the values used by the 'main'
    # server, which responds to any requests that aren't handled by a
    # <VirtualHost> definition.  These values also provide defaults for
    # any <VirtualHost> containers you may define later in the file.
    #
    # All of these directives may appear inside <VirtualHost> containers,
    # in which case these default settings will be overridden for the
    # virtual host being defined.
    #

    #
    # ServerAdmin: Your address, where problems with the server should be
    # e-mailed.  This address appears on some server-generated pages, such
    # as error documents.  e.g. admin@your-domain.com
    #
    ServerAdmin root@localhost

    #
    # ServerName gives the name and port that the server uses to identify itself.
    # This can often be determined automatically, but we recommend you specify
    # it explicitly to prevent problems during startup.
    #
    # If your host doesn't have a registered DNS name, enter its IP address here.
    #
    #ServerName www.example.com:80

    #
    # Deny access to the entirety of your server's filesystem. You must
    # explicitly permit access to web content directories in other
    # <Directory> blocks below.
    #
    <Directory />
        AllowOverride none
        Require all denied
    </Directory>

    #
    # Note that from this point forward you must specifically allow
    # particular features to be enabled - so if something's not working as
    # you might expect, make sure that you have specifically enabled it
    # below.
    #

    #
    # DocumentRoot: The directory out of which you will serve your
    # documents. By default, all requests are taken from this directory, but
    # symbolic links and aliases may be used to point to other locations.
    #
    DocumentRoot "/var/www/html"

    #
    # Relax access to content within /var/www.
    #
    <Directory "/var/www">
        AllowOverride None
        # Allow open access:
        Require all granted
    </Directory>

    # Further relax access to the default document root:
    <Directory "/var/www/html">
        #
        # Possible values for the Options directive are "None", "All",
        # or any combination of:
        #   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews
        #
        # Note that "MultiViews" must be named *explicitly* --- "Options All"
        # doesn't give it to you.
        #
        # The Options directive is both complicated and important.  Please see
        # http://httpd.apache.org/docs/2.4/mod/core.html#options
        # for more information.
        #
        Options Indexes FollowSymLinks

        #
        # AllowOverride controls what directives may be placed in .htaccess files.
        # It can be "All", "None", or any combination of the keywords:
        #   Options FileInfo AuthConfig Limit
        #
        AllowOverride None

        #
        # Controls who can get stuff from this server.
        #
        Require all granted
    </Directory>

    #
    # DirectoryIndex: sets the file that Apache will serve if a directory
    # is requested.
    #
    <IfModule dir_module>
        DirectoryIndex index.html
    </IfModule>
    #
    # The following lines prevent .htaccess and .htpasswd files from being
    # viewed by Web clients.
    #
    <Files ".ht*">
        Require all denied
    </Files>

    #
    # ErrorLog: The location of the error log file.
    # If you do not specify an ErrorLog directive within a <VirtualHost>
    # container, error messages relating to that virtual host will be
    # logged here.  If you *do* define an error logfile for a <VirtualHost>
    # container, that host's errors will be logged there and not here.
    #
    ErrorLog "logs/error_log"

    #
    # LogLevel: Control the number of messages logged to the error_log.
    # Possible values include: debug, info, notice, warn, error, crit,
    # alert, emerg.
    #
    LogLevel warn

    <IfModule log_config_module>
        #
        # The following directives define some format nicknames for use with
        # a CustomLog directive (see below).
        #
        LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined
        LogFormat "%h %l %u %t \"%r\" %>s %b" common

        <IfModule logio_module>
        # You need to enable mod_logio.c to use %I and %O
        LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" %I %O" combinedio
        </IfModule>

        #
        # The location and format of the access logfile (Common Logfile Format).
        # If you do not define any access logfiles within a <VirtualHost>
        # container, they will be logged here.  Contrariwise, if you *do*
        # define per-<VirtualHost> access logfiles, transactions will be
        # logged therein and *not* in this file.
        #
        #CustomLog "logs/access_log" common

        #
        # If you prefer a logfile with access, agent, and referer information
        # (Combined Logfile Format) you can use the following directive.
        #
        CustomLog "logs/access_log" combined
    </IfModule>

    <IfModule alias_module>
        #
        # Redirect: Allows you to tell clients about documents that used to
        # exist in your server's namespace, but do not anymore. The client
        # will make a new request for the document at its new location.
        # Example:
        # Redirect permanent /foo http://www.example.com/bar

        #
        # Alias: Maps web paths into filesystem paths and is used to
        # access content that does not live under the DocumentRoot.
        # Example:
        # Alias /webpath /full/filesystem/path
        #
        # If you include a trailing / on /webpath then the server will
        # require it to be present in the URL.  You will also likely
        # need to provide a <Directory> section to allow access to
        # the filesystem path.

        #
        # ScriptAlias: This controls which directories contain server scripts.
        # ScriptAliases are essentially the same as Aliases, except that
        # documents in the target directory are treated as applications and
        # run by the server when requested rather than as documents sent to the
        # client.  The same rules about trailing "/" apply to ScriptAlias
        # directives as to Alias.
        #
        ScriptAlias /cgi-bin/ "/var/www/cgi-bin/"

    </IfModule>

    #
    # "/var/www/cgi-bin" should be changed to whatever your ScriptAliased
    # CGI directory exists, if you have that configured.
    #
    <Directory "/var/www/cgi-bin">
        AllowOverride None
        Options None
        Require all granted
    </Directory>

    <IfModule mime_module>
        #
        # TypesConfig points to the file containing the list of mappings from
        # filename extension to MIME-type.
        #
        TypesConfig /etc/mime.types

        #
        # AddType allows you to add to or override the MIME configuration
        # file specified in TypesConfig for specific file types.
        #
        #AddType application/x-gzip .tgz
        #
        # AddEncoding allows you to have certain browsers uncompress
        # information on the fly. Note: Not all browsers support this.
        #
        #AddEncoding x-compress .Z
        #AddEncoding x-gzip .gz .tgz
        #
        # If the AddEncoding directives above are commented-out, then you
        # probably should define those extensions to indicate media types:
        #
        AddType application/x-compress .Z
        AddType application/x-gzip .gz .tgz

        #
        # AddHandler allows you to map certain file extensions to "handlers":
        # actions unrelated to filetype. These can be either built into the server
        # or added with the Action directive (see below)
        #
        # To use CGI scripts outside of ScriptAliased directories:
        # (You will also need to add "ExecCGI" to the "Options" directive.)
        #
        #AddHandler cgi-script .cgi

        # For type maps (negotiated resources):
        #AddHandler type-map var

        #
        # Filters allow you to process content before it is sent to the client.
        #
        # To parse .shtml files for server-side includes (SSI):
        # (You will also need to add "Includes" to the "Options" directive.)
        #
        AddType text/html .shtml
        AddOutputFilter INCLUDES .shtml
    </IfModule>

    #
    # Specify a default charset for all content served; this enables
    # interpretation of all content as UTF-8 by default.  To use the
    # default browser choice (ISO-8859-1), or to allow the META tags
    # in HTML content to override this choice, comment out this
    # directive:
    #
    AddDefaultCharset UTF-8

    <IfModule mime_magic_module>
        #
        # The mod_mime_magic module allows the server to use various hints from the
        # contents of the file itself to determine its type.  The MIMEMagicFile
        # directive tells the module where the hint definitions are located.
        #
        MIMEMagicFile conf/magic
    </IfModule>

    #
    # Customizable error responses come in three flavors:
    # 1) plain text 2) local redirects 3) external redirects
    #
    #
    # Some examples:
    #ErrorDocument 500 "The server made a boo boo."
    #ErrorDocument 404 /missing.html
    #ErrorDocument 404 "/cgi-bin/missing_handler.pl"
    #ErrorDocument 402 http://www.example.com/subscription_info.html
    #

    #
    # EnableMMAP and EnableSendfile: On systems that support it,
    # memory-mapping or the sendfile syscall may be used to deliver
    # files.  This usually improves server performance, but must
    # be turned off when serving from networked-mounted
    # filesystems or if support for these functions is otherwise
    # broken on your system.
    # Defaults if commented: EnableMMAP On, EnableSendfile Off
    #
    #EnableMMAP off
    EnableSendfile on

    # Supplemental configuration
    #
    # Load config files in the "/etc/httpd/conf.d" directory, if any.
    IncludeOptional conf.d/*.conf
    [root@server home]#




    ServerRoot "/etc/httpd"
        이 파일 내부에 있는 내용들중에 '상대 경로'를 쓰는 경우 그 앞에 붙혀진다.
        예를 들어
        conf.modules.d/*.conf
        라는 경로가 있다면, 이 경로는 실질적으로
        /etc/httpd/conf.modules.d/*.conf
        라는 경로로써 존재하게 된다는 내용이다.

    Listen 80
        '내가 어떤 IP 를 쓰던간에, 80포트로 연결한다.'
        앞으로 통신할 포트를 뜻한다

    #Listen 12.34.56.78:80
        '12.34.56.78' 아이피에 80 포트로만 연결시키겠다는 의미이다

        만약, 192.168.127.128 , 192.168.127.129 , 192.168.127.130 이렇게 3개의 아이피를 점유하고있을때, 어떤 아이피던 상관없이 모든 곳에서 통신이 가능하게 하려면 'Listen 80' 을 쓰고, 192.168.127.128만 받고싶다면 'Listen 192.168.127.128:80' 을 쓰면 된다.

    Include conf.modules.d/*.conf
        /etc/httpd/conf.modules.d/*.conf 의 내용을 가져오겠다는 내용입니다.
        (* /etc/httpd/conf.modules.d 디렉터리 안에는 이런 파일들이 있고

        
        [root@server conf.modules.d]# ll
        합계 28
        -rw-r--r-- 1 root root 3739  9월 30  2020 00-base.conf
        -rw-r--r-- 1 root root  139  9월 30  2020 00-dav.conf
        -rw-r--r-- 1 root root   41  9월 30  2020 00-lua.conf
        -rw-r--r-- 1 root root  742  9월 30  2020 00-mpm.conf
        -rw-r--r-- 1 root root  957  9월 30  2020 00-proxy.conf
        -rw-r--r-- 1 root root   88  9월 30  2020 00-systemd.conf
        -rw-r--r-- 1 root root  451  9월 30  2020 01-cgi.conf
        [root@server conf.modules.d]#

        내용은 대충 이렇게 모듈들이 들어있는 형태입니다 .

        [root@server conf.modules.d]# cat 01-cgi.conf
        # This configuration file loads a CGI module appropriate to the MPM
        # which has been configured in 00-mpm.conf.  mod_cgid should be used
        # with a threaded MPM; mod_cgi with the prefork MPM.

        <IfModule mpm_worker_module>
        LoadModule cgid_module modules/mod_cgid.so
        </IfModule>
        <IfModule mpm_event_module>
        LoadModule cgid_module modules/mod_cgid.so
        </IfModule>
        <IfModule mpm_prefork_module>
        LoadModule cgi_module modules/mod_cgi.so
        </IfModule>

        [root@server conf.modules.d]# 
        )

    User apache
    Group apache
        서비스가 동작할때, 어느 사용자의 권한으로 동작하는지에 관한 내용입니다.

    # 'Main' server configuration
        이 다음 내용은 '메인'에 관한 내용이라는것입니다.

    ServerAdmin root@localhost
        관리자 이메일 주소

    #ServerName www.example.com:80
        서버이름 설정
        네이버의 포털사이의 원래 이름은 www.naver.com.nhoes.com 인데, 이런 서버이름 설정을 따로 해줘서 www.naver.com 이라고 입력해도 접속이 가능하게 해준다.

    <Directory [이름]/>
        [옵션]
    </Directory>
        이와 같은 형식으로, 전체적인 프로그램의 옵션을 만들어줄 수 있다.

    DocumentRoot "/var/www/html"
        기본적으로 우리가 실질적인 HTML 코드를 넣어놓는 디렉터리 를 뜻하는 옵션입니다.
        이 경로를 다른것으로 넣어놓는다면 다른 설정도 바꿔야합니다.


        DocumentRoot "/var/www/html"

        <Directory "/var/www">
            AllowOverride None
            Require all granted
        </Directory>

        <Directory "/var/www/html">
            Options Indexes FollowSymLinks
            AllowOverride None
            Require all granted
        </Directory>

        이렇게가 기본적인 설정값이라면

        DocumentRoot "/home/ghdwpaks/html"

        <Directory "/home/ghdwpaks/">
            AllowOverride None
            Require all granted
        </Directory>

        <Directory "/home/ghdwpaks/html">
            Options Indexes FollowSymLinks
            AllowOverride None
            Require all granted
        </Directory>

        바꾸는 경우에 이렇게 한번에 바꿔야한다는 내용입니다.

    <IfModule dir_module>
        DirectoryIndex index.html
    </IfModule>
        화면에 첫번째로 띄울 파일명을 정해주는 옵션입니다.
        현재 설정된 값으로는 /var/www/html/index.html 을 맨 처음에 보여준다는 내용입니다.
        여러 파일을 넣을 수 있으나, 기본적으로 앞쪽에 있을수록 먼저 보여준다. 고 합니다.
        
        만약에 여러 파일들을 설정해주고싶다면
        DirectoryIndex index.html index.php
        같이 그저 뒤에 추가해주면 됩니다.


    ErrorLog "logs/error_log"
        에러 로그를 저장하는 곳입니다.
        /var/www/html/logs/error_log 라는 파일 속에 저장된다고 합니다. 

    LogLevel warn
        저장되는 로그의 수준을 나타내는 곳입니다.
        로그를 어느정도 레벨로써 기록하겠다는 내용이기도 합니다. 종류로써는 (윗줄줄에 있는 각주의 내용을 토대로) debug, info, notice, warn, error, crit, alert, emerg 같은 종류들이 있으며, debug 에 가까울수록 사소한것까지 기록합니다.

    AddDefaultCharset UTF-8
        아파치 서버가 쓰는 기본 문자 인코딩 방식입니다.


    IncludeOptional conf.d/*.conf
        이 파일에서 서술하지 못한 추가적인 내용들이 담긴 경로입니다.
        /var/www/html/conf.d/ 디렉터리 안에 있는 .conf 로 끝나는 이름을 가지는 파일들에 들어있다고 합니다.




f14_userdir_conf.txt
    이 문서는
    apache 웹 서버에 관한 내용을 다루는
    /etc/httpd/conf.d/userdir.conf 에 대해 서술합니다.
    파일 내용 예시에 대한 내용은 아래와 같습니다.


    [root@server conf.d]# cat userdir.conf
    #
    # UserDir: The name of the directory that is appended onto a user's home
    # directory if a ~user request is received.
    #
    # The path to the end user account 'public_html' directory must be
    # accessible to the webserver userid.  This usually means that ~userid
    # must have permissions of 711, ~userid/public_html must have permissions
    # of 755, and documents contained therein must be world-readable.
    # Otherwise, the client will only receive a "403 Forbidden" message.
    #
    <IfModule mod_userdir.c>
        #
        # UserDir is disabled by default since it can confirm the presence
        # of a username on the system (depending on home directory
        # permissions).
        #
        UserDir disabled

        #
        # To enable requests to /~user/ to serve the user's public_html
        # directory, remove the "UserDir disabled" line above, and uncomment
        # the following line instead:
        #
        #UserDir public_html
    </IfModule>

    #
    # Control access to UserDir directories.  The following is an example
    # for a site where these directories are restricted to read-only.
    #
    <Directory "/home/*/public_html">
        AllowOverride FileInfo AuthConfig Limit Indexes
        Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec
        Require method GET POST OPTIONS
    </Directory>
    [root@server conf.d]# 


    여기서 주석을 잘 보면
    To enable requests to /~user/ to serve the user's public_html
    # directory, remove the "UserDir disabled" line above, and uncomment
    # the following line instead:

    사용자의 public_html에 대한 /~user/ 요청을 사용하려면
        # 디렉토리, 위의 "UserDir disabled" 줄을 제거하고 주석 처리를 취소하십시오.
        # 대신 다음 줄을 누릅니다.

    그러니까
    사용자의 public_html 에 대해서, ~ghdwpaks 같이 유저 이름을 기준으로 디렉터리를 찾아갈 수 있게 하려면
    위에 있는
    "UserDir disabled"
    를 주석처리하고, 다음줄인
    #UserDir public_html
    의 주석처리를 풀라는 내용입니다.

    그 밑에 
    <Directory "/home/*/public_html">
        AllowOverride FileInfo AuthConfig Limit Indexes
        Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec
        Require method GET POST OPTIONS
    </Directory>
    라는 문단으로
    사용자 홈 디렉터리에 관한 내용들이 적혀있습니다.

    여기서 계속 보이는 public_html 이 있는데, 이것은 꼭 public_html 이라는 디렉터리를 써야한다는 내용이 아니라, 바꿀 수 있지만 '이것을 기준으로 시스템이 구축되어 있으니, 그냥 있는거 쓰라'는 권장사양일 뿐입니다.



f15_autoindex_conf.txt
    이 문서는
    apache 웹 서버에 관한 내용을 다루는
    /etc/httpd/conf.d/autoindex.conf 에 대해 서술합니다.
    간략히, 실질적으로 도움이 되는 부분만 서술합니다.

    파일 내용 예시에 대한 내용은 아래와 같습니다.

    [root@server conf.d]# cat autoindex.conf
    #
    # Directives controlling the display of server-generated directory listings.
    #
    # Required modules: mod_authz_core, mod_authz_host,
    #                   mod_autoindex, mod_alias
    #
    # To see the listing of a directory, the Options directive for the
    # directory must include "Indexes", and the directory must not contain
    # a file matching those listed in the DirectoryIndex directive.
    #

    #
    # IndexOptions: Controls the appearance of server-generated directory
    # listings.
    #
    IndexOptions FancyIndexing HTMLTable VersionSort

    # We include the /icons/ alias for FancyIndexed directory listings.  If
    # you do not use FancyIndexing, you may comment this out.
    #
    Alias /icons/ "/usr/share/httpd/icons/"

    <Directory "/usr/share/httpd/icons">
        Options Indexes MultiViews FollowSymlinks
        AllowOverride None
        Require all granted
    </Directory>

    #
    # AddIcon* directives tell the server which icon to show for different
    # files or filename extensions.  These are only displayed for
    # FancyIndexed directories.
    #
    AddIconByEncoding (CMP,/icons/compressed.gif) x-compress x-gzip

    AddIconByType (TXT,/icons/text.gif) text/*
    AddIconByType (IMG,/icons/image2.gif) image/*
    AddIconByType (SND,/icons/sound2.gif) audio/*
    AddIconByType (VID,/icons/movie.gif) video/*

    AddIcon /icons/binary.gif .bin .exe
    AddIcon /icons/binhex.gif .hqx
    AddIcon /icons/tar.gif .tar
    AddIcon /icons/world2.gif .wrl .wrl.gz .vrml .vrm .iv
    AddIcon /icons/compressed.gif .Z .z .tgz .gz .zip
    AddIcon /icons/a.gif .ps .ai .eps
    AddIcon /icons/layout.gif .html .shtml .htm .pdf
    AddIcon /icons/text.gif .txt
    AddIcon /icons/c.gif .c
    AddIcon /icons/p.gif .pl .py
    AddIcon /icons/f.gif .for
    AddIcon /icons/dvi.gif .dvi
    AddIcon /icons/uuencoded.gif .uu
    AddIcon /icons/script.gif .conf .sh .shar .csh .ksh .tcl
    AddIcon /icons/tex.gif .tex
    AddIcon /icons/bomb.gif /core
    AddIcon /icons/bomb.gif */core.*

    AddIcon /icons/back.gif ..
    AddIcon /icons/hand.right.gif README
    AddIcon /icons/folder.gif ^^DIRECTORY^^
    AddIcon /icons/blank.gif ^^BLANKICON^^

    #
    # DefaultIcon is which icon to show for files which do not have an icon
    # explicitly set.
    #
    DefaultIcon /icons/unknown.gif

    #
    # AddDescription allows you to place a short description after a file in
    # server-generated indexes.  These are only displayed for FancyIndexed
    # directories.
    # Format: AddDescription "description" filename
    #
    #AddDescription "GZIP compressed document" .gz
    #AddDescription "tar archive" .tar
    #AddDescription "GZIP compressed tar archive" .tgz

    #
    # ReadmeName is the name of the README file the server will look for by
    # default, and append to directory listings.
    #
    # HeaderName is the name of a file which should be prepended to
    # directory indexes.
    ReadmeName README.html
    HeaderName HEADER.html

    #
    # IndexIgnore is a set of filenames which directory indexing should ignore
    # and not include in the listing.  Shell-style wildcarding is permitted.
    #
    IndexIgnore .??* *~ *# HEADER* README* RCS CVS *,v *,t
    [root@server conf.d]#

    이 파일에서

    Alias /icons/ "/usr/share/httpd/icons/"

    <Directory "/usr/share/httpd/icons">
        Options Indexes MultiViews FollowSymlinks
        AllowOverride None
        Require all granted
    </Directory>

    이 줄을 복사해서 아래에 붙혀넣고
    (* https://gmlwjd9405.github.io/2019/05/14/vim-shortkey.html)

    Alias /user2/ "/home/user2/public_html/"

    <Directory "/home/user2/public_html">
        Options Indexes MultiViews FollowSymlinks
        AllowOverride None
        Require all granted
    </Directory>
    라고 설정해준다.



p0_putty.txt
    이 문서는 리눅스 2 과정에 대한 작업을 수행할때
    vmware 의 리눅스 와 Windows 간의 불편한 점을 보완하고자 개발된
    putty 의 설정에 대해서 서술합니다.

    putty는 꼭 필요하지 않습니다.
    putty는 편할 뿐입니다.

    시작하겠습니다.



    뒤에 서술된 작동 방법 및 설정법들을 압축하자면 이와 같습니다.

    '
    Putty를 이용한 원격 접속
    1. 원격 접속을 위한 putty 설정
    창 - 모양 -> 글꼴 설정 -> 터미널 기본/유니코드 둘 다 change -> 글꼴 : consolas, 굵게
    창 - 변환 -> 수신한 데이터 문자셋 : UTF-8
    접속 - ssh - 키교환 -> 암호 알고리즘 선택 정책에서 '디피-헬만 그룹 14' 항목을 가장 위로 올리기
    세션 -> Host Name : Linux IP주소 입력 -> 저장된 세션 : 저장할 이름 입력 -> 저장
    2. 접속 방법
    저장된 세션 목록 -> 저장된 항목 더블클릭 (or 저장된 항목 클릭 -> 불러옴 -> 열기)
    -> 경고 창 나오면 예 클릭 -> login as: 뒤에 계정명 'root' 입력
    -> 암호 입력(화면에 안보일 뿐이지 입력중이니 암호 전체 입력)
    '

    이제 이 작업을 하나하나 풀어서 설명하도록 하겠습니다.



    .




    왼쪽에 있는
        분류(G)
    에 있는 것들중에서
        창
    의
        모양
    을 눌러 들여다봅니다.
    그러면 오른쪽에 있는 창이 바뀔텐데
    크게 분류를 하자면
        커서 동작 조절
        글꼴 설정
        마우스 포인터 동작 조절
        창틀 조절
    이 있을것입니다. 그중에서
        글꼴 설정
    내부에 있는
        터미널 기본 글꼴
    오른쪽 바로 아래에 있는
        Change...
    를 누른다음, 
        굵게
    속성을 추가합니다.
    그리고 그 아래에 있는
        터미널 유니코드 글꼴(S)
    오른쪽 바로 아래에 있는
        Change...
    를 누른다음, 
        굵게
    속성을 추가합니다.



    .



    왼쪽에 있는
        분류(G)
    에 있는 것들중에서
        창
    의
        변환
    의
        수신한 데이터를 이 문자셋으로 가정 (R) :
    의
        CP949
    를
        UTF-8
    로 바꿔줍니다.



    .



    왼쪽에 있는
        분류(G)
    에 있는 것들중에서
        접속
    의
        SSH
    의
        키교환
    을 클릭합니다. (없을경우 SSH 왼쪽의 + 버튼을 눌러 세부사항을 확장해서 봅니다.)
    그러면 오른쪽 화면에서 여러개의 블록이 나오는데, 크게 분류하자면 
        키 교환 알고리즘 옵션
        키 재교환 제어 옵션을 조정합니다.
    가 있습니다. 이중에서
        키 교환 알고리즘 옵션
    에 집중을 하도록 하겠습니다.

        '디피-헬만 그룹 14'
    를 클릭 한 후, 왼쪽에 있는
        UP
    버튼을 여러번 눌러 가장 위에 올리도록 합니다.



    .



    왼쪽에 있는
        세션
    을 클릭합니다.
        접속 대상 정보
    에
        Host Name (or IP address)
    에 
        접속할 리눅스 아이피
    를 입력합니다.

        저장된 세션 (E)
    바로 아래에 있는 텍스트 박스에
        쓰고싶은 저장명
    을 대충 넣고, 오른쪽에 있는
        저장(V)
    버튼을 눌러 저장을 합니다.



    .


    불러오고 싶을때
    자신이 설정해높은 설정명들중에 원하는것을 클릭하고
        불러옴
    버튼을 누른 다음
        열기
    를 누르면 됩니다.


p0_setup_virtual_machine.txt
    이 문서는 리눅스 2 과정에 대한 그 어떠한 행위를 할때 기반이 되는
    버추얼 머신의 설정에 관하여 서술합니다.

    VMware Workstation 15.N 버전, 그러니까
    15버전을 사용하는것을 권장드리며
    다른 버전을 사용하실 경우, 추가적으로 설정해주거나, 15버전에서는 설정을 해줘야했던 것들이 더이상 필요없어지는 경우가 생길 수도 있습니다.


    시작합니다.





    .....






            Create a New Virtual Machine
    을 눌러 새 가상머신을 생성합니다.

            Custom
    을 선택하고, 넘깁니다.

            Hardware compatibility:
    라는 항목 뒤에 아마 'Workstation 15.x'라는 구문이 적혀있는 레터박스 하나가 있을겁니다.
    그대로 'Workstation 15.x' 라는 구문이 적혀있으면 
            Next
    하시면 됩니다.
    만약 15.x 가 아니라면 15.x로 바꿔주시고, 안되시는 경우에는 그냥 Next 하시는 수밖에 없습니다.

            Installer disc image file (iso) :
    라는 구문은 ISO 파일 을 설정 해주는 곳입니다. 만약에 설정이 잘 안되있거나 확인이 안되는 경우에는 Browse버튼을 눌러 ISO 파일을 선택해줍니다.
    ISO 파일은 'CentOS-7-x86_64-Everything-2009.iso' 을 권장하는데,
    이 부분에서 바꾸지 않는 것을 권장하는 부분과, 반드시 피해야 하는 사항이 있습니다.
    CentOS-7 은 바뀌지 않는것을 권장합니다. 하지만 CentOS-7 버전 이하로 내려가는것은 반드시 피해야할것입니다.
    Everything은 바뀌지 않는것을 권장합니다. 하지만 Minimal 이나 embedded(임베디드) ISO는 반드시 피해야할것입니다.
    x86_64는 그 어떠한 경우라도 같아야합니다.
    이러한 권장사항까지 서술하는 이유는 이 글을 작성하는 작성자는 이미 이러한 7버전의 Everything ISO 파일을 소지하고 있지만, 그렇지 못한 경우 또한 있을것입니다. 결정적으로는 CentOS 측에서 더이상 7버전의 배포를 잠정 중단한데에 이유가 있습니다
    어쨋던간, 이렇게 ISO 파일을 전부 골랐다면
            Next
    를 눌러서 계속 진행합니다.

            Virtual machine name :
    이라는 구문이 있을텐데, 이것은 내부의 리눅스나 윈도우 운영체제와 완전 별개인 그저 '가상머신'의 이름을 정하는 항목입니다. 대충 원하는 이름을 넣거나, 자동적으로 완성된 이름을 쓰셔도 무방합니다.
    이름을 수정하셨든, 하지 않으셨든,
            Next
    를 눌러서 계속 진행합니다.

            processor configuration 
    라는 구문과 함께 숫자를 설정할 수 있는 레터박스가 나옵니다.
    프로세스 숫자를 설정하는듯한 부분인데, 숫자를 너무 높혀버리면 컴터가 터질수도 있으니 딱히 건드리지 않고
            Next
    를 눌러 진행합니다.

            Memory for the Virtual Machine
    이라는 구문과 함께 MB, GB등의 용량을 정할 수 있는 곳이 나옵니다.
    이번 경우에서는 1GB를 주기 위해서 초록색 화살표가 향하는 곳을 클릭하여
            1024MB
    로 맞춰줍니다. 용량을 늘려도 상관 없으나, 컴터 메모리 터지지 않게 조심하시면 됩니다.

            Network Type
    이라는 부분과 함께 여러가지 체크박스가 나옵니다.
    우리는 NAT 을 사용하여 가상머신을 돌리는 내부 네트워크 안에서 돌아다닐 예정이기 때문에
    그대로 Next를 누르거나 (NAT)이 적힌곳이나 'Use network address translation'이 포함된 항목을 선택한 다음
            Next
    를 눌러 계속 진행합니다.

            Select I/O Controller Types
    이라는 부분에서
            Next
    를 눌러 계속 진행합니다.
    기본적으로는 'LSI Logic (Recommended)'라는 구분을 체크하고 넘어가야합니다만 사실 뭐가 어떻게 다른지 서술자도 잘 이해하지 못한데다가, 기본값으로 위의 사항이 설정되어 있습니다. 만약에 VMware의 버전이나 형식이 달라 다른것으로 설정되어 있다면 그 가상머신 컨트롤러 형식을 따라가는게 맞다고 판단됩니다. 그리고 이 문서를 제외한 다른 문서에서는 가상머신의 장치 추가 이외에 딱히 다른 설정이나 조작, 행동을 유도하지 않으니 만일 다르거나, 선택이 안되는 경우에도 걱정하지 마시기 바랍니다.

            Select a Disk Type
    이라는 부분에서는
            SCSI    (Recommended)
    를 확인하고서 (또는, 확인된걸 확인하고서)
            Next
    를 누릅니다.

            Select a Disk
    이라는 부분에서는
            Create a new Virtual disk
    라는 것을 설정하고서
            Next
    를 누릅니다.

            Specify Disk Capacity
    이라는 부분에서는
            Next
    를 눌러 계속 진행합니다.
    이 부분은 기본적으로 이 가상머신 파일 또는 가상머신 자체에서 최대 얼마나 큰 용량을 사용하거나 점거할 수 있는지에 관한 항목입니다. 20GB도 만만치 않아보이나 이 이상으로 가는것은 상황이 어떻게 흘러갈지 모르니 더 크게 하지 않는것을 추천드립니다. 하지만 앞으로 진행할 학습이나 실습과정에서 10GB 는 충분히 가져가도 괜찮다고 예상됩니다.

            Specify Disk File
    이라는 부분에서는
            Next
    를 눌러 계속 진행합니다.
    이는 다른 이가 이 디스크 파일을 중심으로, 우리가 설정한 가상머신, 사용한 가상머신을 구동시킬 수 있게 해주는 vmdk 형식의 파일입니다. import할때 이 파일을 중심으로 vmware을 구동하기 시작한다는 뜻입니다.


            Ready to Create Virtual Machine
    이라는 부분입니다.
    아마 이 상태에서라면 여러가지 쓸데없는 옵션들이 들어가있을겁니다. 이제 그 옵션들을 없애줄겁니다.
            Customize Hardware...
    을 눌러서, 가상 하드웨어의 종류와 갯수를 수정하겠습니다.
    왼쪽 창에 Device 와 Summary가 맨 위에 적힌 박스 하나를 발견할 수 있는데, 이중에서
            Device
    부분의 목록에서

            Sound Card
    을 클릭하고, 박스 아래에 있는
            Remove
    버튼을 클릭하여, 사운드 카드를 제거합니다.

            Printer
    을 클릭하고, 박스 아래에 있는
            Remove
    버튼을 클릭하여, 사운드 카드를 제거합니다.

            USB Controller
    을 클릭하고, 박스 아래에 있는
            Remove
    버튼을 클릭하여, 사운드 카드를 제거합니다.
    이들을 지우는것에 성공하셨다면 다행이나, 이들(Sound Card, Printer, USB Controller)이 보이지 않는 상황이라면 그건 그것대로 상관 없습니다. 중요한 점은 이들이 가상머신을 만드는데에 포함되지 않는다는것이 중요합니다.

            Close
    버튼을 눌러 변경사항을 저장하고, 계속해서 진행합니다.
            Finish
    버튼을 눌러 마칩니다.

    지금까지 나온것들에 대해서, 수정이 반드시 필요한 부분은
            Installer disc image file (iso)
    입니다. 다른 부부은 기본값으로 계속 넘기고 넘겨도 상관 없으나, 이부분만큼은 신경써서 봐주셔야 합니다.

    아직 끝나지 않았습니다.




    .....





    마운트 포인트와 설치 패키지, 최초의 네트워크와 호스트 이름을 설정합니다.

    Power on this Virtual Machine
    을 클릭하거나, 초록색 플레이버튼을 눌러서, 가상머신을 킵니다.

    시간이 지나면, CentOS 의 사용을 환영한다는 메세지와 함께 언어를 설정하는 부분이 나옵니다.
    사실상 우리는 기술적인 것을 만지기 때문에 가장 안정성이 높은
            English
    를 선택해도 무방합니다만, 한글을 사용하고 싶은 경우에는 Korean을 입력해서 한국어 입력기 또는 한국어 시스템 표시를 선택하셔도 상관 없습니다.


            SOFTWARE SELECTION
            소프트웨어 선택 (s)
    라는 곳을 클릭하여, 우리가 어떤 패키지를 다운받을 건지 선택합니다.

    앞으로 중요합니다.
            밑에서 4번째
    를 기억하세요.

            Base Environment
            기본 환경
    의 공간에서 맨 아래서부터 4번째 에 위치한

            Server with GUI
            서버 - GUI 사용
    을 클릭합니다. 그 다음

            Add-Ons for Selected Environment
            선택한 환경의 기능
    에서 밑에서 4번째에 있는

            Development Tools
            개발용 툴
    을 선택합니다.

    그러면 소프트웨어의 부분에 있는 의존성 및 종속성 등등에 관한 오류 및 경고 표시들이 전부 사라지며 우리가 앞서 설정한 것들로 자동적으로 설정되게 됩니다.
    이제 창을 조금 아래로 내려서,
            System
            시스템
    에 있는
            INSTALLATION DESTINATION
            설치 대상 (D)
    를 선택하고, 들어갑니다.

    들어가면
            Local Standard Disks
            로컬 표준 디스크
    라는 박스 안에 VMware가 들어가있는 모습을 확인할 수 있습니다. 
            해당 그림을 선택
    하여, 아래에 있는
            I will configure partitioning.
            파티션을 설정합니다. (I)
    를 선택할 수 있는 상태로 만들고, 선택합니다.

    그리고 왼쪽 위에 있는
            완료
            Done
    을 누릅니다. 그러면
            New CentOS 7 Installation
            새로운 CentOS 7 설치
    라는 부분이 나오며 아래에 연보라색으로 사용 가능한 공간(AVAILABLE SPACE)와 총 공간(TOTAL SPACE) 가 표시됩니다. 그 상태에서 중간에 LVM이라고 설정되어 있다면
            박스에 표준 파티션
            Standard Partition
    이 출력되도록 설정해줍니다. 

    아래에 연보라색의 가능한 공간(AVAILABLE SPACE) 이 출력되어 있는 박스 바로 위에
            +
    플러스 기호가 있는데, 이를 눌러서 디스크 파티션의 최초 설정을 시작하겠습니다.

            ADD A NEW MOUNT POINT
            새 마운트 지점 추가
    라는 구문 바로 아래에
            Mount Point
            마운트 지점 (P)
    이 있습니다. 역삼각형 버튼을 누르면 추천하는 마운트 지점중에 하나를 선택할 수 있는데, 그중에서
            /boot
    를 선택하고
            Desired Capacity
            용량(D)
    라는 곳에다가
            1024
    라고 적어넣습니다.
    그리고
            Add mount point
            마운트 지점 추가(A)
    를 선택하여 마운트 지점을 추가합니다.



    지금까지 설정한 마운트 지점은
            /boot   1024 MiB
    가 있고, 이렇게 앞으로 설정해야하는 것은
            swap    2048 MiB
            /       17 GiB
    입니다.
    아마 위에 /boot 라는 마운트지점을 정상적으로 설정하셨다면, 이러한 구문들이 어떤 의미인지 바로 알 수 있으실겁니다. 계속 하겠습니다.



    다시
    아래에 연보라색의 가능한 공간(AVAILABLE SPACE) 이 출력되어 있는 박스 바로 위에
            +
    플러스 기호가 있는데, 이를 눌러서 디스크 파티션의 최초 설정을 시작하겠습니다.

            ADD A NEW MOUNT POINT
            새 마운트 지점 추가
    라는 구문 바로 아래에
            Mount Point
            마운트 지점 (P)
    이 있습니다. 역삼각형 버튼을 누르면 추천하는 마운트 지점중에 하나를 선택할 수 있는데, 그중에서
            swap
    를 선택하고
            Desired Capacity
            용량(D)
    라는 곳에다가
            2048
    이라고 적어넣습니다.
    그리고
            Add mount point
            마운트 지점 추가(A)
    를 선택하여 마운트 지점을 추가합니다.


    다시
    아래에 연보라색의 가능한 공간(AVAILABLE SPACE) 이 출력되어 있는 박스 바로 위에
            +
    플러스 기호가 있는데, 이를 눌러서 디스크 파티션의 최초 설정을 시작하겠습니다.

            ADD A NEW MOUNT POINT
            새 마운트 지점 추가
    라는 구문 바로 아래에
            Mount Point
            마운트 지점 (P)
    이 있습니다. 역삼각형 버튼을 누르면 추천하는 마운트 지점중에 하나를 선택할 수 있는데, 그중에서
            /
    를 선택하고
            Desired Capacity
            용량(D)
    라는 곳에다가
            아무것도
    적지 않습니다.
    그리고
            Add mount point
            마운트 지점 추가(A)
    를 선택하여 마운트 지점을 추가합니다.

    그러면 이제
            New CentOS 7 Installation
            새로운 CentOS 7 설치
    박스 안에는
            /boot   1024 MiB
            /       17 GiB
            swap    2048 MiB
    가 들어있을겁니다. 이제
            완료
            Done
    을 클릭하여 마치겠습니다. 하지만 마쳐지지 않고, 무언가 창이 하나가 더 뜰텐데, 이는 사용자에게 재 확인 받는 과정의 일부이므로 크게 신경쓰지 않으셔도 괜찮습니다.
            변경 사항 적용(A)
            Accept changes
    를 눌러 진짜로, 완료를 합니다.




            NETWORK & HOST NAME
            네트워크 & 호스트 이름
    에 들어가서
            Ethernet (ens32)
            이더넷 (ens32)
    의 옆에 있는 스위치 박스에 파란색 불이 들어와있지 않으면,
            클릭
    해서 파란색으로 켬(ON) 상태로 만들어주도록 합니다.
    그리고 아래쪽에 있는
            Host name :
            호스트 이름(H) :
    이라는 곳에는, 이 가상머신의 아이덴티티가 나타날것입니다. 어떤거냐면...
    [root@server7904 ~]# echo ghdwpaks
    ghdwpaks
    이와같은 터미널 기록이 있을때, 
    root@[이부분]
    에 어떤 글자가 쓰일것인지에 관한 내용입니다. 언뜻 봐서는 딱히 안중요해보이기도 하지만 여러개의 가상머신을 돌리고, 여러개의 서버를 돌리다보면 나에게 익숙한 일련번호와 이름이 필요하기 마련입니다. 정말 특별한 경우가 아니라면 이 박스 안에 있는 단어를 자신에게 필요한 이름으로 바꿔주도록 합니다. 이름을 잘 넣어주고서
            Apply
            적용(A)
    을 눌러 적용을 해줍니다.
    모든 설정이 잘 끝났다면 왼쪽 위에 있는 파란색 버튼인   
            완료(D)
            Done
    을 눌러 마치도록 합니다.



            Begin Installation
            설치 시작(B)
    을 누르고, 이 단계를 마무리합니다.





    .....




    이 단계에서는 최초의 root(최고 권한 관리자)와 최초의 일반 사용자에 대한 설정을 합니다.

    앞선 단계를 모두 마쳤으면,
            USER SETTINGS
            사용자 설정
    이라는 단계 아래에
            ROOT 암호 (R)
            ROOT PASSWORD
    라는 곳이 있을겁니다. 이를
            클릭
    해줍니다.

            Root Password
            Root 암호 (R)
    라는 입력 창 하나가 생성되는데, 위에는 루트 사용자의 비밀번호, 아래는 확인차 입력해하는 비밀번호 창이 있습니다.
    자신에게 있어 아주 상징적인 암호를 넣는것을 추천드리겠습니다. 잘 입력하셨다면
        
            Done
            완료(D)
    을 여러번 눌러서 설정을 마치도록 하겠습니다.

            USER CREATION
            사용자 생성(U)
    를 눌러줍니다. 이번에는 여러개의 창이 나오게 되는데, 보시다시피 위에서부터 성명, 사용자 이름, 암호, 암호 확인(재입력)입니다. 대충 아무거나 입력해주셔도 괜찮습니다만, 뭘 넣어야할지 모르시겠다면 추천을 드리도록 하겠습니다.
            성명(Full name) : ghdwpaks
            사용자 이름(User name) : ghd
            암호(Password) : ghd
            암호 확인(Confirm password) : ghd
    이름과 암호를 잘 입력하셨다면,
            Done
            완료(D)
    를 여러번 입력하여 실질적인 사용자의 생성을 마칩니다.

    위의 일련의 과정을 거쳤다면, 오른쪽 아래에는 
            Reboot
            재부팅(R)
    이라는 버튼이 있을것입니다. 이 버튼을 눌러 재시작을 합니다.





    .....





    이 단계에서는 네트워크 설정 직전에 해야할 간단한 편의성 조절에 관한 내용을 담고있습니다.

    재부팅을 마쳤다면
            LICENSE INFORMATION / License not accepted
            LICENSE INFORMATION / 라이센스에 동의하지 않습니다.
    라는 경고문과 함께 버튼이 하나 있습니다.
    이 버튼을 클릭해서 들어가면

            License Agreement
            라이센스 계약
    이라는 내용과 함께 아래에 체크박스 하나가 있습니다. 한글로는 '계약', 영어로는 Agreement 라고 되어있는데 중요한건 아닙니다만 동의하지 않으면 OS 를 사용할 수 없으니, 아래의
            I accept the license agreement.
            약관에 동의합니다 (A)
    라는 체크박스에, 체크를 하고
            Done
            완료(D)
    라는 버튼을 눌러 라이센스(약관)동의를 마치고 OS를 실행시킵니다.


    오른쪽 아래에
            FINISH CONFIGURATION
            설정 완료 (F)
    이라는 버튼을 눌러 설정을 마칩니다.

    다시 OS 가 부팅되며, 세팅이 완료됩니다.


    그리고서는 로그인 창이 하나가 나타나는데, 이중에서 아까 설정한 일반 사용자가 아닌, 최상위 관리자의 계정은 정작 보이지 않을것입니다. 이러한 경우는 문제가 생긴 것이 아닌, 오히려 정상적으로 작동하고있다는것을 나타내니 걱정하지 마세요.
            Not listed?
            목록에 없습니까?
    라는 버튼을 눌러서 준비를 합니다.
            Username
            사용자 이름
    이라는 텍스트 박스 안에 아까 설정했던
            최상위 관리자 (root)의 이름과 비밀번호
    를 입력하고서 다음으로 넘어갑니다.

    그러면 환영한다는 창이 뜰수도, 뜨지 않을 수도 있습니다. 뜨든 안뜨든 별 상관은 없으나, 뜬 경우에는 조금 주의하셔야할 것이 있습니다.
            언어(language)
            입력기(Typing)
            개인정보 / 위치 정보 서비스 (Privacy / Location Services)
    중에서 '개인정보 / 위치 정보 서비스 (Privacy / Location Services)' 의
            켬
            ON
    으로 되어있는것을
            끔 
            OFF
    로 바꿔주셔야합니다.

    이제 계속해서 넘기시면 됩니다.

    welcome
    환영합니다

    같은 창이 뜨기도 하는데, 이것들은 뜨든 말든 정말정말 상관없습니다.

    아무것도 없는 화면이든 어떻든, 왼쪽 위에
            Applications
            프로그램
    이라는곳을 클릭하면, 여러가지 목록이 있는데 그중에서
            System Tools
            시스템 도구
    라는 곳에 마우스를 올려보면 왼쪽 목록에
            Setting
            설정
    이라는 항목이 있을것입니다. 그 항목을 클릭해서 설정 창을 열어줍니다.

    그 창을 열면, 왼쪽 목록중에
            Power
            전원
    이라는 항목이 있을것입니다. 이 항목은 화면 보호기, 또는 절전을 위한 화면(만) 끄기 모드에 들어가는 시간같은, 말 그대로 전원에 관한 내용을 설정하는곳입니다. 아무튼 이 곳에서
            Power Saving
            절전
    안에 
            Blank screen
            빈 화면(B)
    안에 역삼각형이 달린 버튼 하나가 있을겁니다. 그것을
            Never
            안 함
    으로 바꿔주도록 하겠습니다.

    이제 네트워크 설정을 시작하겠습니다.




    .....




    이 단계는 네트워크 설정에 관한 내용을 담고있습니다.


    아무것도 없는 화면이든 어떻든, 왼쪽 위에
            Applications
            프로그램
    이라는곳을 클릭하면, 여러가지 목록이 있는데 그중에서
            System Tools
            시스템 도구
    라는 곳에 마우스를 올려보면 왼쪽 목록에
            Setting
            설정
    이라는 항목이 있을것입니다. 그 항목을 클릭해서 설정 창을 열어줍니다.

    왼쪽의 목록들중에
            Network
            네트워크
    라는 항목이 있을겁니다. 그 항목으로 이동하겠습니다.
            Wired
            유선
    이라는 항목 안에
            Connected - 1000 Mb/s
            연결됨 - 1000Mb/s
    라는 구문 옆에
            ON
            켬
    라는 구문 옆에
            설정 아이콘
    이 있을겁니다. 우선 그 아이콘을 눌러서 네트워크 설정에 진입합니다.

    그 창에 들어가보면,
            자동으로 연결(A)
            Connect automatically
    와
            Make available to other users 
            다른 사용자가 사용할 수 있게 허용(O)
    이라는 구문과 그 옆에 체크박스가 각각 위치해있을겁니다.
    그 박스들에 체크가 안되어있다면, 체크를 해줘야합니다. 이미 되어있는 경우에는 상관없습니다.


    해당 창의 중앙 좀 더 위쪽에 보면
            자세히 보기(Details)
            신원(Identity)
            IPv4
            IPv6
            보안(Security)
    같은 목록이 있을텐데, 그중에서
            IPv4
    로 이동하도록 합니다.
            IPv4 Method
            IPv4 방식
    이라는 곳 옆에
            자동(DHCP) (Automatic (DHCP))
            링크 로컬만(Link-Local Only)
            수동(Manual)
            사용 않기(Disable)
    같은 항목들이 있을텐데, 그중에서
            수동(Manual)
    을 선택합니다. 이유를 알고싶으시다면 우선 우리가 왜 이런 수동 IP 설정을 해주는지에 대해서 알아야 합니다.
    이 IPv4 로 putty연결을 하거나, 서버를 열고 그것에 접속하고싶은 경우에 '자동(DHCP) (Automatic (DHCP))'으로 설정해놓은 경우에는 매번, 수시로 바뀔수도 있고 바뀌지 않을수도 있습니다. 이러한 경우에 우리가 putty 를 사용하거나 열어놓은 서버에 접속하려고 하면 아이피가 바뀌어져버려서 nfs나 DNS 서비스를 제공할때 계속해서 설정값을 바꿔줘야한다는 번거로움이 있으면서도, 앞으로 할 트러블슈팅 또는 오류해결에 관한 실습을 할때 아이피의 일관성이 사라져버리게 됩니다.

    그러면 아래 항목들이 바뀌게 될텐데 크게 나눠서 보자면
            주소(Addresses)
            네임서버(DNS)
            라우팅(Routes)
    가 있을것입니다. 이중에서 이번 설정에 사용할 부분은
            주소(Addresses)
            네임서버(DNS)
    이고, 라우팅은 지금 당장 사용하지 않을 예정입니다. 키든 끄든 상관 없습니다.

    우선, 주소와 네임서버를 서정하기에 앞서서 앞으로 입력할 IP 주소들은 스스로 지어내거나 막 입력하면 안되는 부분들이 많습니다. 이중에서 이번에 가장 중요한 부분을 설정할겁니다.

    VMware 창의 왼쪽 위에 보면
            File
            Edit
            View
            VM
            Tabs
            Help
    같은 탭들이 보일건데, 그중에서 
            Edit
    을 클릭하고, 클릭함에 따라 나오는 목록들중에
            Virtual Network Editor...
    이라는 항목이 있을겁니다. 그것을 클릭해줍니다.
    그렇게 세부 항목들중에 크게크게 보자면 맨 위에 크게 보이는 net들에 대한 정보를 출력하고 있는 테이블이 하나 보일겁니다. 그중에서
            Type 이 NAT 인 네트워크의 Subnet Address
    를 잘 봐야합니다. 당신과 우리가 앞으로 써야할 주소이니까요. 어딘가에 메모해두는것을 추천드립니다.
    'Type 이 NAT 인 네트워크의 Subnet Address'이 여러개인 상황은 아직까지 직면해본적이 없습니다. 따라서 이 문서에서는 그저 다른 Subnet Address 를 계속해서 시도해가면서 성공하는것을 찾아야 한다. 라고 작성해놓겠습니다.

    다시, Virtual Network Editor 창을 닫겠습니다.

    저의 경우에는 아까 'Type 이 NAT 인 네트워크의 Subnet Address' 에
            192.168.127.0
    이라고 적혀있었습니다. 제가 쓸 수 있는 범위는 다음과 같습니다.
            192.168.127.1 ~ 192.168.127.255

    다시 
            IPv4 방식(IPv4 Method)
            주소(address)
            네임서버(DNS)
            라우팅(Routes)
    중에서
            주소(address)
    에 있는
            주소(address)
            네트마스크(Netmask)
            게이트웨이(Gateway)
    중에서
            주소(address)
    에 집중해주세요.
    우리가 아까 쓸 수 있는 범위에서 대충 중간을 찍어줍니다.
    이는 VMware을 구동시키는 컴퓨터 내부에 있는 로컬 네트워크까지 영향을 끼치니, 다른 가상머신들과 겹치지 않게 대충 설정해줍니다. 저는
            192.168.127.125
    라고 적어주겠습니다. 꼭 이것과 똑같이 하지 않아도 될 뿐더러, 위에 적어둔 '쓸 수 있는 범위'내에서 설정해줘야합니다. 다음으로는
        
            네트마스크(Netmask)
    에 집중해보겠습니다.
            255.255.255.0
    을 적어넣으세요. 끝입니다.

            게이트웨이(Gateway)
    에 집중해보겠습니다. 계속 나오고 있는 '쓸 수 있는 범위'에 대해서, IPv4의 3번째 옥텟까지는 똑같이 유지하되, 마지막 4번째 옥텟의 경우에는 2로 고정시켜서 입력해주겠습니다. 제가 사용할 수 있는 범위는 192.168.127.1 ~ 192.168.127.255 이므로,
            192.168.127.2
    로 적어넣어주겠습니다. 명심하세요. 4옥텟에 적힌 2 는 같아야합니다.

    이제 조금 더 넓게 봐서, 밑에 있는
            네임서버(DNS)
    에 집중해보겠습니다.
    여기에는 우리가 아까 적은 게이트웨이를 적어넣어줘야합니다. 저같은 경우에는
            192.168.127.2
    이렇게 적어줘야할것입니다.

    이제 다른 가상머신에서 어떤 점을 똑같이 해야하고, 어떤 점을 다르게 해야하는지 안내해드리겠습니다.
            주소(Address)
    는 당연하게도 달라야 합니다.
            네트마스크(Netmask)
    는 같아야합니다.
            게이트웨이(Gateway)
    도 같아야합니다.
            네임서버(DNS)
    도 같아야합니다.

    이제
            적용(Apply)
    를 누르고, 적용시키고 창을 끕니다.





    .....




    이 다음의 과정은 반드시 거쳐야 하는 과정입니다.
    https://jootc.com/p/201806241113
    와
    https://www.lesstif.com/system-admin/centos-selinux-6979732.html
    으로부터 발췌 또는 참고하였습니다.

    최상위 관리자(root)의 신분인 상태로
            vi /etc/selinux/config
    라고 입력해서 /etc/selinux/config 파일을 vi 에디터로 엽니다.
    그중에서
            SELINUX=enforcing
    라고 적힌곳을
            SELINUX=disabled
    이라고 바꿔줍니다. 바꿔준 해당 행에는 그 어떤것도 추가로 적지 않도록 합니다.

            init 6
    를 입력해서 가상머신을 다시 시작합니다.





    .....





    putty의 연결과 스냅샷의 기능은 다른 문서에서 설명합니다.

    사랑하고, 고생하셨습니다.






p0_snapshot.txt
    이 문서는 리눅스 2 과정에 대한 그 어떠한 행위를 할때 기반이 되는
    버추얼 머신의 설정중, 버추얼 머신의 깃.
    스냅샷에 대한 실질적인 도움이 되는 내용이 서술되어 있습니다.


    VMware Workstation 15.N 버전, 그러니까
    15버전을 사용하는것을 권장드리며
    다른 버전을 사용하실 경우, 추가적으로 설정해주거나, 15버전에서는 설정을 해줘야했던 것들이 더이상 필요없어지는 경우가 생길 수도 있습니다.


    시작합니다.



    어느 한 버추얼 머신을 선택합니다.

    그리고 VMware 의 왼쪽 위에 있는
        File
        Edit
        View
        VM
        Tabs
        Help
    같은 항목들중에서,
        VM
    을 클릭하고, 출력되는 목록들중에
        Snapshot
    을 클릭하고, 출력되는 목록들중에
        Snapshot Manager
    을 클릭합니다.

    그러면 스냅샷 매니저 창이 출력됩니다.

    각각의 기능들에 관해서는 아래에서 설명합니다


    .


    스냅샷 찍기


    창의 우측 중간에 보면 
        Take Snapshot...
    이라는 버튼이 있습니다. 

    해당 버튼을 클릭하면

        [가상머신의 이름] - Take Snapshot
    이라는 이름의 창과 함께
        Name :
    뒤에 이름을 적을 수 있는 텍스트 박스 하나가 나옵니다.
    그 텍스트 박스에 자신이 쓰고싶은 스냅샷을 적어놓으면 되는데
    이미 찍혀진 스냅샷과의 중복은 불가능합니다만 딱히 걱정하지 않아도 괜찮은게, 스냅샷 이름을 알아서 생성해주기 때문입니다. 아무튼, 자신이 원하는 스냅샷 이름을 적어넣은 후에 왼쪽 아래에 있는
        Take Snapshot
    이라는 버튼을 눌러 스냅샷을 찍어줍니다.



    .


    스냅샷 이름 바꾸기


    이름을 바꾸고싶은 스냅샷을 클릭하여 선택해준다음,
    아래에 뜨는
        Snapshot details
    라는 부분 안에 있는
        Name
    옆에 있는 텍스트박스를 보시면 해당 스냅샷의 이름이 나와있습니다.
    이름을 수정해주고, 딱히 아무것도 하지 않은 상태로 
        화면의 아무 빈곳
    을 클릭해주면, 이름이 바뀌게 됩니다.



    .



    스냅샷 돌아가기


    자신이 돌아가고싶은 스냅샷을 선택한 다음, 스냅샷 매니저 창 아래에 있는
        Go To
    버튼을 누르고, 수락하면 됩니다.



p1_mount&rpm.txt
        문제 내용 :
        CD를 마운트하여 rpm 명령어로 telnet 으로 시작하는 패키지 설치

        문제풀이 :

        mount /dev/sr0 /mnt
        /mnt 에다가 /dev/sr0/ 을 마운트한다

        mount: /dev/sr0 is write_protected, mounting read-only 라고 뜨면 된다.

        cd /mnt/Packages/
        /mnt/Packages/ 로 이동해서

        ll telnet*
        telnet 과 관련된 패키지가 있는지 확인하고

        rpm -ivh telnet-0.17-65.el7_8.x96_64.rpm
        으로 설치해준다.


    p2_sshd_config.txt
    문제 내용 :
    root로 바로 접속하는것을 막아야합니다.
    root로 바로 접속하게 된다면 너무 높은 권한때문에 시스템에 예상치 못한
    문제를 초래할 수 있어보입니다.
    적어도 sudo 나 su root같은 명령어를 이용하여 최초 시도자가 누구인지라도 알아야합니다.


    문제 풀이 :

    vi /etc/ssh/sshd_config
    root로 접속하여 /etc/ssh/sshd_config 에 vi 로 접근합니다.
    -rw------- 1 root root 3906 11월 15 05:51 /etc/ssh/sshd_config
    기본적으로 위에서 나타나있듯이 root에게만 읽고, 쓰기 (실행이 없는 이유는 필요하지 않다)기능이 열려 있다.

    #PermitRootLogin yes 이 있는 부분으로 가서
    PermitRootLogin No
    로 바꾸고 저장하고 나간다.

    systemctl status sshd
    를 입력해서 sshd 서비스의 상태가 어떠한지 확인한다.
    (* 출력 예시 : 
    [root@server /]# systemctl status sshd
    ● sshd.service - OpenSSH server daemon
    Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)
    Active: active (running) since 수 2021-11-17 20:34:23 KST; 8h ago
        Docs: man:sshd(8)
            man:sshd_config(5)
    Main PID: 1176 (sshd)
        Tasks: 1
    CGroup: /system.slice/sshd.service
            └─1176 /usr/sbin/sshd -D

    11월 17 20:34:23 server systemd[1]: Starting OpenSSH server daemon...
    11월 17 20:34:23 server sshd[1176]: Server listening on 0.0.0.0 port 22.
    11월 17 20:34:23 server sshd[1176]: Server listening on :: port 22.
    11월 17 20:34:23 server systemd[1]: Started OpenSSH server daemon.
    11월 17 20:45:38 server sshd[1941]: Accepted password for root from 192.16...h2
    Hint: Some lines were ellipsized, use -l to show in full.
    )
    'Active: active (running)'라는 구문이 아마 초록색으로 나올텐데, 이러한 경우에는 이미 sshd데몬이 실행되고 있는중인것이다. 따라서

    systemctl restart sshd
    을 입력해서 sshd 서비스를 다시 시작한다.

    이후 다시 putty나 다른 단말기에서 다시 root 접속을 시도하면 막히게 된다.
    itbank같은 일반 사용자로 로그인 한 다음에 su - 나 su root 로 다시 로그인 해야한다.


p3_scp.txt
    가상 머신을 두개 준비한다.
    1900_server : 192.168.127.128
    1900_client : 192.168.127.129

    가상 머신 두 개에서 존재하는 
    /etc/ssh/sshd_config 라는 파일 안에 있는 PermitRootLogin 속성에 관한 값을 no로 설정한다.
    (*
    [root@server home]# cat /etc/ssh/sshd_config
    #       $OpenBSD: sshd_config,v 1.100 2016/08/15 12:32:04 naddy Exp $

    # This is the sshd server system-wide configuration file.  See
    # sshd_config(5) for more information.

    # This sshd was compiled with PATH=/usr/local/bin:/usr/bin

    # The strategy used for options in the default sshd_config shipped with
    # OpenSSH is to specify options with their default value where
    # possible, but leave them commented.  Uncommented options override the
    # default value.

    # If you want to change the port on a SELinux system, you have to tell
    # SELinux about this change.
    # semanage port -a -t ssh_port_t -p tcp #PORTNUMBER
    #
    #Port 22
    #AddressFamily any
    #ListenAddress 0.0.0.0
    #ListenAddress ::

    HostKey /etc/ssh/ssh_host_rsa_key
    #HostKey /etc/ssh/ssh_host_dsa_key
    HostKey /etc/ssh/ssh_host_ecdsa_key
    HostKey /etc/ssh/ssh_host_ed25519_key

    # Ciphers and keying
    #RekeyLimit default none

    # Logging
    #SyslogFacility AUTH
    SyslogFacility AUTHPRIV
    #LogLevel INFO

    # Authentication:

    #LoginGraceTime 2m
    PermitRootLogin no
    #StrictModes yes
    #MaxAuthTries 6
    #MaxSessions 10

    #PubkeyAuthentication yes

    # The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2
    # but this is overridden so installations will only check .ssh/authorized_keys
    AuthorizedKeysFile      .ssh/authorized_keys

    #AuthorizedPrincipalsFile none

    #AuthorizedKeysCommand none
    #AuthorizedKeysCommandUser nobody

    # For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
    #HostbasedAuthentication no
    # Change to yes if you don't trust ~/.ssh/known_hosts for
    # HostbasedAuthentication
    #IgnoreUserKnownHosts no
    # Don't read the user's ~/.rhosts and ~/.shosts files
    #IgnoreRhosts yes

    # To disable tunneled clear text passwords, change to no here!
    #PasswordAuthentication yes
    #PermitEmptyPasswords no
    PasswordAuthentication yes

    # Change to no to disable s/key passwords
    #ChallengeResponseAuthentication yes
    ChallengeResponseAuthentication no

    # Kerberos options
    #KerberosAuthentication no
    #KerberosOrLocalPasswd yes
    #KerberosTicketCleanup yes
    #KerberosGetAFSToken no
    #KerberosUseKuserok yes

    # GSSAPI options
    GSSAPIAuthentication yes
    GSSAPICleanupCredentials no
    #GSSAPIStrictAcceptorCheck yes
    #GSSAPIKeyExchange no
    #GSSAPIEnablek5users no

    # Set this to 'yes' to enable PAM authentication, account processing,
    # and session processing. If this is enabled, PAM authentication will
    # be allowed through the ChallengeResponseAuthentication and
    # PasswordAuthentication.  Depending on your PAM configuration,
    # PAM authentication via ChallengeResponseAuthentication may bypass
    # the setting of "PermitRootLogin without-password".
    # If you just want the PAM account and session checks to run without
    # PAM authentication, then enable this but set PasswordAuthentication
    # and ChallengeResponseAuthentication to 'no'.
    # WARNING: 'UsePAM no' is not supported in Red Hat Enterprise Linux and may cause several
    # problems.
    UsePAM yes

    #AllowAgentForwarding yes
    #AllowTcpForwarding yes
    #GatewayPorts no
    X11Forwarding yes
    #X11DisplayOffset 10
    #X11UseLocalhost yes
    #PermitTTY yes
    #PrintMotd yes
    #PrintLastLog yes
    #TCPKeepAlive yes
    #UseLogin no
    #UsePrivilegeSeparation sandbox
    #PermitUserEnvironment no
    #Compression delayed
    #ClientAliveInterval 0
    #ClientAliveCountMax 3
    #ShowPatchLevel no
    #UseDNS yes
    #PidFile /var/run/sshd.pid
    #MaxStartups 10:30:100
    #PermitTunnel no
    #ChrootDirectory none
    #VersionAddendum none

    # no default banner path
    #Banner none

    # Accept locale-related environment variables
    AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES
    AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT
    AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE
    AcceptEnv XMODIFIERS

    # override default of no subsystems
    Subsystem       sftp    /usr/libexec/openssh/sftp-server

    # Example of overriding settings on a per-user basis
    #Match User anoncvs
    #       X11Forwarding no
    #       AllowTcpForwarding no
    #       PermitTTY no
    #       ForceCommand cvs server
    )
    이 문서 43행 즈음에 'PermitRootLogin no'라는 구문처럼
    #을 없애고, 뒤에 있는 yes (또는 no)를 no로 입력해준다.

    이렇게 가상머신 두 개 전부 PermitRootLogin 값은 no 로 설정해준다.


    server : 192.168.127.128, /tmp 속에 A라는 파일 생성
    client : 192.168.127.129, /test 디렉터리 생성

    scp 예문 두개 다 설행하기.
    (단, 하나 완료 후 반드시 /test/A 삭제 할 것)

    정답 :
    scp itbank@192.168.127.128:/tmp/A /test
    를 client 측에서 입력한다. 구문을 해석하자면 아래와 같다.

    scp itbank@192.168.127.128:/tmp/A /test
    scp             : rcp 기반의 ssh 통신 예정
    itbank          : 'itbank'라는 이름의 계정으로 접속 예정
    @               : 구분자
    192.168.127.128 : '192.168.127.128'에 연결
    :               : 구분자
    /tmp/A          : 내 컴퓨터(client)에서 있는 /tmp/ 디렉토리 안에 있는 A 파일을
    /test           : 상대 컴퓨터(server) 에 있는 /test 라는 곳에 복사(붙혀넣기)한다.

    그리고

    scp /tmp/A itbank@192.168.127.129:/test
    라는 명령어를 server 측에서 입력한다. 구문을 해석하자면 아래와 같다
    scp             : rcp 기반의 ssh 통신 예정
    /tmp/A          : 내 컴퓨터(server)에서 있는 /tmp/ 디렉토리 안에 있는 A 파일을
    itbank          : 'itbank'라는 이름의 계정으로 접속 예정
    @               : 구분자
    192.168.127.129 : '192.168.127.129'에 연결
    :               : 구분자
    /test           : 상대 컴퓨터(client) 에 있는 /test 라는 곳에 복사(붙혀넣기)한다.


    scp 


p4_vnc_connect.txt

    vncviewer <접속할 IP>:<session>
    기본적인 형식은 이렇습니다.

    바로 위에 password를 따로 지정해준 상황에서, 세션을 제공하는 컴퓨터의 아이피 주소가 192.168.127.129 이라고 하는 상황을 가정하겠습니다.

    vncviewer 192.168.127.129:1
    라고 입력한 뒤에 password를 요구하는 창이 나오면, 입력해줍니다.

    과정이 끝났습니다. 이 부분 이후에는 대표적인 디스플레이(display) 오류에 대해서 서술합니다.

    (*
    [root@localhost itbank]# vncviewer 192.168.127.129:1

    TigerVNC Viewer 64-bit v1.8.0
    Built on: 2020-11-16 16:46
    Copyright (C) 1999-2017 TigerVNC Team and many others (see README.txt)
    See http://www.tigervnc.org for information on TigerVNC.
    Can't open display:
    )
    이러한 구문이 발생하면서 그저 끝납니다.
    오류 구문은 대부분 'CLI only' 환경에서 발생합니다.
    대표적으로는 putty를 이용하는중에 오류가 발생합니다.
    이러한 경우에는 직접 vmware나 컴퓨터로 접속하여 GUI를 제공하는 환경에서 구동시켜야합니다.


p4_vnc_control.txt
        vncserver -list
        라고 입력하면
        (*
        [root@localhost itbank]# vncserver -list

        TigerVNC server sessions:

        X DISPLAY #     PROCESS ID
        :1              3651
        :50             4216
        )
        이렇게 나옵니다
        프로세스 아이디(PROCESS ID)는
        kill 3651같은 프로세스를 종료시키는 명령어에 사용됩니다.





    p4_vnc_create.txt
    문제 내용 :
    vnc를 사용하고싶습니다.


    문제 해결:

    yum -y install tigervnc-*
    를 이용하여 tigervnc 를 다운받습니다.

    vncserver
    를 입력하면 다음과 같은 구문들이 나옵니다.
    (*
    [root@server /]# vncserver
    xauth:  file /root/.Xauthority does not exist

    New 'server:1 (root)' desktop is server:1

    Starting applications specified in /root/.vnc/xstartup
    Log file is /root/.vnc/server:1.log
    )
    이 중에서
    'New 'server:1 (root)' desktop is server:1' 구문에서
    'server:1' 이 구문의 뜻은, server 라는 이름의 단말기에서 세션번호가 '1'인 세션을 열었다는 뜻입니다.

    아니면 아래와 같은 구문들이 나올수도 있습니다.
    (*
    [root@localhost itbank]# vncserver

    You will require a password to access your desktops.

    Password:
    )
    이러한 구문은 세션의 패스워드를 결정하는 곳입니다.
    입력 한 후(안보이는 것이 정상입니다.)엔터를 치면 
    (*
    Verify:
    )
    이러한게 나오는데
    이건 비밀번호를 재입력하는 곳입니다.
    그리고 다시 입력한 후 엔터를 치면
    (*
    Would you like to enter a view-only password (y/n)? n
    A view-only password is not used
    xauth:  file /root/.Xauthority does not exist

    New 'localhost.localdomain:1 (itbank)' desktop is localhost.localdomain:1

    Creating default startup script /root/.vnc/xstartup
    Creating default config /root/.vnc/config
    Starting applications specified in /root/.vnc/xstartup
    Log file is /root/.vnc/localhost.localdomain:1.log
    )
    이러한 구문이 나오며, 세션이 완성됩니다.

    'localhost.localdomain:1' 이 구문을 들여다본다면 : 뒤에 1을 보면 세션 번호가 1임을 알 수있습니다.

    방식이 어쨌든, 과정이 어쨌든 이렇게 세션을 만들고
    세션 번호를 확인하는것이 가장 중요합니다.

    이러한 과정을 통해 vnc 세션을 열었습니다.

    vncserver
    가 아니라

    vncserver :50
    이라고 입력하면, 세션 번호가 50인 상태로 생성된다.






p5_vsftpd.txt 
    필요한 사전 작업 :
    리눅스 서버와 윈도우 클라이언트 간의 ftp 활성화 완료

    문제 내용 :

    1. /etc/inittab 파일을 /home/itbank에 복사
    2. ftp에 itbank로 접속 후 inittab 다운로드
    3. /home/itbank 내부 inittab 파일 삭제
    4. ftp에서 inittab 업로드
    5. windows에 있는 inittab 삭제
    6. 기록된 로그 확인

    추가 정보 :
    /etc/vsftpd/vsftpd.conf


    문제 해결 :
    #기본적으로 모든 과정은 root(관리자) 계정으로 수행합니다. 만일 사용자가 변경될 경우 따로 표기합니다.

    cd ~itbank
    cp /etc/inittab ./

    그리고 윈도우 환경으로 넘어가서
    ftp 192.168.127.128
    로 ftp 연결을 합니다.
    (*앞에 있는 3개의 옥텟은 달라도 괜찮지만 4번째 옥텟의 128은 지키는것이 좋습니다.)

    get inittab
    을 입력하여 itbank 유저의 홈 디렉터리에 있는 inittab 파일을 가져옵니다.

    put inittab
    을 입력하여 itbank 유저의 홈 디렉터리에 inittab 파일을 넣어놉니다.

    quit
    을 입력하여 windows에서의 ftp 연결을 종료합니다.

    ftp 에 대한 로그는 
    /var/log/xferlog에 저장됩니다.


    Tue Nov 16 19:41:24 2021 1 ::ffff:192.168.10.1 511 /home/itbank/inittab a _ o r itbank ftp 0 * c
    Tue Nov 16 19:41:38 2021 1 ::ffff:192.168.10.1 511 /home/itbank/inittab a _ i r itbank tfp 0 * c
    로그는 위와 같은 형태로 저장되며, 해석은 다음과 같습니다.
    Tue     : 기록된 요일을 나타냅니다.
    Nov     : 기록된 월을 나타냅니다.
    16      : 기록된 일을 나타냅니다.
    19:41:24: 기록된 시:분:초 를 나타냅니다.
    2021    : 기록된 년을 나타냅니다.
    1       : 전송에 걸린 초(시간)을 나타냅니다. 소수점 이하는 올리는것으로 추정됩니다.
    ::ffff:192.168.10.1 어떤 IP에서 접근하여 이벤트를 발생시켰는지에 관한 내용입니다.
    511     : 대상(파일)의 크기는 몇 byte였는지
    /home/itbank/inittab : 파일의 이름(과 경로)가 뭐였는지에 관한 내용입니다.
    a       : 파일의 인코딩(및 디코딩)의 형식을 나타냅니다. (a 는 아스키코드, b는 바이너라(이진수)를 뜻하지만, ftp에서는 a인 아스키코드만이 사용됩니다.)
    _       : t 가 들어가면 tar 작업이 수행됐고, c가 들어가면 압축 작업이 일어났음을 뜻한다고 합니다. ftp 통신에서는 기본적으로 파일전송을 하기 때문에 이번 통신 기록에 관해서는 아무런 내용도 뜻하지 않는것으로 보입니다.  xferlog 파일은 기본적으로 ftp 외에 다른 서비스에서도 사용하는 로그 파일이기 때문에 여러 서비스가 로그 형식을 공유합니다. 그렇기에 이번에 사용된 ftp 프로토콜 통신 말고도 다른 서비스에서 사용되는 옵션값으로 추정됩니다.
    o       : 핵심입니다. 나갔음을 뜻합니다. 바로 아래에 있는 로그는 i이라고 기록됐는데, i 는 in의 약자로써 들어왔음을 뜻하고, o 는 out의 약자로써 나갔음을 뜻합니다. (windows 클라이언트에서 다운로드 했으니 linux 서버 입장에서는 '나감'을 뜻합니다. 또한 windows 클라이언트에서 업로드했으니 linux서버에서는 '들어옴'을 뜻합니다.)
    r       : 로컬 사용자를 뜻합니다. 익명 사용자가 들어갔을 경우 a 로 기록됩니다.
    itbank  : 접속한 유저를 뜻합니다. windows 클라이언트가 itbank 계정의 권한을 얻어서 inittab을 itbank의 홈 디렉터리에 작성했습니다.
    ftp     : 통신 프로토콜을 뜻합니다
    0 *      : 인증여부를 뜻합니다. 인증되었으면 1이 기록됩니다. (이번 전송 기록에 0이 기록된 이유는 이미 인증된 itbank 계정을 사용한거지 put inittab 이나 get inittab 을 입력했을때 따로 인증하지 않았기 때문에 0으로 기록됐습니다.) * 이 별 표시는 어떠한 인증을 했는지에 관한 로그이지만 이번에는 인증 자체를 하지 않았기 때문에 *이 찍혔습니다.
    c       : c는이 모든 과정이 정상적으로 이행됐음을 뜻합니다.




p5_vsftpd2_conf.txt
    리눅스의 IPv4 : 192.168.127.128

    1.윈도우에서 리눅스로 파일전송
    윈도우측에서 리눅스로부터 가져올 파일 : ini.txt

    2.리눅스에서 윈도우로 파일전송
    윈도우측에서 리눅스에게 넘겨줄 파일 : index.txt

    문제 해결 :

    리눅스에서 입력해줄것들 :
        yum -y install vsftpd-*
        systemctl restart vsftpd
        firewall-cmd --permanent --add-service=ftp
        firewall-cmd --reload

        해석 :
            yum -y install vsftpd-*
            vsftpd 서비스를 yum 으로 다운로드하기

            systemctl restart vsftpd
            데몬 (재)실행

            firewall-cmd --permanent --add-service=ftp
            firewall(방화벽) 예외처리

            firewall-cmd --reload
            firewall(방화벽) 예외처리 적용

    리눅스에서 해줘야하는것들 :
        1. 유저 생성
            useradd user1
        2. 생성한 유저 비번 설정
            passwd user1
        3. 윈도우에게 넘겨줄 파일 만들기
            cd ~user1
            echo "Hello world, I'm ini text file." >> ini.txt

    윈도우에서 입력해줘야하는것들 :
        cd /
        mkdir /ghdwpaks
        cd /ghdwpaks
        ftp 192.168.127.128
        
        cd /                : 최상위 디렉터리 이동
        mkdir /ghdwpaks     : ini.txt 를 받고, index.txt 를 넘겨줄 디렉터리 생성
        cd /ghdwpaks        : 이동
        copy con index.txt  : index.txt 생성. 내용 대충 입력해주고 Ctrl + C 입력해서 입력종료하기.
        ftp 192.168.127.128 : ftp 접속

        user1 이름 치고 아까 설정한 비밀번호 입력하기
        get ini.txt
        입력해서 ini.txt 파일 가져오기
        put index.txt
        입력해서 index.txt 파일 넘겨주기

        quit 로 접속 종료





    +가능한 추가적인 행동들
        ftp 는 ssh 와 비슷한 맥락이지만 파일만 전달하고 받을 수 있습니다.
        하지만 그중에서도

        cd
            같이 작업 폴더 이동과 같은 행위들을 할 수 있기도 하고

        pwd
            같이 자신이 어떤 위치에서 작업하고 있는지도 알려줍니다. 하지만
            웬만한 경우에는 "/" 라고 출력되면 최상위 디렉터리라고 알려주는데, 이는 사실 진짜 최상위 디렉터리가 아니라 '접속한 유저의 권한으로 움직일 수 있는 최상위 디렉터리' 입니다.
            ftp 에서는 리눅스에서 (웬만하면)root 로만 올라갈 수 있게 되어있는 진짜 최상위 디렉터리인 / 까지 못올라간다는 내용입니다.

        ls
        ls -al
            등등의 명령어도 쓸 수 있습니다.



p6_auto_mount.txt
    문제 내용 :
    HDD : 1GB(SCSI) 추가

    partition size    mount point
    100MB           : linux
    200MB           : clang
    200MB           : ms
    300MB           : net
    200MB           : anon

    오토 마운트 해보기

    문제 해결 :
    버추얼 머신 또는 실제 물리적으로 1GB 이상의 용량을 확보합니다. 이번 실습에서는 기본적으로 버추얼 머신을 사용한다는것을 가정하고서 풀이를 진행합니다.

    버추얼 머신 세팅에 들어가서
    새로운 하드 디스크를 1GB 이상을 추가합니다.(1GB로 추가합니다.) 디스크 형식도 SCSI이므로 용량 설정 이후 그저 기본 설정으로 계속 만들어주시면 됩니다.

    fdisk /def/sdb
    를 통해 본격적으로 파티션을 만드는 과정으로 돌입합니다. 만약 이 명령어가 수행이 되지 않거나 이러한 파티션이 없다고 뜨는 경우에는 fdisk -l을통해 2048의 용량을 가진 디스크를 선택합니다.

    우리는 지금 문제에서 5개의 파티션을 설정해줘야합니다. 하지만 프라이머리(primary)파티션은 하나의 디스크에 4개까지밖에 만들 수 없으니, 4개를 primary 파티션으로 설정하고, 나머지 하나의 영역을 extended의 영역으로 설정한 후 logical 파티션으로 설정할 예정입니다.


    n을 입력합니다.
    (*
    Partition type:
        p   primary (0 primary, 0 extended, 4 free)
        e   extended
    Select (default p) :
    )
    같은 구문이 나온는데, primary 뒤에 붙은 괄호는 현재 사용중인 파티션의 종류과 갯수를 나타냅니다.

    이후 p를 입력합니다.
    이 p를 입력함으로써 primary 파티션을 새로 추가합니다.
    이후 
    Using default response p 라는 구문과 함께
    Partition number (1,3 default 1) :
    이라는 구문이 나오는데, 딱히 순서나 이름을 신경쓰는 문제상황이 아니니 그저 엔터를 눌러 기본값으로 설정해줍니다.

    First sector (2048-2097151, default 2048) :
    이라고 나오는데... 뭔지 모르는 항목이니 그냥 기본값으로 입력하기 위해 엔터를 누릅니다.

    Using default value 2048 이라는 문장이 나오며
    Last sector, +sectors or +size{K,M,G} (2048-2097151, default 2097151):
    이라는 구문이 나옵니다.
    우리는 일단 100, 200, 200, 300, 200 MB가 필요하기 때문에 +100M 이라고 입력해줍니다.
    이후
    Partition 1 of type Linux and of size 100 MiB is set
    이라는 구문이 나오며 정상적으로 파티션 생성이 완료되었음을 알립니다.

    앞으로 총 4개의 파티션을 더 설정해야합니다.

    이번에도 새로운 파티션을 생성해야 하니
    Partition type:
        p   primary (0 primary, 0 extended, 4 free)
        e   extended
    Select (default p) :
    이라는 구문에서 다시 p를 입력하거나 아무것도 입력하지 않은 상태로 엔터를 누릅니다.
    파티션 넘버와 First sector는 건드리지 않을거고,

    Last sector, +sectors or +size{K,M,G} (2048-2097151, default 2097151):
    다시 이러한 구문이 나옵니다.
    이번에는 200MB 용량의 파티션이 필요하니, +200M 을 입력하고 엔터를 칩니다.

    다시 n 을 눌러 새로운 파티션을 만듭니다.
    primary로 생성하고, 숫자 건드리지 않고 First sector 또한 건드리지 않습니다.
    다시 용량을 설정해줘야하는데, 이번에도 200MB의 용량이 필요하니 +200MB를 입력해줍니다.

    다시 n 을 눌러 새로운 파티션을 만듭니다.
    primary로 생성하고, 숫자 건드리지 않고 First sector 또한 건드리지 않습니다.
    다시 용량을 설정해줘야하는데, 이번에는 300MB 용량이 필요하니 +300MB를 입력해줍니다.

    다시 n을 눌러 새로운 파티션을 생성합니다.
    하지만 이제 primary 파티션을 전부 차지했으니 자동적으로 extended로 넘어가며 logical 파티션이 생성됩니다.
    이번에도 First sector 건드리지 않을거고, Last sector, +sectors or +size{K,M,G} (1644544-2097151, default 2097151) :
    이라는 구문이 나오는데, 이번에는 1000 - 100 - 200- 200 - 300 을 하여 자동적으로 200MB 만 남게 되니 어짜피 설정 해주든 말들 상관 없이 200MB를 가져가게 될겁니다. 따라서 +200MB를 입력해줘도 괜찮지만, 이번 실습에서는 그냥 엔터를 쳐서 기본값인 최대치로써 200MB를 설정해줍니다.

    이제 파티션의 크기 설정과 생성에 관한 과정은 모두 끝났습니다. 마지막으로
    Command (m for help) :
    라는 구문 뒤에 p 를 입력하여
    여태까지 만든 파티션들이 정상적으로 만들어졌는지에 대해서 확인을 해줍니다.

    저장하고 나온다는 의미의 w를 입력하여 fdisk 명령어를 끝냅니다.



    이제 각 마운트 포인트를 설정하여 지금까지 만든 파티션들을 모두 마운트해줄겁니다.

    mkfs.xfs /dev/sdb1
    을 입력하여 /def/sdb1 파티션을 xfs 라는 파일 시스템 형식으로 포맷하고 새로 설정합니다.

    mkfs.xfs /dev/sdb2
    mkfs.xfs /dev/sdb3
    mkfs.xfs /dev/sdb4
    mkfs.xfs /dev/sdb5
    mkfs.xfs /dev/sdb6
    똑같은 의미로서 이 명령어들까지 전부 입력해줍니다.

    아무곳에서나 상관 없으니(그래도 최상위 디렉토리가 아닌 유저의 홈 디렉토리가 적당합니다.) 아무 디렉토리나 이동하여 
    mkdir linux clang ms net anon 
    을 입력하여 마운트를 실행할 각 폴더들을 생성합니다.

    일단 마운트를 오토 마운트로 돌려서 사용하기 전에 마운트를 한번 해줍니다.

    mount /dev/sdb2 /home/itbank/linux
    (
    mount /dev/sdb3 /home/itbank/clang
    mount /dev/sdb4 /home/itbank/mx
    mount /dev/sdb5 /home/itbank/net
    mount /dev/sdb6 /home/itbank/anon
    )

    입력 이후 정상적으로 마운트가 이행되는지 확인하기 위해
    df -h
    를 입력합니다.
    /dev/sdb1   97M     5.3M    9.3M    6%  /test/linux
    같은 구문이 있으면 잘 된것이니 이제 마운트를 해제해줍니다.
    umount /dev/sdb2
    (
    umount /dev/sdb3
    umount /dev/sdb4
    umount /dev/sdb5
    umount /dev/sdb6
    )

    이 일련의 과정의 핵심인 파일설정을 할겁니다 .

    vi /etc/fstab
    을 입력해서 오토마운트에 관한 파일인 fstab 을 엽니다.
    이 안에
    /dev/sdb2   /home/itbank/linux  xfs     defaults    0 0
    /dev/sdb3   /home/itbank/clang  xfs     defaults    0 0
    /dev/sdb4   /home/itbank/ms     xfs     defaults    0 0
    /dev/sdb5   /home/itbank/net    xfs     defaults    0 0
    /dev/sdb6   /home/itbank/anon   xfs     defaults    0 0
    이러한 구문을 남김으로써
    다음에 재부팅 할때도 자동으로 마운트가 되게 합니다.




p7_nfs.txt
    문제 내용:
    서울지사에서 서버관리자로 일하고 있는 도중 본사에서 급한 연락을 받았다
    본사 서버에서 용량이 부족한데 본사 서버관리자가 휴가 및 외근으로 인해 작업을 할 수 있는 사람이 없다고 할때
    서울지사에서 본사에 5GB 용량을 확보해주기
    (단, 지사 머신에 HDD 추가 후 진행)

    *용량 제공은 재부팅 후에도 자동으로 동작되도록 설정
    *스냡샷 되돌린 후에는 putty를하나만 켜고 한다
    (putty를 nfs server에 연결, nfs client는 nfs server에서 원격 제어)


    문제 해결 :

    서버측에서는 일단 5GB 라는 용량을 정해서 본사에게 제공해줘야하기 때문에, 이 부분적인 제공을 위한 파티션을 일단 나눠줘야합니다.
    어떠한 디스크인지는 별로 상관 없으나, 당연하게도 5GB 이상의 용량 및 공간이 필요합니다.

    이번 상황에서는 sdb 디스크를 설정하여 본사에게 제공하겠습니다.

    fdisk /dev/sdb
    를 입력해서, sdb 디스크에 관한 파티션 설정을 시작합니다.

    n
    을 입력해서 새로운 파티션을 생성합니다.

    p
    를 입력하거나, 아무것도 입력하지 않은것으로써 프라이머리 파티션을 제공합니다. 프라이머리 파티션이 전부 차있다면, e(xtended)파티션을 제공해줘야합니다.
    이유야 어쨌든, 5GB짜리 통으로 된 파티션을 제공해야합니다.

    1
    을 입력하거나, 아무것도 입력하지 않은것으로써 '파티션의 고유번호'를 붙혀줍니다.


    First sector (2048-10485759, default 2048) :
    같은 구문이 나온다면

    아무것도 입력하지 않음
    으로써 기본값으로 넘깁니다. 이는 파티션 내부의 정렬에 관한 내용입니다만, 웬만하면 기본값으로 하는게 좋습니다. (http://rette.iruis.net/2018/01/fdisk%EB%A1%9C-4096-%EC%84%B9%ED%84%B0-%EC%A0%95%EB%A0%AC%EB%90%9C-%ED%8C%8C%ED%8B%B0%EC%85%98-%EC%83%9D%EC%84%B1/ , https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=merry_3&logNo=221540218022 발췌)

    Last sector, +sectors of +size{K,M,G} (2048-10485759, default 10485759):
    같은 구문이 나온다면

    5G
    를 입력해주거나, 애초에 디스크 용량이 5G짜리 디스크라면 그냥 엔터를 눌러서 넘기면 됩니다.

    Command (m for help) : 
    라는 구문이 나온다면,

    w
    를 입력해서 fdisk 를 종료합니다.


    .


    이제 본사에 제공할 5GB 용량의 파티션을 생성하는 과정을 마쳤습니다.

    그럼에도 잘 설정이 됐는지 확인하기 위해서

    mkfs.xfs /dev/sdb1
    를 입력합니다. 아까 설정한 파티션 이름(sdb) 뒤에 '파티션의 고유번호'(1)를 붙힌다음, mkfs.xfs 뒤에 붙혀줍니다.
    위의 구문은 mkfs 명령어를 통해 /def 디렉터리 안에 있는 sdb1 파티션을 xfs 형식으로써 포맷하는것을 뜻합니다.

    meta-data=/dev/sdb1              isize=512    agcount=4, agsize=327616 blks
            =                       sectsz=512   attr=2, projid32bit=1
            =                       crc=1        finobt=0, sparse=0
    data     =                       bsize=4096   blocks=1310464, imaxpct=25
            =                       sunit=0      swidth=0 blks
    naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
    log      =internal log           bsize=4096   blocks=2560, version=2
            =                       sectsz=512   sunit=0 blks, lazy-count=1
    realtime =none                   extsz=4096   blocks=0, rtextents=0

    를 동반한 여러가지 정보가 출력된다면 정상적인 과정을 거친것입니다.


    .


    vi /etc/fstab
    을 입력하여, 위에 설정해준 sdb1 파티션이 재부팅 된 후에도 자동으로 마운트(오토마운트)되도록 설정해주기 시작하겠습니다.

    파일의 말단에
    /dev/sdb1       /nfs        xfs     defaults    0 0
    을 입력하여 아래와 같은 의미의 설정을 합니다.
    (
    /dev/sda1       /nfs     xfs     defaults        0 0
    장치명          : /dev/sda1
    마운트 포인트   : /nfs
    장치의 fs type  : xfs
    마운트 옵션     : default
    dump 운용       : 0
    부팅시 fsck 동작: 0
    )


    .


    이때, 이 파티션을 마운트 할 부분을 /nfs라고 설정해줬는데, 당연하게도 이 파일이 없으면 마운트가 안되고, 제공이 안될테니
    ls /nfs
    를 입력해서 /nfs 가 없다면
    mkdir /nfs
    를 입력해서 /nfs를 만들어줍니다.


    .


    이제 서버측에서 nfs 서비스를 설정해줄겁니다.

    systemctl restart nfs
    라고 입력하여 nfs를 (재)시작합니다.

    systemctl status nfs
    를 입력해서 중간에 'Active: active'라고 (초록색 글자로)출력되어있다면 문제없이 작동하는것입니다. 일단 이 이후의 작업을 하려면 이 확인절차는 반드시 필요합니다.

    nfs가 정상적으로 작동하는것을 확인했으니, 방화벽을 설정하여 이 nfs서비스에 관한 포트는 예외로 둡니다.

    firewall-cmd --permanent --add-service=nfs
    를 입력하여 firewall(방화벽)을 통해 nfs서비스 통신을 할 수 있도록 방화벽 설정을 해줍니다.

    firewall-cmd --reload
    를 입력하여 firewall(방화벽)설정을 해준것을 reload(재시작)함으로써 다시 시작합니다.


    .


    이제 서버에서 해야하는 모든 과정을 마쳤습니다.
    클라이언트로 넘어가는 과정을 거치고, 서버에 접속하겠습니다.
    지금의 상황에서는 본사에 아무도 없기 때문에 ssh로 접속하여 실질적으로는...
    'server 에서 client로 ssh 접속을 해서 client가 server에 접속하는것'이 될 예정입니다.


    .


    ssh 192.168.10.129
    를 입력하여 클라이언트에 ssh 접속을 합니다.

    Are you sure you want to continue connecting (yes/no)?
    라는 구문이 나오면

    yes
    를 입력합니다. 위의 구문은 ssh 통신의 위한 공개키를 생성하는것에 관한 허락을 구하는 내용입니다. (https://info-lab.tistory.com/254 발췌)


    ssh 의 통신 과정으로써 당연한 이야기겠지만, 서버에서 root로써 작업하고 있었다면 ssh [클라이언트 아이피 주소] 를 통해 클라이언트에 ssh 접속을 할 때에도 root로써 들어가게 됩니다. 우리가 접속할 클라이언트의 root라는 유저 또한 (최상위 권한을 가진)관리자 라는 가정 하에 상황을 진행합니다.

    root@192.168.10.129's password:
    라는 구문이 나온다면 클라이언트의 root계정의 비밀번호를 입력하면 됩니다.


    .


    이제 서버에서 제공해준 파티션을 받아서 사용해야합니다.
    서버에서 받은 파티션을 가지고 있으면서, 클라이언트가 재부팅 되었을 때도 사용할 예정인 상황이니, autofs 패키지를 다운받겠습니다.(그저 auto mount 기술이 필요한 경우 위와 같이 해도 되지만 이번에는 경험을 위하여 이와같이 진행했습니다.)

    yum -y install autofs-*
    를 입력하여 autofs 에 관련된 패키지는 모두 받습니다.
    다운로드가 끝난 후, 'Complete!'라는 구문이 나오면 말 그대로 정상적으로 설치가 됐음을 뜻합니다.

    vi /etc/autofs.conf
    라는 명령어를 입력하여 autofs 에 대한 설정을 건드립니다.

    해당 파일에
    browse_mode = 
    가 있는 곳에

    browse_mode = yes
    로 바꿔줍니다. 바꿔준 해당 줄(라인)에는 이 구문 이외에는 아무것도 적지 않도록 합니다.

    :wq
    를 입력하여 저장하고, vi를 빠져나옵니다.

    이제 실질적으로 마운트에 대한 정보를 다뤄야 하니,

    vi /etc/auto.misc
    를 입력하여 문서를 엽니다.

    문서의 말단에
    nfs_auto    -rw,hard,intr       192.168.10.128:/nfs
    이라고 입력해줍니다.해석은 아래와 같습니다.
    nfs_auto    : 마운트 포인트 실질적인 경로는 /misc/nfs_auto 로 됩니다.(디렉토리입니다.)
    -rw         : read , write 를 하겠다는 의미입니다. 읽기 전용은 ro(read only) 로 적어야합니다.
    ,           : 구분자
    hard        : soft와 hard가 있습니다. hard라면 연결이 끊긴다면 연결 시도를 더 하지 않고 그저 끊어버립니다. soft라면 연결이 끊길경우 연결을 계속해서 시도합니다.
    ,           : 구분자
    intr        : 비정상 종료가 발생했을 경우, 연결을 유지한다는 내용입니다.
    192.168.127.128:/nfs : 장치명입니다. 서버가 공유해주는 디렉토리에 대한 부분입니다.

    exit
    를 입력해서 서버측에서 실행하는 클라이언트를 향한 ssh 접속을 중단합니다.

    vi /etc/exports
    를 입력하여, client 에서 접속해서 client 의 로컬 디렉토리처럼 사용할 수 있게 설정해주도록 하겠습니다.
    (https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hanajava&logNo=220422771247 발췌)

    해당 문서 말단에

    /nfs    192.168.10.129(rw,no_root_squash,sync)
    를 입력합니다. 의미는 아래와 같습니다.
    /nfs    : 제공자 측에서 제공해줄 파티션이 마운트된 파일 위치
    192.168.10.129 : 사용자 측의 아이피
    rw      : 작업 형식. 일고, 쓰는것 모두를 허용한다는 내용이다.
    no_root_squash : client의 root를 서버의 root로 매핑 (최상위 관리자 접속으로 시도하는 경우, 상대방의 최상위 관리자의 이름이 어떻게 되든지간에 '최상위 관리자'라는 것에 맞춰 연결해줌)
    sync    : 파일 시스템이 변경되면 즉시 동기화
    (https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=musalyh&logNo=220710277058 발췌)


    .


    이제 client 에 관한 추가적인 설정을 마쳤습니다.
    따라서 nfs를 다시 시작해주고, 상태를 살펴보겠습니다.

    systemctl restart nfs
    를 입력하여 nfs 서비스를 다시 시작하고,

    systemctl status nfs
    를 입력하여 nfs 서비스의 상태를 살펴봅니다.
    아까와 같이 Active: active 같은 설정이 (초록색 글자로)나와있다면 성공입니다.

    systemctl enable nfs
    를 입력하여 만약에 서버가 재부팅 되는 상황에서도 nfs 서비스가 자동으로 서비스를 할 수 있게 해줍니다.


    다시 클라이언트로 ssh 접속을 통해 마운트가 잘 됐는지, nfs 설정이 올바르게 들어갔는지 확인해보겠습니다.


    .


    ssh 192.168.10.129
    를 입력하여 클라이언트(client : 192.168.10.129)에 접속합니다.

    root@192.168.10.129's password:
    와 같은 구문이 나온다면, client의 root의 비밀번호(password)를 입력해줍니다.

    systemctl restart autofs
    를 입력하여 오토 마운트 서비스를 (재)시작합니다.

    systemctl status autofs
    를 입력하여 autofs 서비스가 정상적으로 돌아가고 있는지 확인해봅니다.
    위에서 nfs 서비스의 상태를 살펴볼 때와 같이, Active: active 라는 구문이 (초록색으로) 출력되면 정상적으로 작동되는것을 의미합니다.

    ls -al /misc
    를 입력하여 nfs_auto 디렉토리가 정상적으로 제자리에 잘 있는지 확인합니다.
    왜 /nfs_auto 가 아니라 /misc를 하는 이유는 이 문서 176 즈음의 '/misc/nfs_auto'키워드와 함께 서술되어 있습니다.

    systemctl enable autofs
    를 입력하여 autofs가 재부팅 될 시에도 자동으로 시작할 수 있게 해줍니다.
    (https://www.lesstif.com/system-admin/systemd-system-daemon-systemctl-24445064.html 발췌)

    init 6
    를 입력하여

    최종적인 확인을 위하여 클라이언트를 재시작하겠습니다.


    .


    이렇게 된다면
    Connection to 192.168.10.129 closed by remote host.
    Connection to 192.168.10.129 closed.
    같은 구문이 나오며 서버측에서 진행한 클라이언트를 향한 ssh 통신이 끊기게 됩니다.

    서버측에서도 이때까지 해온 모든 과정을 예외없이 정상적으로 적용시키기 위하여 

    init 6
    를 입력합니다.


    .


    서버측에서 진행하는 과정입니다.

    df -h
    를 입력하여 클라이언트가 접속하고싶은 /nfs가 정상적으로 마운트 되어있는지,
    용량은 어떤지 확인합니다.

    출력문 중에
    /dev/sdb1   5.0G    33M     5.0G    1%  /nfs
    같은 구문이 있다면 정상적으로 작동하고있는것을 뜻합니다.

    exportfs -v
    를 입력하여 exports 파일에서 설정한 nfs 공유 파티션(또는 디렉토리) 가 어떤것이 있는지 확인합니다.

    /nfs    192.168.10.129(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,no_root_squash,no_all_squash)
    같은 구문이 나온다면 성공입니다.

    이제 재부팅 하는 상황에도 다시 자동으로 서비스 해줄 수 있는 상황에 도달했습니다. 클라이언트 측에서는 어떻게 사용할 수 있는지 확인해보겠습니다.

    ssh 192.168.10.129
    를 입력하여 클라이언트로 접속합니다.


    .

    클라이언트의 root 패스워드를 입력하여 ssh 연결을 성립시킵니다.

    ls -l /misc
    를 입력하여

    파일이 정상적으로 위치해있는지 확인합니다.

    이제 클라이언트가 서버의 디렉토리에 무언가 정상적으로 적을 수 있는지, 꺼내오고, 읽을 수 있는지 확인하는 절차만이 남았습니다.

    cp /etc/inittab /misc/nfs_auto
    를 입력하여 nfs_auto에 무언가 적어보겠습니다.

    ls -al /misc/nfs_auto
    를 입력하여, inittab 이 정상적으로 작성됐는지 확인해봅니다.

    -rw-r--r-- 1 root root 511 11월  19 20:23 inittab
    같은 구문이 나온다면 성공입니다.
    서버측의 디렉토리에 쓴건지 확인하기 위하여 다시 서버로 넘어가겠습니다.


    .

    exit 를 입력하여 ssh 접속을 종룧바니다.

    ls -l /nfs
    를 입력하여 nfs 서비스를 통해 nfs에 정상적으로 inittab 이 들어가 있는지 확인합니다.

    -rw-r--r-- 1 root root 511 11월  19 20:23 inittab
    같은 구문이 출력되는 경우, 정상적으로 작동하는것을 뜻합니다.






p8_nfs_self.txt
    문제 내용 :
    1.server 또는 이외의 리눅스 운영체제를 사용하는 머신에서 1GB HDD를 추가하고 500MB 파티션을 생성한다
    2. 1번에서 만든 파티션을 /nfs 디렉터리에 오토마운트한다.
    3. 재부팅 후 mount 명령어로 nfs 연결하고 마운트 정보를 확인한다

    문제 해결 :


    .


    해당 문제 해결 시나리오 에서는
    VMware Pro 15.N 버전을 사용합니다.
    아래의 상황을 그대로 따라하지 않고싶거나, 따라할 수 없는 상황에서는
    '하드디스크의 추가'라는 부분만이라도 정확히 파악하고, 수행하면 됩니다.


    '하드디스크의 추가'
    VMware 의 Memory 를 눌러서 설정 창을 엽니다.
    설정 창을 연 후, ADD 버튼을 눌러 하드디스크 하나를 더 추가해줄겁니다.
    디스크 타입 등등 여러가지 부가적인 설정은 어떻게 되든 상관은 없습니다.
    다만, 이번 문제에서는 '1GB HDD'라고 명시되어 있으니
    용량을 맞추는 영역에서, 1GB를 맞춰주도록 합니다.

    설정을 전부 마쳤으면, ok 를 눌러 설정을 저장하고, 가상머신을 다시 실행시킵니다.
    sd 뒤에 a부터 a , b , c 순서로 추가적인 글자가 하나 더 있을텐데,
    예를 들어
    sda1 이라는 파티션이 있다면, 이는
    sd 형식의 a니까 1번째의 1번 번호를 가진 파티션 이라는 뜻입니다.

    예를 들어 이번에 추가된 하드디스크가
    sdb 라는 이름을 부여받았다면,
    sdb1 라는 이름으로 파티션을 만들어 줄 수 있다는 뜻입니다.


    .


    '파티션 생성'
    이번에 수행해줄 작업은 파티션을 생성해준다는 중심 내용을 가지고 있습니다.

    우선, 파티션을 만들어줄 물리적인 장치의 이름을 알아야 하는데
    우리가 추가해준 장치는, 아직 아무런 파티션도 만들어주지 않은 상태일것이니
    /dev 디렉터리로 들어가 sd 와 관련된 파일을 찾아봅니다.
    그중에서, sd 뒤에 따라붙는 영어 철자가 가장 마지막인것이 우리가 방금 추가한 하드디스크일겁니다.
    brw-rw----. 1 root disk 8,  0 Dec 20 21:38 sda
    brw-rw----. 1 root disk 8,  1 Dec 20 21:38 sda1
    brw-rw----. 1 root disk 8,  2 Dec 20 21:38 sda2
    brw-rw----. 1 root disk 8,  3 Dec 20 21:38 sda3
    brw-rw----. 1 root disk 8, 16 Dec 20 21:38 sdb
    같은 파일들이 있는 상황이라면, 우리가 방금 추가해준 하드디스크는 sdb일 것이라는 이야기입니다.

    이번 문제에서는 sdb 에서 작업을 수행합니다.

    아무튼, 이제 우리가 파티션을 생성하고싶은 디스크(장치)가 무엇인지 확인을 하는 과정을 거쳤으니,
    실질적으로 파티션을 만들어보도록 하겠습니다.

    fdisk /dev/sdb
    를 입력하여, sdb 장치의 파티션 설정을 시작하겠습니다.

    Command (m for help) :
    라는 구문이 나온다면

    n
    을 입력해서 새로운 파티션을 만들어주도록 하겠습니다.


    Partition type:
        p   primary (0 primary, 0 extended, 4 free)
        e   extended
    Select (default p) :
    라는 구문이 나온다면 

    p
    를 입력해서 엔터를 치거나 아무것도 입력하지 않은 채로 엔터를 눌러서 Primary 파티션을 만들어주도록 하겠습니다.


    Partition number (1-4, default 1) :
    이라는 구문이 나온다면

    1
    이나, 아무것도 입력하지 않은 상태로 입력을 해서, 우리가 마운트해야할 파티션의 이름이 sdb1 이 되도록 만들어줍니다.


    Last sector, +sectors on +size{K,M,G} (2048-2097151, default 2097151):
    이라는 구문이 나온다면

    +500M
    을 입력하여 500 MB 크기의 파티션을 만들어주도록 하겠습니다.

    w
    를 입력하여 /dev/sdb 의 fdisk 작업을 종료합니다.

    지금까지
    500메가바이트의 크기를 가진, sdb1 이라는 이름의 파티션을 만들었습니다.

    mkfs.xfs /dev/sdb1
    을 입력해서, sdb1 이라는 이름을 가진 파티션을 xfs 라는 파일 시스템 형식으로써 포맷해주겠습니다.
    이 명령어를 입력하지 않으면 '파일 시스템'이 반드시 주어져야하는 파티션의 입장에서 아무것도 할 수 없는 상태가 돼버립니다.
    (*
    [root@localhost dev]# mkfs.xfs /dev/sdb1
    meta-data=/dev/sdb1              isize=512    agcount=4, agsize=32000 blks
            =                       sectsz=512   attr=2, projid32bit=1
            =                       crc=1        finobt=0, sparse=0
    data     =                       bsize=4096   blocks=128000, imaxpct=25
            =                       sunit=0      swidth=0 blks
    naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
    log      =internal log           bsize=4096   blocks=855, version=2
            =                       sectsz=512   sunit=0 blks, lazy-count=1
    realtime =none                   extsz=4096   blocks=0, rtextents=0
    이와같은 출력문은, 정상적으로 작동되고 있다는 뜻일겁니다.
    )

    우리는 최종적으로

    /dev/sdb1 이라는 위치에 있는
    500 메가바이트의 크기를 가진
    xfs 라는 파일 시스템을 사용하는
    파티션을 만들어줬습니다.

    이제 오토마운트를 설정하겠습니다.


    .


    '오토마운트'

    오토 마운트를 관리하는 파일은
    /etc/fstab
    입니다.

    vi /etc/fstab
    를 입력해서 vi 에디터로 fstab 을 열어주겠습니다.

    해당 문서 말단에
    /dev/sdb1   /nfs    xfs     default     0 0
    을 입력해주고, 저장해주고, vi 에디터를 종료합니다.

    위의 구문의 뜻은 다음과 같습니다.

    /dev/sdb1       /nfs     xfs     defaults        0 0
    장치명          : /dev/sdb1
    마운트 포인트   : /nfs
    장치의 fs type  : xfs
    마운트 옵션     : default
    dump 운용       : 0(안함)
    부팅시 fsck 동작: 0(안함)

    (*해당 디렉토리의 f3_fstab.txt 으로부터 발췌)



    이제 이러한 자동적인 마운트가 정상적으로 작동하는지 확인하기 위해서 재시작하고, 정상작동을 확인해보겠습니다.

    init 6
    를 입력하여 머신을 다시 시작합니다.

    다시 터미널로 돌아와서

    df -h
    를 입력합니다.

    [root@localhost /]# df -h
    Filesystem      Size  Used Avail Use% Mounted on
    devtmpfs        471M     0  471M   0% /dev
    tmpfs           487M     0  487M   0% /dev/shm
    tmpfs           487M  8.5M  478M   2% /run
    tmpfs           487M     0  487M   0% /sys/fs/cgroup
    /dev/sda3       8.7G  4.3G  4.5G  49% /
    /dev/sdb1       497M   26M  472M   6% /nfs
    /dev/sda1       297M  152M  145M  52% /boot
    tmpfs            98M   20K   98M   1% /run/user/0

    이와 똑같은 화면이 아니더라도 아래의
    /dev/sdb1       497M   26M  472M   6% /nfs
    이 행이 가장 중요합니다. 우리가 방금 설정해준거니까요.

    /dev/sdb1 은 당연하게도 파티션의 이름일것이고
    497M    은 전체 크기
    26M     은 사용된 용량
    472M    은 남은 용량,
    6%      은 남은 용량 대비 사용된 용량의 퍼센트에이지일것입니다.
    /nfs    는 마운트된 디렉터리입니다.

    이제 nfs 서비스를 적용시키는 일이 남았습니다.


    .


    'nfs 서비스 와 방화벽'

    우선, nfs 서비스에 관하여 방화벽을 설정해주도록 하겠습니다.

    systemctl restart nfs
    라고 입력하여 nfs를 (재)시작합니다.

    systemctl status nfs
    를 입력해서 중간에 'Active: active'라고 (초록색 글자로)출력되어있다면 문제없이 작동하는것입니다. 일단 이 이후의 작업을 하려면 이 확인절차는 반드시 필요합니다.

    nfs가 정상적으로 작동하는것을 확인했으니, 방화벽을 설정하여 이 nfs서비스에 관한 포트는 예외로 둡니다.

    firewall-cmd --permanent --add-service=nfs
    를 입력하여 firewall(방화벽)을 통해 nfs서비스 통신을 할 수 있도록 방화벽 설정을 해줍니다.

    firewall-cmd --reload
    를 입력하여 firewall(방화벽)설정을 해준것을 reload(재시작)함으로써 다시 시작합니다.

    이제 실질적으로 nfs 서비스를 설정해보겠습니다.


    .


    'nfs 서비스의 설정파일인 /etc/exports 설정'


    vi /etc/exports
    를 입력하여, client 에서 접속해서 client 의 로컬 디렉토리처럼 사용할 수 있게 설정해주도록 하겠습니다.
    (https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hanajava&logNo=220422771247 발췌)

    해당 문서 말단에

    /nfs    192.168.127.128(rw,no_root_squash,sync)
    를 입력합니다. 의미는 아래와 같습니다.
    /nfs    : 제공자 측에서 제공해줄 파티션이 마운트된 파일 위치


    192.168.127.128 : 사용자 측의 아이피
    rw      : 작업 형식. 일고, 쓰는것 모두를 허용한다는 내용이다.
    no_root_squash : client의 root를 서버의 root로 매핑 (최상위 관리자 접속으로 시도하는 경우, 상대방의 최상위 관리자의 이름이 어떻게 되든지간에 '최상위 관리자'라는 것에 맞춰 연결해줌)
    sync    : 파일 시스템이 변경되면 즉시 동기화

    다만, 이번에 사용할 사용자는 '본인'입니다.
    서버의 컴퓨터에서 nfs 를 스스로 제공하고, 스스로 사용한다는 컨셉의 문제입니다.

    따라서, 제공자와 사용자의 아이피가 똑같은게 특징입니다.

    위에서 사용된
    192.168.127.128
    이라는 주소를 입력하지 말고, 자신의 리눅스에서 사용되고 있는 IP 를 적어넣어야 합니다.

    만약에 '됐었는데, 안됨'같은 종류의 문제가 있다면

    mount, firewall, DHCP 의 문제일것입니다.
    이중에서 'IPv4 주소'의 부분에서 발생될 수 있는 문제로써는
    DHCP를 사용함으로써 이미 설정해놓은 exports에 적혀 있는 아이피와,
    현재 nfs 서비스를 제공하는 서버의 아이피가 달라지는 상황이 있을 수 있습니다.

    이는 DHCP의 사용을 중지하고, 고정된 아이피를 설정함으로써 해결할 수 있습니다.

    아무튼, 이렇게 nfs 서비스를 다루는 파일인 /etc/exports 를 설정해줬습니다.


    이제 서비스가 설정됐는지, 확인하는 작업을 거치겠습니다.


    .


    'nfs 서비스 정상 작동 확인 절차'

    init 6
    를 입력해서 시스템을 재시작해줍니다.

    그리고, root의 권한을 가지고 제자리로 돌아온 후

    exportfs -v
    를 입력해서 현재 nfs 서비스를 진행하고 있는게 뭔지 살펴봅니다. 만약에 아무것도 뜨지 않은 경우에는 위의 과정을 다시 거쳐야합니다.
    (*
    [root@localhost ~]# exportfs -v
    /nfs            192.168.127.128(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,no_root_squash,no_all_squash)
    )
    이러한 비슷한 형식으로써 잘 출력되면 문제 없는것입니다.
    이제 실질적으로 마운트를 하고, 제 기능을 하는지 확인해보겠습니다.


    .



    'nfs 서비스 작동'

    mkdir /nfs_client
    를 입력하여 클라이언트의 입장이 될 디렉터리 하나를 만들어주겠습니다.

    mount -t nfs 192.168.127.128:/nfs /nfs_client
    를 입력하여 마운트를 해줍니다.

    cp /etc/inittab /nfs_client
    같은 명령어 이외에도, 안에 무언가 들어갔음을 증명할 수 있는 파일 하나를 대충 만들어서 /nfs_client 안에 넣어주면 됩니다.

    ls -l /nfs_client
    를 입력해줍니다. 정상적으로
    (*
    [root@localhost /]# ls -l nfs_client/
    total 4
    -rw-r--r-- 1 root root 511 Dec 21 15:34 inittab
    )
    같은 구문이 출력된다면, 파일 복붙까지는 정상적으로 된것입니다.

    이제 핵심입니다.

    우리는 /nfs에 무언가 복붙해넣지도, 무언가 작성하지도 않았습니다.
    만약에, /nfs 안에 무언가 들어있다면
    우리가 앞에서 설정해준 nfs 서비스에 대한 모든 것들이 정상적으로 작동하고있음을 증명할것입니다.

    결과는 다음과 같습니다.


    [root@localhost /]# ls -l /nfs
    total 4
    -rw-r--r-- 1 root root 511 Dec 21 15:34 inittab

    정상적으로 출력되는것을 확인할 수 있습니다!

    수고하셨습니다.


p9_DHCP.txt
    문제 내용 :

    *virtual network editer 에 있는 VMnet 8의 DHCP가 켜져있다면 끄고 진행 필요
    1.  범위    : 192.168.127.0/24
        할당 IP : 51~60
        GW      : 192.168.127.2
        DNS     : 192.168.127.2
        최소임대기간 : 3일
        최대임대기간 : 6일

        위의 설정을 갖고있는 dhcp서버를 재부팅 후에도 동작 가능하도록 설정
        client에서 IP 할당 받아보기
        (1번이 완료된 후 virtual network editer에서 VMnet 8의 DHCP를 켜주세요)

    2. windows에서 client의 공유폴더 접근하여 메모장파일 만들어보기 (단, 접속은 testuser로 진행함)

    추가정보 :
    virtual network editer 에 있는 VMnet 8의 Subnet Address 는 '192.168.127.0' 이다.

    문제 해결 :

    이 아래의 실습은 server 컴퓨터에서 진행합니다.
    만약 dhcp 서비스 자체가 깔려있지 않은 경우에는 

    yum -y install dhcp-*
    를 입력하여 dhcp 에 관한 패키지들을 다운받습니다

    vi /etc/dhcp/dhcpd.conf
    를 입력하여 dhcp 의 주된 설정 파일을 엽니다.

    그리고 그 파일 말단에 

    subnet 192.168.127.0 netmask 255.255.255.0 {
        range dynamic-bootp 192.168.127.51 192.168.127.60;
        option subnet-mask 255.255.255.0;
        option routers 192.168.127.2;
        option domain-name-servers 192.168.127.2;
        default-lease-time 259200;
        max-lease-time 518400;
    }

    이라고 입력하고, 저장하고, 나옵니다.

    systemctl restart dhcpd
    를 입력하여 dhcp 서비스의 설정값을 적용하고 다시 시작합니다.


    .


    이 아래의 실습은 client 컴퓨터에서 진행합니다.


    특히, 이 실습은 client 의 컴퓨터에서 putty 를 사용하지 않고 진행함을 알아주시면 더 이해하기 편하실겁니다.

    설정 > 네트워크 > 유선 
    의 톱니바퀴 버튼을 클릭하여 유선의 설정으로 들어갑니다.

        자세히 보기
        신원
        IPv4
        IPv6
        보안
    중에서,
        IPv4
    를 클릭합니다

    IPv4 의 방식을 '자동(DHCP)' 로 바꾸고서
    그 아래에 있는
    네임서버(DNS)에 적혀있는 무언가를 없애줍니다.

    오른쪽 위에 파란 버튼인

    '적용'
    버튼을 눌러서 적용을 하고, 나옵니다

    유선 아래에 있는 스위치를 껏다 킴으로써 다시 연결을 하고
    톱니바퀴 버튼을 눌러 다시 상태를 확인합니다.

    이 과정에서 시간이 조금 걸릴 수 있으나 보통 5분 내외로 다시 연결되는것을 확인할 수 있습니다


p10_samba.txt
    문제 내용 :
    client(192.168.127.129)에서 samba 를 이용해 윈도우에서 파일 열고 저장하기

    윈도우가 접속할때 사용할 계정은
    testuser 이라는 이름의 유저이고
    ghdwpaks 이 비밀번호이다.

    문제 해결 :

    만약 client 에 samba 가 없을 경우에는

    yum -y install samba-*
    를 입력하여 samba 관련 패키지를 받아준다

    vi /etc/samba/smb.conf
    를 입력하여 samba 의 설정파일을 열어준다.
    파일 내용 예시 (*

    # See smb.conf.example for a more detailed config file or
    # read the smb.conf manpage.
    # Run 'testparm' to verify the config is correct after
    # you modified it.

    [global]
        workgroup = SAMBA
        security = user
        
        passdb backend = tdbsam

        printing = cups
        printcap name = cups
        load printers = yes
        cups options = raw

    [homes]
        comment = Home Directories
        valid users = %S, %D%w%S
        browseable = No
        read only = No
        inherit acls = Yes

    [printers]
        comment = All Printers
        path = /var/tmp
        printable = Yes
        create mask = 0600
        browseable = No

    [print$]
        comment = Printer Drivers
        path = /var/lib/samba/drivers
        write list = @printadmin root
        force group = @printadmin
        create mask = 0664
        directory mask = 0775
    )

    workgroup = SAMBA
    이라고 적혀있는 곳을

    workgroup = WORKGROUP
    으로 바꿔주고,


    여기서 파일 말단에

    [userShare_client]
        comment = client test
        path = /samba/user
        writeable = Yes
        read only = No
        valid users = @testuser
    을 넣어주고 저장하고 나옵니다

    파일 결과 예시 (*
    # See smb.conf.example for a more detailed config file or
    # read the smb.conf manpage.
    # Run 'testparm' to verify the config is correct after
    # you modified it.

    [global]
        workgroup = WORKGROUP
        security = user
        
        passdb backend = tdbsam

        printing = cups
        printcap name = cups
        load printers = yes
        cups options = raw

    [homes]
        comment = Home Directories
        valid users = %S, %D%w%S
        browseable = No
        read only = No
        inherit acls = Yes

    [printers]
        comment = All Printers
        path = /var/tmp
        printable = Yes
        create mask = 0600
        browseable = No

    [print$]
        comment = Printer Drivers
        path = /var/lib/samba/drivers
        write list = @printadmin root
        force group = @printadmin
        create mask = 0664
        directory mask = 0775
    [userShare_client]
        comment = client test
        path = /samba/user
        writeable = Yes
        read only = No
        valid users = @testuser

    )

    이제 samba 관련 파일 설정은 끝났으니, 유저를 만들고 설정해보겠습니다 

    useradd testuser
    을 입력하여 testuser 계정을 생성해주고,

    passwd testuser
    을 입력하고

    ghdwpaks
    과
    ghdwpaks
    을 입력하여 testuser 의 비밀번호를 'ghdwpaks' 으로 맞춰줍니다. 두번 입력하는 이유가, 하나는 질문응답용이고, 하나는 오타방지를 위한 확인절차때문입니다.

    smbpasswd -a testuser
    에도

    ghdwpaks
    과
    ghdwpaks
    을 입력해줍니다

    이렇게 설정을 끝냈으니

    systemctl restart smb
    데몬을 다시 시작해주고,

    firewall-cmd --permanent --add-service=samba
    를 입력하여 방화벽 예외처리도 해주고

    firewall-cmd --reload
    를 입력하여 방화벽을 다시 시작해서 앞서 설정한 예외처리를 진짜로 적용시켜줍니다.


    .



    아래의 과정은 windows 에서 진행합니다.

    Window 키 + R
    을 입력해서 PowerShell 을 켜주고

    \\192.168.127.129
    를 입력해줍니다.

    그리고 자격증명에

    testuser 와 ghdwpaks 을 입력해줍니다.

    정상적으로 userShare_client 폴더를 찾을 수 있게 됩니다.




p11_DNS.txt
    DNS 설정에 대한 전체적인 맥락에 대한 문서입니다.

    행운을 빌겠습니다.

    시작합니다.

    vi /etc/named.conf
    /etc/named.conf 엽니다

    listen-on port 53 { any; };
    allow-query { any ; };

    바꿉니다.

    나옵니다.

    /etc/named.conf의 내용물

    [root@server ~]# cat /etc/named.conf
    //
    // named.conf
    //
    // Provided by Red Hat bind package to configure the ISC BIND named(8) DNS
    // server as a caching only nameserver (as a localhost DNS resolver only).
    //
    // See /usr/share/doc/bind*/sample/ for example named configuration files.
    //
    // See the BIND Administrator's Reference Manual (ARM) for details about the
    // configuration located in /usr/share/doc/bind-{version}/Bv9ARM.html

    options {
            listen-on port 53 { any; };
            listen-on-v6 port 53 { ::1; };
            directory       "/var/named";
            dump-file       "/var/named/data/cache_dump.db";
            statistics-file "/var/named/data/named_stats.txt";
            memstatistics-file "/var/named/data/named_mem_stats.txt";
            recursing-file  "/var/named/data/named.recursing";
            secroots-file   "/var/named/data/named.secroots";
            allow-query     { any; };

            /*
            - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
            - If you are building a RECURSIVE (caching) DNS server, you need to enable
            recursion.
            - If your recursive DNS server has a public IP address, you MUST enable access
            control to limit queries to your legitimate users. Failing to do so will
            cause your server to become part of large scale DNS amplification
            attacks. Implementing BCP38 within your network would greatly
            reduce such attack surface
            */
            recursion yes;

            dnssec-enable yes;
            dnssec-validation yes;

            /* Path to ISC DLV key */
            bindkeys-file "/etc/named.root.key";

            managed-keys-directory "/var/named/dynamic";

            pid-file "/run/named/named.pid";
            session-keyfile "/run/named/session.key";
    };

    logging {
            channel default_debug {
                    file "data/named.run";
                    severity dynamic;
            };
    };

    zone "." IN {
            type hint;
            file "named.ca";
    };

    include "/etc/named.rfc1912.zones";
    include "/etc/named.root.key";
    [root@server ~]#

    저장하고 나온 다음

    vi /etc/named.rfc1912.zones
    로 엽니다

    파일 말단으로 이동하여


    zone "linux.edu" IN {
            type master;
            file "linux.edu.zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    zone "127.168.192.in-addr.arpa" IN {
            type master;
            file "192.168.127.zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    을 입력합니다.

    저장하고
    나옵니다.

    /etc/named.rfc1912.zones 의 내용물

    [root@server ~]# cat /etc/named.rfc1912.zones
    // named.rfc1912.zones:
    //
    // Provided by Red Hat caching-nameserver package
    //
    // ISC BIND named zone configuration for zones recommended by
    // RFC 1912 section 4.1 : localhost TLDs and address zones
    // and http://www.ietf.org/internet-drafts/draft-ietf-dnsop-default-local-zones-02.txt
    // (c)2007 R W Franks
    //
    // See /usr/share/doc/bind*/sample/ for example named configuration files.
    //

    zone "localhost.localdomain" IN {
            type master;
            file "named.localhost";
            allow-update { none; };
    };

    zone "localhost" IN {
            type master;
            file "named.localhost";
            allow-update { none; };
    };

    zone "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa" IN {
            type master;
            file "named.loopback";
            allow-update { none; };
    };

    zone "1.0.0.127.in-addr.arpa" IN {
            type master;
            file "named.loopback";
            allow-update { none; };
    };

    zone "0.in-addr.arpa" IN {
            type master;
            file "named.empty";
            allow-update { none; };
    };

    zone "linux.edu" IN {
            type master;
            file "linux.edu.zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    zone "127.168.192.in-addr.arpa" IN {
            type master;
            file "192.168.127.zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    [root@server ~]#


    touch 192.168.127.zone
    touch linux.edu.zone
    을 하여 zone 형식 파일을 만든다.

    vi 192.168.127.zone
    안에
    $TTL 1D
    @       IN SOA  linux.edu.              root(
                                            0       ; serial
                                            1D      ; refresh
                                            1H      ; retry
                                            1W      ; expire
                                            3H )    ; minimum
            IN      NS      linux.edu.
            IN      A       192.168.127.128

    128     IN      PTR     www.linux.edu.
    을 입력한다.

    192.168.127.zone
    안에 내용은 다음과 같다.
    [root@server named]# cat 192.168.127.zone
    $TTL 1D
    @       IN SOA  linux.edu.              root(
                                            0       ; serial
                                            1D      ; refresh
                                            1H      ; retry
                                            1W      ; expire
                                            3H )    ; minimum
            IN      NS      linux.edu.
            IN      A       192.168.127.128

    128     IN      PTR     www.linux.edu.
    [root@server named]#

    vi linux.edu.zone
    안에
    $TTL 86400
    @       IN SOA  linux.edu.              root(
                                            0       ; serial
                                            86400   ; refresh
                                            3600    ; retry
                                            604800  ; expire
                                            10800 ) ; minimum
            IN      NS      linux.edu.
            IN      A       192.168.127.128

    www     IN      A       192.168.127.128
    입력한다.

    linux.edu.zone
    내용은 다음과 같다.
    [root@server named]# cat linux.edu.zone
    $TTL 86400
    @       IN SOA  linux.edu.              root(
                                            0       ; serial
                                            86400   ; refresh
                                            3600    ; retry
                                            604800  ; expire
                                            10800 ) ; minimum
            IN      NS      linux.edu.
            IN      A       192.168.127.128

    www     IN      A       192.168.127.128
    [root@server named]#

    chmod 660 *.zone
    으로 권한을 바꾸고

    chown .named *.zone
    으로 주인을 바꾸고

    systemctl restart named
    를 입력하여 여태까지 설정한 정보들을 적용시킨다.


p12_DNS.txt
    www.ghdwpaks.com
    도메인 세팅하기


    문제 해결 :

    0. yum -y install bind-*
    0. named.conf 설정
    1. /etc/named.rfc1912.zones 에 zone 추가
    2. /var/named 에 zone 파일 추가 및 설정
    3. zone 파일들 권한 설정
    4. /etc/resolv.conf 파일 설정
    5. named 데몬 재실행


    0. named.conf 설정
        
        listen-on port 53 { any; };
        allow-query     { any; };
        dnssec-enable yes;



    1. /etc/named.rfc1912.zones 에 zone 추가
    zone "linux.edu" IN {
            type master;
            file "linux.edu.zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    zone "127.168.192.in-addr.arpa" IN {
            type master;
            file "192.168.127.zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    형식

    [1] = linux.edu
    zone "[1]" IN {
            type master;
            file "[1].zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    192.168.127.128
    [2].[3].[4].[5]
    [2] = 192
    [3] = 168
    [4] = 127
    [5] = 128
    zone "[4].[3].[2].in-addr.arpa" IN {
            type master;
            file "[2].[3].[4].zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    2. /var/named 에 zone 파일 추가 및 설정

    touch [1].zone
    touch [2].[3].[4].zone
    으로 추가


    $TTL 1D
    @       IN SOA  [1].      root(
                                    0       ; serial
                                    1D      ; refresh
                                    1H      ; retry
                                    1W      ; expire
                                    3H )    ; minimum
            IN      NS      [1].
            IN      A       [2].[3].[4].[5]
    이라고 전부 작성

    www     IN      A       [2].[3].[4].[5]
    [5]     IN      PTR     www.[1]

    3. zone 파일들 권한 설정

    chmod 660 [1].zone
    chmod 660 [2].[3].[4].zone

    chown .named [1].zone
    chown .named [2].[3].[4].zone

    4. /etc/resolv.conf 파일 설정
    vi /etc/resolv.conf
    열어서
    맨 첫줄에
    nameserver 192.168.127.128
    넣기


    5. systemctl restart named



p13_DNS_troubleshooting.txt
    이 문서는 DNS 를 설정하다 보면 만날 수 있는 각종 오류들의 구분방법과 출력 방법 등등을 서술합니다.

    systemctl status named | journalctl -xe

    '잘 진행되다가 이상함'


    .


    모든 시작은 '문제 인식'으로부터 시작합니다.
    이 모든 과정은 창을 작게 하지 않는것을 강력히 권장합니다. 
    텍스트가 나오다가 잘리는 경우가 생깁니다.

    systemctl restart named
    이후에
    Job for named.service failed because the control process exited with error code. See "systemctl status named.service" and "journalctl -xe" for details.
    같은 구문이 출력된다면 오류에 걸린것입니다. 아니면 이러한 구문이 뜨지 않더라도

    systemctl status named
    로 named 서비스의 상태를 확인했을때 무언가 이상하고 active 같은 '정상 작동중'이라는 구문이 뜨지 않은 영우에는 문제가 생긴것이라고 인식하는게 좋습니다.


    .


    이제 '문제 해결'의 시간입니다.
    위에서 떴었던것처럼 

    systemctl status named.service
    와
    journalctl -xe
    를 통해 어떠한 문제가 발생했는지 확실하게 알아보라고 나옵니다.

    systemctl status named | journalctl -xe
    을 입력하여 상세한 캐시 기록을 확인해보겠습니다.


    .


    url 입력 실수 문제 상황입니다.

    11월 23 31:31:45 server bash[5513]: zone localhost.localdomain/IN: loaded serial 0
    11월 23 31:31:45 server bash[5513]: zone localhost/IN; loaded serial 0
    12월 26 00:26:20 server bash[2011]: zone 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa/IN: loaded serial 0
    11월 23 31:31:45 server bash[5513]: zone 1.0.0.127.in-addr.arpa/IN: loaded serial 0
    11월 23 31:31:45 server bash[5513]: zone 0.in-addr.arpa/IN: loaded serial 0
    11월 23 31:31:45 server bash[5513]: zone linux.edu/IN: loaded serial 0
    11월 23 31:31:45 server bash[5513]: zone 127.168.192.in-addr.arpa/IN: NS 'linux.edu.127.168.192.in-addr.arpa' has no address rec
    11월 23 31:31:45 server bash[5513]: zone 127.168.192.in-addr.arpa/IN: not loaded due to errors.
    11월 23 31:31:45 server bash[5513]: _default/127.168.192.in-addr.arpa/IN; bad zone
    11월 23 31:31:45 server polkid[581]: Unregistered Authentication Agent for unix-process:5504:941337 (system bus name :1.187,
    11월 23 31:31:45 server systemd[1]: named.service: control process exited, code=exited status=1
    11월 23 31:31:45 server systemd[1]: Failed to start Berkeley Internet Name Domain (DNS).

    같은 구문에서 문제 없는 부분은
    11월 23 31:31:45 server bash[5513]: zone localhost.localdomain/IN: loaded serial 0
    같이
    serial 0
    라고 뜨는 곳은 웬만하면 이상이 없다는 이야기입니다.

    실질적인 문제는 '잘 가다가 이상해짐' 에서 발생하게 됩니다.
    11월 23 31:31:45 server bash[5513]: zone 127.168.192.in-addr.arpa/IN: NS 'linux.edu.127.168.192.in-addr.arpa' has no address rec
    같은 곳에서 말이죠.
    이번 경우에는 'has no address rec' 라고 하네요.
    이러한 'has no address rec'같은 경우에는
    /ver/named 
    안에 들어있는 파일이 문제가 되는 경우가 많습니다.

    이 파일 안에는 다음과같은 파일이 있는데,
    [root@server named]# ll
    합계 24
    -rw-rw---- 1 root  named  183 12월 25 11:04 192.168.127.zone
    drwxr-x--- 7 root  named   61 12월 25 09:43 chroot
    drwxr-x--- 7 root  named   61 12월 25 09:43 chroot_sdb
    drwxrwx--- 2 named named   23 12월 25 11:58 data
    drwxrwx--- 2 named named   60 12월 26 00:26 dynamic
    drwxrwx--- 2 root  named    6  4월  1  2020 dyndb-ldap
    -rw-rw---- 1 root  named  197 12월 25 11:19 linux.edu.zone
    -rw-r----- 1 root  named 2253  4월  5  2018 named.ca
    -rw-r----- 1 root  named  152 12월 15  2009 named.empty
    -rw-r----- 1 root  named  152  6월 21  2007 named.localhost
    -rw-r----- 1 root  named  168 12월 15  2009 named.loopback
    drwxrwx--- 2 named named    6 11월 25 01:38 slaves
    [root@server named]# 

    그중에서도

    [root@server named]# ll *.zone
    -rw-rw---- 1 root named 183 12월 25 11:04 192.168.127.zone
    -rw-rw---- 1 root named 197 12월 25 11:19 linux.edu.zone
    [root@server named]#
    를 중점으로 보시면 문제를 해결하는데에 있어서 아주 큰 도움이 될 것입니다.
    이중에서 문제가 일어났는데, 특히 'has no address rec' 문제이니까 
    f12_zone.txt 문서에 서술되어있는
        IN      NS      linux.edu.
        IN      A       192.168.127.128
    쪽에서 문제가 일어났을 가능성이 큽니다.

    이번 경우에는 
    IN      NS      linux.edu.
    라고 써야했었는데
    IN      NS      linux.edu
    라고만 적어놔서 문제가 일어났었네요.
    수정하고,

    systemctl restart named
    를 입력하여 정상작동하는지 알아보겠습니다.


    .


    세미콜론 미입력 문제 상황에 대한 내용입니다.
    틍징으로써는 세미콜론과 중괄호 missing 오류 구문이 많다는게 특징입니다

    11월 23 31:31:45 server bash[8875]: /etc/named.rfc1912.zone:47: missing ';' before 'allow-transfer'
    11월 23 31:31:45 server bash[8875]: /etc/named.rfc1912.zone:48: missing ';' before '}'
    11월 23 31:31:45 server bash[8875]: /etc/named.rfc1912.zone:54: missing ';' before 'allow-transfer'
    11월 23 31:31:45 server bash[8875]: /etc/named.conf:60: missing ';' before 'include'
    11월 23 31:31:45 server bash[8875]: /etc/named.root.key:1: unknown option 'managed-keys'
    11월 23 31:31:45 server bash[8875]: /etc/named.conf:62 '}' expected near end of file
    11월 23 31:31:45 server systemd[1]: named.service: contol process exited, code=exited status=1 
    11월 23 31:31:45 server polkitd[574]: Unregistered Authentication Agent for unix-process:8866:697388
    11월 23 31:31:45 server systemd[1]: Failed to start Berkeley Internet Name Domain (DNS).

    이러한 구문이 출력된 경우 파일과 그 파일의 라인이 정확하게 나옵니다.
    맨 첫번째 줄인 
    11월 23 31:31:45 server bash[8875]: /etc/named.rfc1912.zone:47: missing ';' before 'allow-transfer'
    을 예로 들자면

    /etc/named.rfc1912.zone 파일의 
    47 번째 줄에 
    before 'allow-transfer' , 'allow-transfer' 하기 전에
    missing ';' 세미콜론을 찾지 못했다

    라는 뜻입니다.

    이제 문제가 어디서 발생했는지 바로 알았으니

    vi /etc/named.rfc1912.zone
    으로 문제를 해결하러 가보겠습니다.

    이번 문제 상황에서는 원래대로

    zone "127.168.192.in-addr.arpa" IN {
            type master;
            file "192.168.127.zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    라고 적혀있어야했는데

    zone "127.168.192.in-addr.arpa" IN {
            type master
            file "192.168.127.zone"
            allow-update {any;}
            allow-transfer {any;}
    };
    라고 되어있었습니다.

    다시 정상적으로 수정해주고 저장하고, 나오겠습니다.


    systemctl restart named
    를 입력하여 정상작동하는지 알아보겠습니다.


    .


    단어를 잘못 선택한 경우에 대해 서술합니다.

    이번 경우에는 오류 구문이 아주 적은게 특징입니다.

    11월 23 31:31:45 server bash[8875]: /etc/named.rfc1912.zones:47: unknown option 'allow-trasfer'
    11월 23 31:31:45 server systemd[1]: named.service:control process exited, code=exited status=1
    11월 23 31:31:45 server systemd[1]: Failed to start Berkeley Internet Name Domain (DNS).

    이번 구문에서는
    11월 23 31:31:45 server bash[8875]: /etc/named.rfc1912.zones:47: unknown option 'allow-trasfer'
    이 문장 하나에서
    /etc/named.rfc1912 파일에서
    zones   존 설정 영역인데
    47      번째 줄에 있는
    unknown option 알지 못한 옵션인
    'allow-trasfer' 이 적혀있어서 에러가 났다.
    라고 합니다.

    vi /etc/named.rfc1912.zones
    로 들어간 다음

    :/trasfer
    을 입력하여 문제가 생긴 줄로 이동합니다.

    zone "127.168.192.in-addr.arpa" IN {
            type master;
            file "192.168.127.zone";
            allow-update {any;};
            allow-trasfer {any;};
    };
    이라고 입력되어 있었네요. 정상적으로 
            allow-trasnfer {any;};
    이라고 바꿔준 후 vi 를 나오고

    systemctl restart named
    로 정상작동을 확인합니다.


    .


    진짜 정상 작동 확인 을 하겠습니다.

    앞서 실행했던
    systemctl restart named
    systemctl status named
    명령어들은 그저 DNS 데몬이 정상적으로 구동이 되는지 확인한것 뿐이였습니다.

    이제 정말로 DNS 기능이 정상작동하는지 확인하는 과정을 설명하겠습니다.

    vi /etc/resolv.conf
    파일을 열어서, 맨 처음 FQDN 을 검색하는 주소를 나 자신으로 설정해두겠습니다.

    # Generated by NetworManager
    nameserver 192.168.127.128
    nameserver 192.168.127.2

    라고 적겠습니다. 다르게 적는다면


    # Generated by NetworManager
    nameserver 192.168.10.128
    nameserver 192.168.10.2
    라고도 적을 수 있을것 같습니다.

    '나 자신의 DNS'를 '제일 먼저'찾는다는게 중요합니다.
    맨 첫째줄에 적힌
    nameserver 192.168.127.128
    이 문장 이외에 다음 문장에 뭐가 적히든 상관 없으나 (주석을 제외하고) 맨 처음 오는 문장은 이렇게 나 자신을 찾는 문장이여야합니다.

    이제 n(ame)s(server)lookup으로 통신확인을 해보겠습니다.

    nslookup
    을 입력합니다.

    www.linux.edu 를 쳤을때

    >www.linux.edu
    Server:     192.168.127.128
    Address:    192.168.127.128#53

    Name:       www.linux.edu
    Address:    192.168.127.128
    >

    이라고 나오고, 192.168.127.128 이라고 쳤을때

    >192.168.127.128
    129.127.168.192.in-addr.arpa    name = www.linux.edu.
    >

    이라고 나와야합니다.
    주소가 완전히 똑같지 않을 수도 있습니다. 하지만 겉으로 보기에
    위와 같은 출력 형식과 크게 다르지 않아야 합니다.

    버전마다 출력 형식이 다를 수 있습니다만 통상적으로 그래야한다는것이고
    최소한
    정상적인 FQDN 와 IPv4 가 출력되야하는것은 맞습니다.

    다만, 이 상황에서도 에러가 날 수 있습니다


    .


    nslookup 도중 일어날 수 있는 오류 상황에 대해 서술하겠습니다.


    [root@server named]# nslookup
    > www.linux.edu
    Server:         192.168.127.2
    Address:        192.168.127.2#53

    Non-authoritative answer:
    Name:   www.linux.EDU
    Address: 37.187.109.196
    Name:   www.linux.EDU
    Address: 2001:41d0:a:62c4::1
    > 192.168.127.128
    ** server can't find 128.127.168.192.in-addr.arpa.: NXDOMAIN
    >
    이번 경우에 핵심은
    '없었다. 그래서 외부까지 가야했다.'
    라는겁니다.

    > www.linux.edu
    Server:         192.168.127.2
    Address:        192.168.127.2#53
    이 문단을 잘 보면 서버와 주소가 나타나있는데,
    Server:         192.168.127.2 를 보면
    이 FQDN 를 검색하는 DNS server 의 주소가 우리 자신인 192.168.127.128 이 아닌, 게이트웨이에 물어보고있다는 것이 특징입니다.


    우리가 앞서 정상적으로 설정을 해줬는데도, 데몬 실행이 정상적으로 이루어지고 있음에도 불구하고 이러한 일이 일어난다는것은

    resolv.conf 설정을 안해줬다는 뜻입니다.
    resolv.conf 설정을 정상적으로 해주지 않았음으로 우리가 설정한 DNS 에 들어있는 정보를 검색하지 못했고, 결국에는 이 FQDN 에 관한 내용이나 IPv4 에 관한 내용이 보이지 않자 외부 인터넷까지 나가 FQDN 와 IPv4 를 검색한것입니다.

    이 폴더의 
    f8_resolv_conf.txt
    파일 안에 이러한 내용이 있습니다.

    vi /etc/resolv.conf 
    로 파일을 열고, 첫째줄에 자신의 아이피를 넣습니다.

    nameserver 192.168.127.128
    을 입력하고, 저장하고, 나옵니다.


    [root@server named]# cat /etc/resolv.conf
    # Generated by NetworkManager
    nameserver 192.168.127.128
    nameserver 192.168.127.2
    [root@server named]#

    이렇게 설정해주고, 다시 nslookup 을 실행하면

    [root@server named]# nslookup
    > www.linux.edu
    Server:         192.168.127.128
    Address:        192.168.127.128#53

    Name:   www.linux.edu
    Address: 192.168.127.128
    > 192.168.127.128
    128.127.168.192.in-addr.arpa    name = www.linux.edu.
    > exit

    [root@server named]#

    잘 되는 모습을 볼 수 있습니다.


    다만, FQDN 는 잘 검색이 됐지만 IPv4 로 검색하는 경우에 정상적으로 검색이 되지 않는 경우가 있습니다. 이러한 경우에는 다음과 같은 출력이 특징입니다.

    [root@server named]# nslookup
    > www.linux.edu
    Server:         192.168.127.2
    Address:        192.168.127.2#53

    Name:   www.linux.edu
    Address: 192.168.127.128
    > 192.168.127.128
    ** server can't find 128.127.168.192.in-addr.arpa.: NXDOMAIN
    >

    이러한 경우에는 linux.edu.zone 같은 파일은 정상적으로 작성됐지만
    192.168.127.zone 같은 파일의 작성이 이상하게 되어있는 경우입니다.

    해당 zone 파일들의 상태가 정상인 경우, named.rfc1912.zone 이 문제일겁니다.
    특히 이번 경우에는
    FQDN 은 검색할 수 있었으나 IPv4 는 검색할 수 없었기 때문에
    zone "127.168.192.in-addr.arpa" 쪽이 문제였습니다.





p15_DNS.txt
    FQDN : www.ghdghd.com
    IPv4 : 192.168.127.130
    도메인 세팅하기

    0. yum -y install bind-*
    0. named.conf 설정
    1. /etc/named.rfc1912.zones 에 zone 추가
    2. /var/named 에 zone 파일 추가 및 설정
    3. zone 파일들 권한 설정
    4. named 데몬 재실행


    0. named.conf 설정
        
        listen-on port 53 { any; };
        allow-query     { any; };
        dnssec-enable yes;


    1. /etc/named.rfc1912.zones 에 zone 추가
    zone "ghdghd.com" IN {
            type master;
            file "ghdghd.com.zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    zone "127.168.192.in-addr.arpa" IN {
            type master;
            file "ghdghd.rev";
            allow-update {any;};
            allow-transfer {any;};
    };

    2. /var/named 에 zone 파일과 rev 파일 추가 및 설정

    cp named.localhost ghdghd.zone
    vi ghdghd.zone
    으로 들어가서
    @       IN SOA  @ rname.invalid. (
    을
    @       IN SOA  ghdghd.com.     root(
    로 바꾼다.

    NS      @
            A       127.0.0.1
            AAAA    ::1
    을
        IN  NS  ghdghd.com.
        IN  A   192.168.127.130

    www IN  A   192.168.127.130
    으로 바꾼다

    나온다.

    cp ghdghd.zone ghdghd.rev
    vi ghdghd.rev
    로 들어간다

    www IN  A   192.168.127.130
    을
    130 IN  PTR www.ghdghd.com.
    으로 바꿔준다.

    3. zone 파일과 rev 파일 권한 설정
    chmod 660 ghdghd*
    chwon .named ghdghd*

    4. /etc/resolv.conf 파일 설정
    vi /etc/resolv.conf
    열어서 맨 첫줄에
    nameserver 192.168.127.128
    넣기

    5. systemctl restart named




p16_httpd.txt
    문제 내용 :
    firefox 브라우저에 www.ghdwpaks.com 을 입력했을때
    또는, 자신의 아이피를 입력했을때

    ghd 홈 디렉토리 내부에 있는 index.html 화면을
    출력하도록 설정하기


    문제 해결 :
    vi /etc/httpd/conf/httpd.conf
    로 열고
    160번 행 즈음에 있는

    <IfModule dir_module>
        DirectoryIndex index.html
    </IfModule>
    을
    <IfModule dir_module>
        DirectoryIndex /home/ghd/index.html
    </IfModule>
    으로 바꾼다.

    systemctl restart httpd 를 입력해서 데몬을 재시작해준다.









    다른 방식의 문제 해결 :

    vi /etc/httpd/conf/httpd.conf
    로 열고

    119행 쯤에 있는
        DocumentRoot "/var/www/html"
        을
        DocumentRoot "/home/ghd"
        으로 바꿔준다.

    124행쪽에 있는
        <Directory "/var/www">
            AllowOverride None
            # Allow open access:
            Require all granted
        </Directory>
        을
        <Directory "/home">
            AllowOverride None
            # Allow open access:
            Require all granted
        </Directory>
        으로 바꿔준다.

    131 행 쪽에 있는
        # Further relax access to the default document root:
        <Directory "/var/www/html">
        을
        # Further relax access to the default document root:
        <Directory "/home/itbank">
        로 바꿔준다.

    vi 를 나간다
    기본적으로 HTTP(d)서비스를 실행하고, 관제하는 계정은 apache 계정이기 때문에
    권한설정을 시작한다.

    파일의 소유 및 사용자도 아니고, 같은 그룹도 아니니
    '남'의 영역을 개방시켜줘야한다.

    chmod 701 /home/ghd/index.html
    -rwx-----x 로 바꿔 주는 이유는 보안상 707로 만들어버리면 apache 이외의 다른 유저들 또한 수정하고, 읽고, 실행시킬 수 있기 때문에 그저 '실행'의 권한 말 줄 수 있도록 701로 설정해줬다.

    systemctl restart httpd
    로 데몬을 다시 시작해준다.



p17_httpd.txt
    아파치 서버 설정

    1.
    user    : main
    skel    : /ghd/
    자동생성 디렉터리   : public_html/
    DocumentRoot       : ~main/public_html/

    www.2bwithu.co.kr   : 화면 내용 main

    2.
    www.2bwithu.co.kr/test1   : 화면 내용 test1

    3.
    www.2bwithu.co.kr/test1/test2   : 화면 내용 test2

    4.
    www.2bwithu.co.kr/~user1   : user1 홈 디렉터리 내부 index.html

    5.
    www.2bwithu.co.kr/user2/   : user2 홈 디렉터리 내부 index.html


    1~5 까지의 문제는 순서대로 진행
    2,3번 문제는 httpd.conf 설정 파일 사용 안하기.(FQDN 을 DocumentRoot 로 바꿔서 보는것을 권장)
    4,5번 문제는 httpd.conf 설정 파일의 마지막 줄 참조(파일 4개 중 하나는 4번, 하나는 5번과 관련됨.)


    문제 해결 :
    큰 맥락은 다음과 같습니다.

    1. DNS 설정
        1-0. yum , named.conf 설정
        1-1. /etc/named.rfc1912.zones 설정에서 zone 추가
        1-2. 추가해준 zone 영역에 대한 파일 생성 및 내용 추가
        1-3. 파일들  권한 설정
        + resolv.conf 파일 내용 확인 및 데몬 재시작
    2. HTTP 설정
        2-0. yum

    시작하겠습...다.

    yum -y install bind-* httpd-*
    로 named 서비스와 httpd 서비스에 관련한 패키지 다운로드

    vi /etc/named.rfc1912.zones
    열어서

    options { 아래에
    listen-on port 53 { any; };
    allow-query     { any; };
    으로 바꾸기

    vi /etc/named.rfc1912.zones
    열고, 파일 말단에


    zone "2bwithu.co.kr" IN {
            type master;
            file "2b.zone";
            allow-update {any;};
            allow-transfer {any;};
    };

    zone "127.168.192.in-addr.arpa" IN {
            type master;
            file "2b.rev";
            allow-update {any;};
            allow-transfer {any;};
    };

    추가하기

    cd /var/named
    로 이동
    cp named.localhost 2b.zone
    cp named.localhost 2b.rev

    로 zone들에 적어놨던 파일 생성

    아래의 출력문은 잘 나와야한다.
    [root@server named]# ll 2b*
    -rw-r--r-- 1 root root 152 12월 29 05:20 2b.rev
    -rw-r----- 1 root root 152 12월 29 05:21 2b.zone
    [root@server named]#

    vi 2b.zone
    으로 파일 열고

    $TTL 1D
    @       IN SOA  2bwithu.co.kr.          root(
                                            0       ; serial
                                            1D      ; refresh
                                            1H      ; retry
                                            1W      ; expire
                                            3H )    ; minimum
            IN      NS      2bwithu.co.kr.
            IN      A       192.168.127.128

    www     IN      A       192.168.127.128
    이런식으로 내용을 바꾼다.
    (*출력문은 다음과 같다.
    [root@server named]#cat 2b.zone
    $TTL 1D
    @       IN SOA  2bwithu.co.kr.          root(
                                            0       ; serial
                                            1D      ; refresh
                                            1H      ; retry
                                            1W      ; expire
                                            3H )    ; minimum
            IN      NS      2bwithu.co.kr.
            IN      A       192.168.127.128

    www     IN      A       192.168.127.128
    [root@server named]#
    )

    vi 2b.rev
    으로 파일 열고

    $TTL 1D
    @       IN SOA  2bwithu.co.kr.          root(
                                            0       ; serial
                                            1D      ; refresh
                                            1H      ; retry
                                            1W      ; expire
                                            3H )    ; minimum
            IN      NS      2bwithu.co.kr.
            IN      A       192.168.127.128

    128     IN      PTR     www.2bwithu.co.kr.
    (* 출력문은 다음과 같다.
    [root@server named]# cat 2b.rev
    $TTL 1D
    @       IN SOA  2bwithu.co.kr.          root(
                                            0       ; serial
                                            1D      ; refresh
                                            1H      ; retry
                                            1W      ; expire
                                            3H )    ; minimum
            IN      NS      2bwithu.co.kr.
            IN      A       192.168.127.128

    128     IN      PTR     www.2bwithu.co.kr.
    [root@server named]# 
    )

    으로 내용을 바꾼다.

    chmod 660 2b*
    chown .named 2b*
    으로 소유자와 권한을 바꾼다.

    systemctl restart named
    로 데몬을 재실행함과 동시에 정상작동 여부 확인

    vi /etc/resolv.conf
    로 열어서

    # Generated by NetworkManager
    nameserver 192.168.127.128
    nameserver 192.168.127.2
    첫번째 도메인(FQDN)검색 대상을 '나'로 지정

    nslookup 을 친 다음
    www.2bwithu.co.kr 와
    192.168.127.128 을 입력해서 정상 작동 여부 확인 











    2.HTTP

    skel 작업 시작.
    mkdir /ghd
    cp -r /etc/skel /ghd
    mkdir /ghd/public_html


    유저 설정 작업 시작.
    useradd -mk /ghd user1
    useradd -mk /ghd user2
    useradd -mk /ghd main

    공동 '실행'을 위해서 main 의 홈디렉터리는 701로 권한재설정
    chmod 701 ~main

    echo "main's home" >> ~main/public_html/index.html


    vi /etc/httpd/conf/httpd.conf
    로 httpd 설정 파일 열고

    119번행 즈음에 있는
    DocumentRoot "/var/www/html"
    을
    DocumentRoot "/home/main/public_html"
    로 바꾸기

    밑에있는 옵션도 바꾸기

    # Relax access to content within /var/www.
    #
    <Directory "/var/www">
        AllowOverride None
        # Allow open access:
        Require all granted
    </Directory>
    에서

    <Directory "/var/www">
    를
    <Directory "/home/main">
    으로 바꾸기

    그 밑에 있는
    # Further relax access to the default document root:
    <Directory "/var/www/html">
    도
    # Further relax access to the default document root:
    <Directory "/home/main/public_html">
    으로 바꾸기

    저장하고 나온다.





    cd ~main/public_html
    로 이동

    mkdir test1
    echo "directory test1" >> test1/index.html
    로 index 파일 생성

    mkdir /home/main/public_html/test1/test2
    디렉터리 생성
    echo "directory test2" >> ./test1/test2/index.html
    index.html 생성





    tail -1 /etc/httpd/conf/httpd.conf
    라고 입력해서 우리가 찾아봐야하는 유틸리티 파일의 경로가 어디인지 출력하기

    IncludeOptional conf.d/*.conf
    라고 출력되면, 실질적인 경로가
    /etc/httpd/conf.d
    가 되므로

    cd /etc/httpd/conf.d
    로 이동

    일단 user1 이랑 user2의 홈 디렉터리를 'apache 가 사용할 수 있도록' 권한을 설정해줌

    chmod 701 ~user1
    echo "user1's home" >> ~user1/public_html/index.html
    으로 홈 디렉터리에 index.html 넣고

    vi /etc/httpd/conf.d/userdir.conf

    "UserDir disabled"
    를 주석처리하고, 다음줄인
    #UserDir public_html
    의 주석처리를 풀라는 내용입니다.
    아래는 이 파일의 수정 후 전체 내용입니다.
    [root@server conf.d]# cat /etc/httpd/conf.d/userdir.conf
    #
    # UserDir: The name of the directory that is appended onto a user's home
    # directory if a ~user request is received.
    #
    # The path to the end user account 'public_html' directory must be
    # accessible to the webserver userid.  This usually means that ~userid
    # must have permissions of 711, ~userid/public_html must have permissions
    # of 755, and documents contained therein must be world-readable.
    # Otherwise, the client will only receive a "403 Forbidden" message.
    #
    <IfModule mod_userdir.c>
        #
        # UserDir is disabled by default since it can confirm the presence
        # of a username on the system (depending on home directory
        # permissions).
        #
        #UserDir disabled

        #
        # To enable requests to /~user/ to serve the user's public_html
        # directory, remove the "UserDir disabled" line above, and uncomment
        # the following line instead:
        #
        UserDir public_html
    </IfModule>

    #
    # Control access to UserDir directories.  The following is an example
    # for a site where these directories are restricted to read-only.
    #
    <Directory "/home/*/public_html">
        AllowOverride FileInfo AuthConfig Limit Indexes
        Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec
        Require method GET POST OPTIONS
    </Directory>

    [root@server conf.d]#


    systemctl restart httpd
    로 httpd 데몬 재실행

    chmod 701 ~user2
    echo "user2's home d" >> ~user2/public_html/index.html

    vi autoindex.conf
    열고

    Alias /icons/ "/usr/share/httpd/icons/"

    <Directory "/usr/share/httpd/icons">
        Options Indexes MultiViews FollowSymlinks
        AllowOverride None
        Require all granted
    </Directory>

    여기 문단 찾아서, 밑에

    Alias /user2/ "/home/user2/public_html/"

    <Directory "/home/user2/public_html">
        Options Indexes MultiViews FollowSymlinks
        AllowOverride None
        Require all granted
    </Directory>

    이렇게 추가하기


p18_mariadb.txt

    1. root 로 접속해서 진행
    DataBase    : dbtest
    user        : usertest

    2. usertest 로 접속해서 진행
    table   : tbtest
    field   : num, name, addr, phone
    values  : 3개 이상


    문제 해결 :
    0. mysql , mariadb 설치 및 데몬 재실행
    1. DB 생성 및 유저 생성
    2. table 및 field 생성
    3. table 에 column 값 넣기


    0. mysql , mariadb 설치 및 데몬 재실행

        yum -y install mariadb-*
        로 설치하고, 완료되면

        systemctl restart mariadb
        입력해서 데몬 재실행

    1. DB 생성 및 유저 생성 
        mysql -u root -p mysql
        mysql 접속하는데, 사용할 유저가 root 이고, 사용할 DB 는 mysql 이라는 뜻

        create database dbtest;
        우리가 쓸 DB 만들어주고

        insert into user(host,user,password) values ('localhost','usertest',password('ghdwpaks'));
        localhost 가 호스트고
        usertest 가 이름이고
        ghdwpaks 이 비밀번호인 계정을 생성하기

        insert into db values ('localhost','dbtest','usertest','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y');
        'y' 의 갯수는 19개이며 각 명령어 사용 가능 여부에 관한 '사용가능'처리를 하기 위해 넣은 내용이다.
        localhost 는 접속자 호스트를 뜻하고
        dbtest 는 권한을 적용받을 DB 를 뜻하고
        usertest 는 권한을 적용받을 유저의 이름을 뜻한다.

        exit
        로 '앞서 생성한 usertest 를 사용하기 위해' 나온다.

    2. table 및 field 생성
        systemctl restart mariadb

        mysql -u usertest -p dbtest;
        usertest 계정으로 dbtest 에 접속한다는 내용이다.

        ghdwpaks
        으로 아까 설정해줬던 비밀번호를 넣어준다

        create table tbtest (num int(3), name char(20), addr char(80), phone int(14));

        이렇게 table 과 field 까지 생성하는게 끝났다.

    3. table 에 column 값 넣기
        
        명령어의 구성은 다음과 같다.
        insert into tbtest values ([숫자],'[단어]','[단어]','[예의상 전번]'){,([숫자],'[단어]','[단어]','[예의상 전번]')}
        숫자는 3자리숫자 이내의 숫자를 뜻하고,
        단어는 각각 20자리와 80 자리를 넘기지 않도록 하고
        예의상 전번이라는것은 123같은 일반적인 숫자여도 상관 없으나 그저 예의상 010-1234-5678 같이 14자리 안의 숫자를 넣어주는것을 뜻한다.
        
        예를 들면
        insert into tbtest values (1,'ghdwp','non-hyon','010-1234-5678');
        같이 입력할수도 있고,
        insert into tbtest values (1,'ghdwp','non-hyon','010-1234-5678'),(2,'ghdwpaks','gang-nam','010-3412-6587'),(3,'홍제','서울','010-3412-6587');
        같이 입력할 수도 있다.

    + 결과값 이해와 문제해결
        select * from tbtest;
        을 입력해서 우리가 넣은 값들을 출력해보면 다음과 같이 나올 가능성이 크다.
        
        +------+----------+----------+-------+
        | num  | name     | addr     | phone |
        +------+----------+----------+-------+
        |    1 | ghdwp    | non-hyon |    10 |
        |    2 | ghdwpaks | gang-nam |    10 |
        |    3 | ??       | ??       |    10 |
        +------+----------+----------+-------+
        3 rows in set (0.00 sec)

        우선 phone 필드부터 보자면 10으로 들어가있는것을 볼 수 있다.
        이는 010-1234-5678 이라는 값을 예시로 들자면
        010-1234-5678 에서 마이너스 표시는 인식하지 못하기 때문에 010 만 인식한다.
        그리고 정수 표기법상 0 이 앞에 올 수 없기 때문에 10 만이 표현되는것이다.

        그리고 3번째 컬럼의
        name 과 addr 필드에 넣었던 한글 데이터가 전부 깨진것을 볼 수 있다.

        
        이제부터 문제를 고쳐주기 시작할텐데, 우선 전번은 문자형으로 바꿔준다.

        alter table tbtest modify phone char(14);

        update tbtest set phone='010-1111-1111' where num=1;


        이제 한글 증상을 고치기 위해서
        exit
        를 해서, 다시

        mysql -u root -p mysql
        로 다시 들어와준다.

        show variables like 'c%';
        를 입력했을때 아래와 같이 나올 가능성이 큰데,

        MariaDB [mysql]> show variables like 'c%';
        +--------------------------+----------------------------+
        | Variable_name            | Value                      |
        +--------------------------+----------------------------+
        | character_set_client     | utf8                       |
        | character_set_connection | utf8                       |
        | character_set_database   | latin1                     |
        | character_set_filesystem | binary                     |
        | character_set_results    | utf8                       |
        | character_set_server     | latin1                     |
        | character_set_system     | utf8                       |
        | character_sets_dir       | /usr/share/mysql/charsets/ |
        | collation_connection     | utf8_general_ci            |
        | collation_database       | latin1_swedish_ci          |
        | collation_server         | latin1_swedish_ci          |
        | completion_type          | NO_CHAIN                   |
        | concurrent_insert        | AUTO                       |
        | connect_timeout          | 10                         |
        +--------------------------+----------------------------+
        14 rows in set (0.00 sec)

        MariaDB [mysql]>
        이중에서 주목해야할것은
        character_set_database   | latin1   
        character_set_server     | latin1 
        collation_database       | latin1_swedish_ci
        collation_server         | latin1_swedish_ci
        시스템의 핵심이 라틴어 인코더 형식이 적용되어있는것들이다.

        이제부터 이러한 인코딩 형식들을 전부 utf-8로 바꿔줄것이다.

        exit
        를 입력해서 DB 를 나오고

        vi /etc/my.cnf
        로 파일을 들어간다.
        (파일 내용 예시 :
        [root@server ~]# cat /etc/my.cnf
        [mysqld]
        datadir=/var/lib/mysql
        socket=/var/lib/mysql/mysql.sock
        # Disabling symbolic-links is recommended to prevent assorted security risks
        symbolic-links=0
        # Settings user and group are ignored when systemd is used.
        # If you need to run mysqld under a different user or group,
        # customize your systemd unit file for mariadb according to the
        # instructions in http://fedoraproject.org/wiki/Systemd

        [mysqld_safe]
        log-error=/var/log/mariadb/mariadb.log
        pid-file=/var/run/mariadb/mariadb.pid

        #
        # include all files from the config directory
        #
        !includedir /etc/my.cnf.d

        [root@server ~]#
        )
        # instructions 주석 아래에
        character-set-server = utf8
        collation-server = utf8_general_ci
        이라는 내용을 넣고, vi 를 종료한다.

        (*파일 결과물
        [root@server ~]# cat /etc/my.cnf
        [mysqld]
        datadir=/var/lib/mysql
        socket=/var/lib/mysql/mysql.sock
        # Disabling symbolic-links is recommended to prevent assorted security risks
        symbolic-links=0
        # Settings user and group are ignored when systemd is used.
        # If you need to run mysqld under a different user or group,
        # customize your systemd unit file for mariadb according to the
        # instructions in http://fedoraproject.org/wiki/Systemd
        character-set-server = utf8
        collation-server = utf8_general_ci

        [mysqld_safe]
        log-error=/var/log/mariadb/mariadb.log
        pid-file=/var/run/mariadb/mariadb.pid

        #
        # include all files from the config directory
        #
        !includedir /etc/my.cnf.d

        [root@server ~]#
        )
        그리고 데몬을 재시작해준다.

        systemctl restart mariadb

        그리고 다시 mysql 을 들어가서
        mysql -u root -p mysql

        show variables like 'c%';
        이라고 입력해줬을때

        MariaDB [mysql]> show variables like 'c%';
        +--------------------------+----------------------------+
        | Variable_name            | Value                      |
        +--------------------------+----------------------------+
        | character_set_client     | utf8                       |
        | character_set_connection | utf8                       |
        | character_set_database   | utf8                       |
        | character_set_filesystem | binary                     |
        | character_set_results    | utf8                       |
        | character_set_server     | utf8                       |
        | character_set_system     | utf8                       |
        | character_sets_dir       | /usr/share/mysql/charsets/ |
        | collation_connection     | utf8_general_ci            |
        | collation_database       | utf8_general_ci            |
        | collation_server         | utf8_general_ci            |
        | completion_type          | NO_CHAIN                   |
        | concurrent_insert        | AUTO                       |
        | connect_timeout          | 10                         |
        +--------------------------+----------------------------+
        14 rows in set (0.00 sec)

        MariaDB [mysql]>
        이 출력문중에서
        character_set_client     | utf8
        character_set_connection | utf8
        character_set_database   | utf8
        character_set_results    | utf8
        character_set_server     | utf8
        character_set_system     | utf8
        collation_connection     | utf8_general_ci
        collation_database       | utf8_general_ci
        collation_server         | utf8_general_ci
        이렇게 'latin1' 없이 utf8 만 가득하다면 성공적으로 한글을 넣을 수 있는 상태가 된다.

        근데 여기서 끝나지 않고, 실질적으로
        exit 한다음
        mysql -u usertest -p dbtest
        로 우리가 적용시켜야할 dbtest 라는 이름의 db 에 들어가본다음
        status;
        를 입력해서 상태를 살펴봤을때

        MariaDB [dbtest]> status;
        --------------
        mysql  Ver 15.1 Distrib 5.5.68-MariaDB, for Linux (x86_64) using readline 5.1

        Connection id:          3
        Current database:       dbtest
        Current user:           usertest@localhost
        SSL:                    Not in use
        Current pager:          stdout
        Using outfile:          ''
        Using delimiter:        ;
        Server:                 MariaDB
        Server version:         5.5.68-MariaDB MariaDB Server
        Protocol version:       10
        Connection:             Localhost via UNIX socket
        Server characterset:    utf8
        Db     characterset:    latin1
        Client characterset:    utf8
        Conn.  characterset:    utf8
        UNIX socket:            /var/lib/mysql/mysql.sock
        Uptime:                 8 min 14 sec

        Threads: 1  Questions: 41  Slow queries: 0  Opens: 16  Flush tables: 2  Open tables: 42  Queries per second avg: 0.082
        --------------

        MariaDB [dbtest]>

        이중에서

        Db     characterset:    latin1
        이 부분처럼, Db 의 characterset (언어 인코딩 설정) 이 아직도 'latin1'인것을 볼 수 있다.

        alter database dbtest default character set utf8;
        입력해주고

        commit;
        커밋해준다.

        그리고 다시
        status;
        로 확인해보면

        
        MariaDB [dbtest]> status
        --------------
        mysql  Ver 15.1 Distrib 5.5.68-MariaDB, for Linux (x86_64) using readline 5.1

        Connection id:          3
        Current database:       dbtest
        Current user:           usertest@localhost
        SSL:                    Not in use
        Current pager:          stdout
        Using outfile:          ''
        Using delimiter:        ;
        Server:                 MariaDB
        Server version:         5.5.68-MariaDB MariaDB Server
        Protocol version:       10
        Connection:             Localhost via UNIX socket
        Server characterset:    utf8
        Db     characterset:    utf8
        Client characterset:    utf8
        Conn.  characterset:    utf8
        UNIX socket:            /var/lib/mysql/mysql.sock
        Uptime:                 13 min 32 sec

        Threads: 1  Questions: 50  Slow queries: 0  Opens: 16  Flush tables: 2  Open tables: 42  Queries per second avg: 0.061
        --------------

        MariaDB [dbtest]>

        이 출력문들중에서
        Db     characterset:    utf8
        를 보면, DB 의 characterset 이 utf8 로 바뀌어져있는것을 알 수 있다.

        근데 이 변경점들은 이 수정과정을 거친 이후부터 만들어지는 테이블들에 적용될 내용이고,
        이미 만들어진 테이블에서는 적용되지 않는 부분들이니
        만약에 이미 만들어진 테이블에서도 적용시키고싶다면 다음 과정을 추가적으로 거쳐야한다.

        alter table tbtest modify name char(20)char set utf8;
        alter table tbtest modify phone char(14)char set utf8;

        alter table [테이블 이름] modify [필드 이름] [자료형]([필드 크기]) [자료형] set utf8;

        그리고 다시
        update tbtest set name='테스트' where num=3;
        라고 한글을 입력해준다음에

        select * from tbtest;
        로 출력해주면

        MariaDB [dbtest]> select * from tbtest;
        +------+-----------+------+---------------+
        | num  | name      | age  | phone         |
        +------+-----------+------+---------------+
        |    1 | ghdwp     |   11 | 010-1111-1111 |
        |    2 | ghdwpaks  | NULL | 10            |
        |    3 | 테스트    | NULL | 10            |
        +------+-----------+------+---------------+
        3 rows in set (0.01 sec)

        MariaDB [dbtest]>
        정상적으로 한글이 들어가있는것을 확인할 수 있다.
        

        그리고 하나의 예시로써, 나이를 나타내기 위해 old 라는 field 를 추가하고싶다면
        alter table tbtest add old int(3) after name;
        
        이렇게 추가하고,

        필드의 이름을 바꾸고싶다면 이렇게 바꾸면 된다.
        alter table tbtest change old age int(3);
        old 라는 필드를 age 라는 이름으로 바꾼다는 내용이다.

        alter table tbtest drop addr;
        addr 이라는 field 는 쓸곳이 딱히 없어보이니, 삭제하도록 한다.


p19_mariadb.txt
    1. mysql 안에서 userghd 라는 유저를 만들어서 dbghd 대상으로 모든 권한 부여. 이후 userghd 접속해서 권한 확인

    2. 도메인 설정
    생성자 계정     : main
    자동생성디렉터리: public_html (DocumentRoot 로 사용)
    도메인          : www.lingus.com
    화면내용        : MAIN


    문제 해결:
    0. 패키지 다운로드
    1. 유저 생성 및 권한 부여
    2. 권한 확인
    4. 도메인 설정
    5. main 유저 생성 및 자동생성디렉터리 설정


    0. 패키지 다운로드
        yum -y install bind-* httpd-* mariadb-*
        systemctl restart mariadb
        systemctl restart named
        systemctl restart httpd


    1. 유저 생성 및 권한 부여
        mysql -u root -p mysql

        update user set password=password('ghdwpaks') where user='root';
        로 user 테이블 안에 있던 root 이름의 모든 사용자의 비밀번호를 ghdwpaks 으로 바꿔주고
        
        delete from user where user=' ';
        delete from db where user=' ';
        위험한 익명 사용자 없애주고

        insert into user(host,user,password) values ('localhost','userghd',password('ghdwpaks'));
        로 유저 추가해주고

        insert into db values ('localhost','dbghd','userghd','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y','y');
        로 유저 권한 추가해주고


        확인하기 전에,
        create database dbghd;
        이 모든 권한이 적용될 db 를 생성해주기
        
        exit
        나가기.

        systemctl restart mariadb
        데몬 재실행

    2. 권한 확인
        mysql -u userghd -p dbghd
        입력한 후

        ghdwpaks
        입력해서 비밀번호 치고
        접속 확인하기

        show tables;
        권한 확인하고

        exit
        나가기

    4. 도메인 설정
        vi /etc/named.conf
        열어서

        listen-on port 53 { any; };
        allow-query     { any; };
        변경해주고 닫기.


        vi /etc/named.rfc1912.zones
        열어서, 파일 말단에
        
        zone "lingus.com" IN {
                type master;
                file "lingus.zone";
                allow-update {any;};
                allow-transfer {any;};
        };

        zone "127.168.192.in-addr.arpa" IN {
                type master;
                file "lingus.rev";
                allow-update {any;};
                allow-transfer {any;};
        };
        입력해주고 닫기.

        cd /var/named
        디렉터리 들어가고

        cp named.localhost lingus.zone
        복사해서

        [root@server named]# cat lingus.zone
        $TTL 1D
        @       IN SOA  lingus.com.             root(
                                                0       ; serial
                                                1D      ; refresh
                                                1H      ; retry
                                                1W      ; expire
                                                3H )    ; minimum
                IN      NS      lingus.com.
                IN      A       192.168.127.128

        www     IN      A       192.168.127.128
        [root@server named]#

        이렇게 내용넣고

        cp lingus.zone lingus.rev
        복사해서
        
        
        [root@server named]# cat lingus.rev
        $TTL 1D
        @       IN SOA  lingus.com.             root(
                                                0       ; serial
                                                1D      ; refresh
                                                1H      ; retry
                                                1W      ; expire
                                                3H )    ; minimum
                IN      NS      lingus.com.
                IN      A       192.168.127.128

        128     IN      PTR     www.lingus.com.
        [root@server named]#
        이렇게 내용넣고 나오기

        chmod 660 lin*
        chown .named lin*
        데몬이 읽게 파일 권한 설정 해주고

        systemctl restart named
        (* 문제 생길시 여기 참조 https://hbesthee.tistory.com/1681)
        데몬 재실행 해주고

        vi /etc/resolv.conf
        파일 열어서
        
        [root@server named]# cat /etc/resolv.conf
        # Generated by NetworkManager
        nameserver 192.168.127.128
        nameserver 192.168.127.2
        [root@server named]#

        위와같이 '나'에게 제일 먼저 FQDN 을 물어보도록 설정하기

        ***위의 과정을 몇차례의 추가 문제 해결이 있었던 과정입니다.***


    5. main 유저 생성 및 자동생성디렉터리 설정
        mkdir /etc/skel/public_html
        public_html 이라는 디렉터리를 모든 일반유저의 뼈대 설정 안에 넣고

        useradd main
        main 추가하고

        chmod 701 ~main
        apache 가 쓸 수 있게 main 유저 홈 디렉터리 권한 설정

        echo "MAIN's home" >> ~main/public_html/index.html
        main 유저 홈 디렉터리 안에 public_html 디렉터리 안에 index 파일 만들기

        vi /etc/httpd/conf/httpd.conf 
        열어서
        DocumentRoot "/www/html"
        을
        DocumentRoot "/home/main/public_html"
        바꾼다.

        그 아래에
        <Directory "/var/www">
        을
        <Directory "/home/main">
        바꾸고

        
        # Further relax access to the default document root:
        <Directory "/www/html">
        을
        # Further relax access to the default document root:
        <Directory "/home/main/public_html">
        바꾸고
        
        나온다.

        systemctl restart httpd
        데몬 재시작해준다.

    + 확인
    리눅스 안에 있는 아무 브라우저 하나 열어서
    www.lingus.com
    url 쳐서 들어갔을때
    MAIN's home
    이라는 구문이 나오면 성공이다.

    lingus 는 ling us 가 아니라 lin gus 입니다
    리눅스 잘못치면 린구스 돼서 함 써봤습니다



p20_php_install.txt
    php 다운로드 및 적용

    https://www.phpmyadmin.net
    에 접속한 다음 상단 메뉴 바에 맨 오른쪽에 있을 Download 버튼을 눌러서 페이지를 이동해야합니다.

    그 아래에 
    Older Releases 라고 비교적 큰 폰트로 써져있는 문단에서 'You can find older releases on separate files page. You can also get them from our Git repository (check developer information for instructions). Older releases are unsupported.' 이라고 적혀있고, 'separate files page'라는 문단이 하이퍼링크로 걸려있을텐데, 그곳으로 들어가줍니다.

    Releases 라는 항목이 4.4.15.10 라고 되어있는 곳으로 가서 오른쪽에 있는 zip 파일 하이퍼링크를 타고 다운로드를 해줍니다.


    리눅스 환경에서는
    yum -y install vsftpd-*
    systemctl restart vsftpd
    firewall-cmd --permanent --add-service=ftp
    firewall-cmd --reload


    윈도우 CMD 환경에서
    (서버 아이피가 192.168.127.128 인경우)
    다운로드 해준 파일이 있는 디렉터리로 이동해서
    ftp 192.168.127.128
    ftp 에 접속해준다.


    main 으로 접속해주고
    cd public_html
    put phpMy*
    를 입력해서, 다운로드한 파일을 ftp 로 전송해주고

    quit
    나옵니다

    다시 리눅스로 돌아와서,
    cd ~main/public_html 
    이동하고

    unzip php*
    다운로드 받은 파일을 풀어주고

    mv phpmyadmin-4.4.15.10-all-languages db
    그 파일의 이름 db 로 바꿔준다


    vi /etc/httpd/conf/httpd.conf
    로 파일을 열어주고

    <IfModule dir_module>
        DirectoryIndex index.html
    </IfModule>
    처럼 되어있는 구문을

    <IfModule dir_module>
        DirectoryIndex index.html index.php
    </IfModule>
    바꿔주고 저장하고 나온다

    systemctl restart httpd
    그리고 시스템을 재시작해준다


    그리고 다시 www.lingus.com/db/ 같은 경로로 이동했을때 php 코드가 그대로 보일 수 있습니다.
    이 경우에는 리눅스 서버에서 php 언어에 대한 정보를 가지고있지 않아서 일어나는 일입니다.

    yum -y install php-* --skip-broken
    다운로드 해줍니다.

    --skip-broken
    옵션은 php 5와 db 버전의 충돌을 무시하기 위한 옵션입니다.

    systemctl restart httpd
    httpd 데몬 재실행















