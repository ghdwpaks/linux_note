alias
    -임의의 키워드에 명령어[에 옵션까지] 등록함
    -해당 키워드로 등록된 명령을 대체해서 사용함
    
    -형식
        alias                           : 등록된 내용 확인
        alias 키워드='명령어 [옵션]'    : 키워드 등록

    -예시
        alias
        alias p="pwd"
        alias p='pwd'
        alias lll = "ls -alR"
        

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


Authority and ownership
권한
    -파일/디렉토리를 사용할 수 있는지 여부를 정하는 개념
    -허가권과 소유권으로 구분
        > 허가권 + 소유권 = 권한

허가권
    - ls -l 명령을 입력했을 때 나오는 내용 중 개체 형식을 나타내는 첫 글자 뒤에 오는 9개의 글자가 허가권이다.
    (예시 :
        [root@localhost home]# ls -l
        합계 0
        drwx------. 7 itbank itbank 191  9월 26 23:31 itbank
        drwxr-xr-x. 3 root   root    67  9월 26 23:02 test
        drwx------. 3 user1  user1   78  9월 29 19:38 user1
        drwx------. 3 user2  user2   78  9월 29 19:38 user2

        여기서
        drwx------.
        drwxr-xr-x.
        drwx------.
        drwx------.
        이 부분들이 권한을 나타내는 부분이다.
    )

    -8가지 문자로 권한을 표현 : r, w, x, -, s, S, t, T
    
        r : 일기 권한 (*디렉토리일 경우 - 디렉토리 내부 목록 확인 가능)
        w : 쓰기 권한 (*디렉토리일 경우 - 디렉토리 내부 목록 수정 가능)
        x : 실행 권한 (*디렉토리일 경우 - 디렉토리에 x가 없으면 디렉토리 자체 및 내부의 항목들을 사용할 수 없다.)
        - : 권한 없음

    -9자리의 권한 문자를 3개씩 끊어서 Owner, Group, Other 영역으로 구분
        Owner : 소유자를 위한 권한(소유자 : 파일/디렉터리를 소유 중인 사용자)
        Group : 그룹 사용자를 위한 권한(그룹 사용자 : 파일/디렉토리를 소유 중인 그룹에 소속된 사용자)
        Other : 그 외 사용자를 위한 권한(그 외 사용자 : Owner, Group 둘 다 해당되지 않는 사용자)

        * 3개의 영역 중 어느 영역의 권한을 적용 받는지에 대한 내용은 소유권에서 결정    

        예시 :
            
            Owner   |   Group   |   Other
            r  w  x  r   -    x   r   -   x


            drwxr-xr-x.
            d : 디렉터리
            r : 생성자(주인) 읽기 가능
            w : 생성자(주인) 수정 가능
            x : 생성자(주인) 사용 가능
            r : 같은 그룹 인원 읽기 가능
            - : 같은 그룹 인원 수정 불가
            x : 같은 그룹 인원 사용 가능
            r : 외부인(제3자) 일기 가능
            - : 외부인(제3자) 수정 불가
            x : 외부인(제3자) 사용 가능
    

            drwx------.
            d : 디렉터리
            r : 생성자(주인) 읽기 가능
            w : 생성자(주인) 수정 가능
            x : 생성자(주인) 사용 가능
            - : 같은 그룹 인원 읽기 불가
            - : 같은 그룹 인원 수정 불가
            - : 같은 그룹 인원 사용 불가
            - : 외부인(제3자) 일기 불가
            - : 외부인(제3자) 수정 불가
            - : 외부인(제3자) 사용 불가

    
    -권한 표현 방법
        1. 문자를 이용한 방법 : r, w, x, -  문자(= 권한 문자)를 차례대로 읽어주는 방법

        2. 숫자를 이용한 방법 : 문자를 바탕으로 숫자 값을 계산
            * 계산 방법
                1) 영역 분리
                2) r = 4, w = 2, x = 1, - = 0 을 각 영역의 문자에 대입 후 영역별로 합 계산
                3) 각 영역에서 구한 합에 Owner는 100, Group은 10, Other는 1을 곱해서 전체 합을 계산
                
                예시:
                    1. rwx-xr-X     >> 755

                        Owner   |   Group   |   Other
                      r   w   x    r  -  x     r  -  x
                      4   2   1    4  0  1     4  0  1
                          7           5           5
                        x100        x10          x1
                        700     +   50      +     5

                    2. rw-r--r--
                        
                        Owner   |   Group   |   Other
                      r   w   0    r  -  -     r  -  -
                      4   2   0    4  0  0     4  0  0
                          7           4           4
                        x100        x10          x1
                        700     +   40      +     4

                    
                    3. -wxrwxr-x
                        
                        Owner   |   Group   |   Other
                      -   w   x    r  w  x     r  -  x
                      0   2   1    4  2  1     4  0  1
                          3           4           4
                        x100        x10          x1
                        700     +   40      +     4

    -허가권 변경
        chmod [옵션] 권한값 대상 [대상] ... [대상]
        
        *권한값을 숫자/문자로 입력
            숫자로 입력하면 numeric method
            문자로 입력하면 symbolic method
                > symbolic method에서 사용하는 영역 문자
                    u : owner
                    g : group
                    o : other
            
        예시 :
        chomd o+wx hello.txt
        (*hello.txt 파일의 o(other)권한의 w 와 x 추가)

        chmod o-r hello.txt
        (*hello.txt 파일의 o(other)권한의 r 제거)

        chmod o+wx , o-r hello.txt
        (*hello.txt 파일의 o(other)권한의 w 와 x 추가를 하고 r권한을 제거한다.)

        chmod 623 hello.txt
        (*hello.txt 파일의 권한을 u = rw- , g = -w- , o = -wx 으로 설정한다.)

소유권
    - 파일/디렉토리를 어느 사용자와 그룹이 소유하고 있는지 나타내는 권한
        > ls -l 명령으로 출력되는 정보 중 링크 개수 뒤에 나오는 사용자명과 그룹명이 소유권
        (*
        -rw-r--r-- 1 itbank itbank  6205496 10월  6 20:03 vim-common-7.4.629-7.el7.x86_64.rpm
        -rw-r--r-- 1 itbank itbank  1105904 10월  6 20:03 vim-enhanced-7.4.629-7.el7.x86_64.rpm
        -rw-r--r-- 1 itbank itbank    11144 10월  6 20:03 vim-filesystem-7.4.629-7.el7.x86_64.rpm
        -rw-r--r-- 1 itbank itbank   453600 10월  6 19:18 vim-minimal-7.4.629-7.el7.x86_64.rpm

        이러한 경우에는 사용자명과 그룹명이 itbank(사용자명)와 itbank(그룹명)으로 동일하다
        )

    - 소유권을 두 개의 영역으로 구분
        > 앞에 나오는 정보가 계정명(UID), 파일/디렉토리를 소유하고 있는 사용자 뒤에 나오는 정보가 그룹명(GID), 파일/디렉토리를 소유하고 있는 그룹
        (*
        -rw-r--r-- 1 itbank itbank  6205496 10월  6 20:03 vim-common-7.4.629-7.el7.x86_64.rpm
        itbank      itbank
        (사용자명)  (그룹명)    )


    - 소유권 변경
        chown [옵션] 권한값 대상 [대상] ... [대상]

        *권한값 작성 방식( : 기호 대신에 . 기호 사용 가능)
        UID	> 소유권의 UID 지정
        UID:GID	> 소유권의 UID, GID 지정
        UID:	> 소유권의 UID, GID를 특정 사용자의 UID, GID로 변경
        :GID	> 소유권의 GID 영역 변경

        (*
        chown itbank:itbank hello.txt
        소유권의 UID와 GID를 itbank와 itbank로 지정한다.
        -rw-r--r-- 1 itbank itbank       12 10월  7 03:02 hello.txt

        chown root hello.txt
        소유권의 UID와 root로 지정한다.
        -rw-r--r-- 1 root itbank       12 10월  7 03:02 hello.txt
        
        
        chown :root hello.txt
        소유권의 GID와 itbank로 지정한다.
        -rw-r--r-- 1 root root       12 10월  7 03:02 hello.txt


        (*
        실행전
        drwxr-xr-x 2 root   root         52 10월  7 03:36 test
        -rw-r--r--  1 root   root     33 10월  7 03:35 hello_test1.txt
        -rw-r--r--  1 root   root     12 10월  7 03:36 hello_test2.txt
        )
        
        chown -R itbank:itbank ./test
        test디렉토리의 안에 들어있는 내용물과 그 하위 디렉토리 전부 소유권을 변경한다.  

        (*
        실행후
        drwxr-xr-x 2 itbank itbank       52 10월  7 03:36 test
        -rw-r--r--  1 root   root     33 10월  7 03:35 hello_test1.txt
        -rw-r--r--  1 root   root     12 10월  7 03:36 hello_test2.txt
        )

        )

    허가권과 소유권이 적용되는 방식(중요!!!)
    1. 작업 주체와 작업 대상의 UID, GID 확인
        > 작업 주체 : 작업을 수행하는(= 명령을 입력하는) 사용자	>> 사용자 정보 중 UID, GID(/etc/passwd 파일, id 명령)
        작업 대상 : 작업(= 명령)의 대상이 되는 파일/디렉토리	>> 소유권 UID, GID(ls 명령어 -l 옵션이나 -n 옵션)

    2. 작업 주체와 작업 대상의 UID, GID 비교
        1) UID 비교 >> UID가 일치하면 owner 영역 권한 적용, 일치하지 않으면 GID 비교
        2) GID 비교 >> GID가 일치하면 group 영역 권한 적용, 일치하지 않으면 other 영역 권한 적용




---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

cal
    -형식
    cal             :운영체제 설졍된 날짜와 시간을 기준으로 현재 월의 달력을 출력
    cal 숫자1       :숫자를 년도로 사용하여 해당 년도의 전체 달력을 출력
    cal 숫자1 숫자2 :숫자2를 년도로 숫자1을 월로 사용하여 해당 년월의 달력을 출력

    -입력예시
    cal
    cal 1
    cal 1 2



    
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



cat
    -사용 형식
        cat         : 입력한 내용을 출력(정규 표현식 or shell script 에서 많이 사용함.)
        cat 파일명  : 파일의 내용을 출력함.
        cat > 파일명: 입력한 파일명의 이름으로 파일을 생성하며, 생성함과 동시에 사용자를 간단하게 입력할 수 있게 해줌(vi에디터가 아님.) 다만 이미 파일명이 현재 디렉토리에 있을때는 덮어씌운다. 경고문은 뜨지 않는다.

    -예시
    cat
    cat hello.txt
    cat > hello.txt



    
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------




cp
    - copy , 복사 + 붙혀넣기를 한번에 함
    - 기본적으로 파일만 복사가 가능
        > 디렉토리의 복사는 별도의 옵션이 필요함
    - 원본 파일과 같은 이름으로 or 원본 파일과 다른 이름으로 복사 가능
        > 이름을 바꿔서 복사할 때는 원본을 하나만 입력(1:1 복사만 가능)
    - 형식
        cp [옵션] 원본 [원본] ... [원본] 복사할위치[+이름]
        (*이름을 원본과 같게 입력하거나 생략하면 원본과 같은 이름으로 복사하며 , 원본과 다른 이름을 입력하면 해당 이름으로 변경되어서 복사함)
    -예시
        cp ./hello.txt ./itbank/
        cp ./hello.txt ./itbank/hello.txt
        cp ./*.txt ./itbank/
        cp ./hello.txt ./hello2.txt ./itbank/
        



        
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


date
    - 날짜와 시간을 출력함
    
    date              : 현재 날짜와 시간 출력
    date mmddhhMMyyyy : yyyy년 mm월 dd일 hh시 MM분으로 날짜와 시간 변경함

    -예시
        date
        date 122507252021
        


        
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



기본 디렉토리
-시스템이 설치 되었을 떄 기본적으로 생성되어 있는 디렉토리
    > 개수가 굉장히 많지만 / 디렉토리 아래에 있는 항목들만 확인
-   /디렉토리는 Linux 시스템의 최상위 디렉토리 Linux를 구성하는 모든 파일과 디렉토리는 전부 / 아래에 있다.(Tree 트리 구조로 되어 있다)
-   / 아래에 있는 기본ㄴ 디렉토리들은 시스템 구성에 있어서 중요한 역할을 하고있다. (->기호는 바로가기(symbolic link를 의미 , symbolic link는 윈도우의 바로가기와 비슷하다.))

bin     : 모든 사용자가 사용할 수 있는 공용 명령어들이 들어있는 디렉토리
boot    : 부팅에 필요한 각종 파일들이 모여있는 디렉토리
dev     : 장치 파일이 생성되는 디렉토리
etc     : 
home    : 일반 사용자들의 홈 디렉토리가 생성되는 디렉토리 (*여기서 말하는 홈 디렉토리는 사용자 개인의 디렉토리를 말한다.)
lib     : 라이브러리가 모여있는 디렉터리
lib64   : 64bit 전용의 라이브러리가 모여있는 디렉토리
media   : remote device를 인식했을 떄 연결해주는 디렉토리
opt
root    : 관리자(root)의 홈 디렉토리
sbin    : 관리자만 할 수 있는 명령어(시스템 제어 명령어)들이 들어있는 디렉토리




---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



프로그램 설치 과정
    소스 파일 다운로드 -> compile -> 설정 및 파일 배치 -> 프로그램 실행 : tar + 압축
    패키지 파일 갖고 있는 상태 -> 명령어를 이용한 설치 -> 프로그램 실행  : rpm
    (Internet 연결) 명령어를 이용한 설치 -> 프로그램 실행               : yum





---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


(*
Command (m for help): m
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   g   create a new empty GPT partition table
   G   create an IRIX (SGI) partition table
   l   list known partition types
   m   print this menu
   n   add a new partition
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only)


명령(도움말의 경우 m): m
명령 작업
    a 부팅 가능한 플래그 토글
    b 편집 bsd 디스크 레이블
    c 도스 호환성 플래그 토글
    d 파티션 삭제
    g 새로운 빈 GPT 파티션 테이블 생성
    G IRIX(SGI) 파티션 테이블 생성
    l 알려진 파티션 유형 나열
    m 이 메뉴를 출력
    n 새 파티션 추가
    o 새로운 빈 DOS 파티션 테이블 생성
    p 파티션 테이블 출력
    q 변경 사항을 저장하지 않고 종료
    s 새 빈 Sun 디스크 레이블을 만듭니다.
    t 파티션의 시스템 ID를 변경
    디스플레이 변경

)


fdisk
    -Linux(에 기본적으로 탑차돼있는 장치 관리 프로그램)

    -사용 방법  
        fdisk <장치명>      : 해당 장치 관리
        (*  내부 명령어(command)
            d   : 파티션 삭제
            n   : 파티션 생성
            p   : 파티션 목록 확인
            q   : 변경 내용을 저장하지 않고 종료
            w   : 저장 후 종료
        
        )
        

        fdisk -l [장치명]   : 장치 인식 여부 확인
            (*
            예시 : fdisk -l /dev/sdb
                /dev/sdb 장치를 인식하고 있는지 확인함.
            출력 예시 : 
                Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
                Units = sectors of 1 * 512 = 512 bytes
                Sector size (logical/physical): 512 bytes / 512 bytes
                I/O size (minimum/optimal): 512 bytes / 512 bytes

            예시 : fdisk -l
                현재 운영체제에서 인식하고 있는 장치들에 대한 정보를 출력함
            출력 예시 :
                Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
                Units = sectors of 1 * 512 = 512 bytes
                Sector size (logical/physical): 512 bytes / 512 bytes
                I/O size (minimum/optimal): 512 bytes / 512 bytes
                Disk label type: dos
                Disk identifier: 0x000aaa69

                Device Boot      Start         End      Blocks   Id  System
                /dev/sda1   *        2048     2099199     1048576   83  Linux
                /dev/sda2         2099200     6293503     2097152   82  Linux swap / Solaris
                /dev/sda3         6293504    41943039    17824768   83  Linux

                Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
                Units = sectors of 1 * 512 = 512 bytes
                Sector size (logical/physical): 512 bytes / 512 bytes
                I/O size (minimum/optimal): 512 bytes / 512 bytes

            예시 : fdisk /dev/sdb
                /dev/sdb 장치 관리를 시작함.
            )
        



        
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------




find
    -검색하는 명령어
    -옵션을 검색할 내용으로 사용함

    -형식
    find 범위 [범위]...[범위] 옵션 값 [옵션] [값] ... [옵션] [값]

    -옵션
    name    : 이름으로 검색
    type    : 개체의 형식으로 검색(d : directory, f : file)
    newer   : 기준 파일 / 디렉터리 보다 늦게 수정된 개체 검색
    exec    : 일반적으로 마지막 옵션으로 사용하며, 검색 결과들을 대상으로 특정 명령어를 적용시킨다.

    -예시

    find / -name itbank
    (* /를 포함한 하위 디렉토리에서 이름이 itbank인 디렉토리만을 찾는다.)

    find / -name hello_itbank.txt -type f
    (* /를 포함한 하위 디렉토리에서 이름이 hello_itbank.txt 라는 '파일'을 찾는다.)

    find /home/itbank -newer test
    (* /home/itbank를 포함한 하위 디렉토리에서 test 디렉터리보다 늦게 수정/생성된 개체 검색)

    find /test /tmp -name "test*" exec rm {} \;
    (*/test 와 /tmp 의 각 디렉터리를 포함하여 하위 디렉토리에서 test로 시작하는 이름을 가진 파일을 rm(삭제)한다.)
    
    find /home/itbank -name "*itbank*" -type f -exec cat {} \;
    (*/home/itbank 디렉터리를 포함하여 하위 디렉토리에서 '파일'로 이루어진 요소에 itbank가 제목에 들어가있을 경우 해당 파일들을 cat(출력)한다. )




    
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



ftp
    -file transfer protocol; 파일 전송에 대한 통신 규칙/약속

ftp server 
    -파일 전송을 위한 서버 (클라이언트가 서버에 접속하여 자신의 파일을 서버에 저장(업로드)하거나 서버의 파일을 클라이언트에 저장 및 제공(다운로드) 할 수 있다)

    -설치 및 사용을 위한 작업
    1.linux 환경에서 입력해야할 것들(ftp server로 사용)
        yum -y install vsftpd-*                     : ftp 서비스 설치
        systemctl restart vsftpd                    : ftp 서비스 동작
        systemctl enable vsftpd                     : 부팅 시 ftp 서비스 자동 동작
        firewall-cmd --permanent --add-service=ftp  : 방화벽 예외 규칙에 ftp 서비스 추가
        firewall-cmd --reload                       : 방화벽 예외 규칙 적용
    2.windows 환경에서 해야할것들(ftp client로 사용)
        '제어판' > '시스템 및 보안' > 'Windows 방화벽에서 앱 허용' 으로 이동
        '허용되는 앱 및 기능(A):' 밑에 있는 테이블에서 '파일 전송 프로그램 찾기'
        '파일 전송 프로그램' 바로 왼쪽에 있는 박스를 포함하여, 오른쪽에 있는 '개인', '공용' 에 있는 박스에도 체크넣기

        (*만약 '파일 전송 프로그램'을 찾을 수 없다면 아래 방법을 이행)
        '허용되는 앱 및 기능(A):'테이블 박스 아래에 '다른 앱 허용(R)...'를 눌러 '앱 추가'창을 띄움  
        '앱 추가'창에서 '찾아보기(B)...'를 누른다.
        사용자의 로컬디스크에 Windows 파일에 ftp.exe 를 찾고, 더블클릭 한다.(*예시 : C:\Windows\System32\ftp.exe)
        '앱 추가'창에서 '앱(P):'박스 안에 '파일 전송 프로그램'을 누르고 아래의 '추가'버튼을 누른다.
        
        해당 과정을 완료했으면 위의 windows 환경에서 해야할것들 과정을 다시 거친다.

    -사용방법
    1.접속
        (ftp client = windows에서 접속)
        cmd -> ftp에 사용할 폴더로 이동 -> ftp <Linux IP> -> 사용자 로그인(root 접속 X)
        (*fpt에 사용할 폴더와 로그인 한 사용자의 홈 디렉토리 간의 파일 전송이 가능함)
        (*ftp <Linux IP> 예시 : ftp 127.168.10.128)
    2.파일전송
        -업로드(client가 자신의 컴퓨터에 있는 파일을 ftp server에 저장(복사))
            put 파일명 (*/업로드 할 파일이 ftp에 사용할 폴더 안에 있는 상태에서 입력)
        -다운로드(client가 server에 있는 파일을 내 컴퓨터에 저장(복사))
            get 파일명 (*다운로드 할 파일이 로그인 한 사용자 홈 디렉토리 안에 있는 상태에서 입력)





---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



user&group
사용자&그룹
    -사용자 계정이란?
    >사람이 장치를 사용하기 위해 로그인하는 계정
    누가 어떤 작업을 했는지 멱확하게 알기 위해서 개개인에게 생성해주는 계정
    사용자 계정을 이용하여 파일/디렉토리 권한 설정이 가능하다
    (같은 파일을 누구는 보고 누구는 못보는 등의 작업 범위 지정이 가능)

    -그룹이란?
    >사용자 계정을 묶어서 관리하기 위해 사용하는 계정
    관리자가 주로 제어하며(그룹 생성/수정/삭제, 그룹에 사용자 계정을 소속시키는 등)
    그룹에 권한을 부여하여 그룹에 소속된 사용자들이 동일한 권한을 적용받도록 할 수 있다.

사용자 계정
    -사용자 계정에 관련된 파일
        /etc/passwd     :사용자의 일반 정보가 들어있는 파일
            (*보는 방법 : itbank:x:1000:1000:dust:/home/itbank:/bin/bash)
            itbank      :사용명, 뒤의 정보들이 어느 사용자의 정보인지 표시함
            x           :암호이지만, 보안상의 이유로 passwd파일에는 암호를 표시하지 않는다.
            1000(왼쪽)  : UID, 이 사용자의 고유 번호
            1000(오른쪽): GID, 이 사용자가 소속된 주요 그룹의 고유 번호
            dust        :사용자 별칭(계정명 or ID로 사용 X, 표시되는 이름)

            (*여기서 말하는 UID, GID는
                UID :  User ID, 사용자에게 부여되는 고유 번호 
                GID :  Group ID, 그룹에게 부여되는 고유 번호 )
            (*   이란, 사용자가 입력한 명령어를 해독하는 해독기이며 운영체제(커널)에 명령을 전달해주는 역할을 한다. 현재 linux시스템에 설치된 shell은 /etc/shells 파일에서 확인이 가능하다.
            passwd 파일에 저장된 정보 중 shell 위치에 /sbin/nologin이 들어간 경우 해당 계정은 system or service 계정이다.(/sbin/nologin은 명령어 사용 shell 이다, 로그인을 하지 못하게 만드는 shell))
    
        /etc/shadow     :사용자의 고급 정보가 들어잇는 파일
            (*보는 방법 : itbank:$6$~~$~~~:18894:0:99999:7:::
            itbank      : 사용자명, 뒤의 정보들이 어느 사용자의 정보인지 표시한다.
            $6$~~$~~~   : 암호이다. 사용자가 로그인 할 경우 사용하는 비밀번호를 암호화하여 저장한다.
            18894       : 암호 생성 일자(1970년 1월 1일을 기준으로 몇일째에 생성된 암호인지 표시한다. 운영체제 설치 시 저장된 암호는 생성 일자가 표시되지 않는다.)
            0           : 암호 최소 사용 일자(변경불가기간)
            99999       : 암호 최대 사용 일자(만료 일자)
            7           : 암호 만료 전 경고 일자
            )

        /etc/login.defs : 사용자와 그룹 계정 및 삭제와 관련된 몇몇 정보들이 들어있는 파일


        
    -사용자 암호 변경
        passwd          : 명령어를 입력한 사용자 자신의 암호 변경(모든 사용자가 사용 가능)
        passwd 계정명   : '계정명' 사용자의 암호 변경(관리자만 사용 가능)
        passwd itbank   : itbank 사용자의 암호 변경(관리자만 사용 가능)
    
    -사용자 계정 생성
        useradd [옵션] [값] ... [옵션] [값] 사용자명

            옵션들 :
            c : 별칭 지정
            useradd -c testuser user2 (*user2를 추가하면서 testuser이라는 별명도 같이 넣는다.)

            s : shell 지정(system에 설치된 shell 지정 -> /etc/shells 파일에서 확인 가능)
            useradd -c testuser -s /bin/sh user2 (*user2를 추가하면서 testuser이라는 별명을 같이 넣고서 shell은 /bin/sh 라는 shell로 지정한다.)

            d : 홈 디렉토리의 경로와 이름 지정(반드시 경로와 이름 전부 절대경로로 작성)
            useradd -d /jong/ro user3 (*user3를 추가하면서 /jong/ro 디렉토리를 홈 디렉토리로 지정함. /etc/login.defs 파일 CREATE_HOME 설정이 없거나 no로 되어있으면 -m 옵션과 함께 사용)

            m : make directory

            k : 기본값 /etc/skel이 아닌 다른 디렉토리를 skel로 지정, 반드시 m 옵션과 함께 사용함.

            D : 사용자 생성 시 적용되는 기본 정보 확인한다. 그저 확인하는것만이 가능하니 사용자 계정을 생성할 수는 없다. 추가 옵션을 함께 사용하여 기본 정보 변경 할 수 있다.(예시 : d 옵션을 함게 사용하면 홈 디렉토리 생성 위치 변경이 가능하다.)
            



            /etc/skel   : 사용자 홈 디렉토리의 뼈대가 되는 디렉토리
                         사용자 생성 시 홈 디렉토리 내부에 복사할 파일/디렉토리들을 넣어놓는다
                         > 사용자 생성 시 홈 디렉토리 내부에 특정 파일/디렉토리 자동으로 생성 가능

            /etc/default/useradd     : 사용자 생성 시 적용되는 기본 정보가 저장된 파일이며 이 파일의 내용을 변경하면 useradd의 옵션을 사용하지 않아도 같은 효과를 볼 수 있다.


        문제 예시 :
        사용자 user7을 생성한다. (단 옵션을 사용하지 않고 아래의 정보가 적용되도록 설정 후 생성한다.)
        shell 의 이름 : tcsh
        홈 디렉토리 생성 위치 : /test
        skel 로 사용할 디렉토리 : /skelkg

        풀이 :

        mkdir /test (*홈 디렉토리 설정을 위한 /test 생성)

        cp -r /etc/skel /skelkg (*skel로 사용할 디렉토리 생성)

        vi /etc/default/useradd
        (*useradd 명령어의 기본정보가 담긴 파일로 vi 진입)

        (*
        #useradd default file
        GROUP=100
        HOME=/jong
        INACTIVE=-1
        EXPIRE=
        SHELL=/bin/bash
        SKEL=/etc/skel
        CREATE_MAIL_SPOOL=yes
        )
        HOME=/jong 을 HOME=/test 로 변경 
        SHELL=/bin/bash 를 SHELL=/bin/tcsh
        SKEL=/etc/skel 을 SKEL=/skelkg

        touch /skelkg/test7
        (*test7용 skel파일 제작)

        useradd user7
        (*user7 유저 추가)

        tail -1 /etc/passwd
        (*필수 아님. 잘 추가됐는지 확인)
    
    -사용자 계정 정보 수정
        usermod 옵션 값 [옵션] [값] ... [옵션] [값] 사용자명

        (*옵션은 useradd 의 옵션을 대다수 사용할 수 있다.)

        문제 예시 :
        모든 사용자의 홈 디렉토리를 /export/home/<username> 으로 변경
        (*잘못 만들어서 홈 디렉토리가 없는 경우에는 사용자 정보만 수정)

        사용자의 shell은 bash shell, 별칭은 전부 없도록 정보 수정
        (별칭 제거 시 '' 사용)

        풀이 :
        
            mkdir -p /exprot/home
            
            tail -8 /etc/passwd
            (*해당 운영체제에 관련된 (관리자를 제외한) 유저들에 대한 정보를 출력하는 명령어.
            이 명령어와 출력문을 통해서 해당 유저가 별칭을 갖고있는지, 홈 디렉토리은 어디인지, 쉘은 뭘 쓰는지 등등의 정보를 확인한다.)

            usermod -c '' -d /export/home/itbank itbank
            (* -c '' 는 itbank itbank의 별명을 없애는 역할을 한다.
               -d /export/home/itbank 는 itbank
                itbank 는 앞서 입력했던 옵션들과 값들의 목표가 되는 유저를 뜻한다.
            )

            mv /home/itbank /export/home
            (* /home/itbank 는 해당 명령 이행 이전에 쓰이던 itbank 유저의 홈 디렉토리를
            /export/home 으로 옮기기 위함이다.
            )

            usermod -d /export/home/user1 user1
            (*user1의 홈 디렉토리를 /export/home/user으로 변경.)
            usermod -d /export/home/user4 user4
            (*user4의 홈 디렉토리를 /export/home/user4으로 변경.)
            usermod -d /export/home/user5 user5
            (*user5의 홈 디렉토리를 /export/home/user5으로 변경.)
            usermod -d /export/home/user7 user7
            (*user7의 홈 디렉토리를 /export/home/user7으로 변경.)
            usermod -d /export/home/user2  -c '' -s /bin/bash
            (*user2의 홈 디렉토리를 /export/home/user으로 변경하고 별칭을 제거하며 사용자에 배정된 shell을 /bin/bash 로 바꾼다.)
        
            mv /home/user* /export/home/
            (* /home/디렉토리 안에 user가 디렉토리 앞에 포함된 경우에 예외없이 /export/home/으로 옮긴다.)

            usermod -d /export/home/user3 user3
            (*user3의 홈 디렉토리를 /export/home/user3으로 변경.)

            mv /jong/ro /exprot/home/user3
            (*원래 user3의 홈 디렉토리였던 /jong/ro 디렉토리를 /export/home/user3로 옮긴다.)


            usermod -d /export/home/user6 user6
            (*user6의 홈 디렉토리를 /export/home/user6으로 변경.)
            mv /jong/user6 /export/home
            (*원래 user6의 홈 디렉토리였던 /jong/user6 디렉토리를 /export/home으로 옮긴다.)

        
    -사용자 계정 삭제
            userdel [옵션] 사용자명

            옵션 :
            r : 사용자의 홈 디렉토리나 메일함 등 사용자 소유의 개체들을 함께 삭제

    -그룹
        -사용자 계정을 그룹에 소속시켜서 사용함(= 사용자 계정들을 하나의 그룹으로 묶어준다.)
            > 그룹을 대상으로 권한을 부혀아여 그룹에 소속된 모든 사용자가 동일한 권한을 적용 받음

        - 사용자가 그룹에 소속되는 방법을 두가지로 분류
        1. 사용자가 그룹을 자신의 주요 그룹으로 사용(=gid로 사용)
        2. 사용자가 그룹에 일반 소속되어 사용함.            
        
        -그룹에 관련된 파일 
            /etc/group      :그룹의 일반 정보가 들어있는 파일 
            *파일 내용 보는 방법
            itbank:x:1000:

            itbank  : 그룹 이름, 뒤의 정보가 어느 그룹의 정보인지 알려준다.
            x       : 암호, 그룹에는 별도의 암호를 지정하지 않는다.
            1000    : gid, 해당 그룹의 고유 번호
            <마지막 필드(*현재 예시에는 공백 상태)>
                    : 그 그룹에 일반 소속된 사용자들의 목록 출력

        -그룹 생성
            groupadd [옵션] [값] ... [옵션] [값] 그룹명

            

            옵션 :
            g : 생성되는 그룹의 GID 지정

            예시 :
            groupadd test_group (*test_group이라는 이름의 그룹을 생성함)
            groupadd -g 1234 test_group (*test_group이라는 이름의 그룹을 GID가 1234인 상태로 생성함.)

        -그룹 정보 수정
            groupmod 옵션 값 [옵션] [값]  ... [옵션] [값] 그룹명

            옵션 : 
            g : 그룹의 gid 지정
            n : 그룹의 이름 지정 

            예시 :
            groupmod -g 4321 test_group (*test_group의 GID를 4321로 변경함)
            groupmod -n ghdwpaks test_group (*test_group라는 이름의 그룹을 ghdwpaks 이라는 이름의 그룹으로 이름변경을 함)
            groupmod -g 7904 -n ghdghdwpaks ghdwpaks(*ghdwpaks이라는 이름의 그룹의 GID를 7904로 바꾸고 이름도 ghdghdwpaks으로 변경함)

        -그룹 삭제
            groupdel 그룹명
            (*사용자가 주요 그룹(gid)로 사용중인 그룹은 삭제하지 못한다.)

        - 사용자 + 그룹
        1. 사용자를 만들면 같은 이름의 그룹이 자동으로 생성된다 (*사용자는 함께 만들어진 그룹을 자신의 주요 그룹(GID)으로 사용한다)
        2. 사용자가 일반 소속된 그룹과 사용자의 주요 그룹은 언제든지 변경 가능하다.
            1)GID 변경  > 사용자 계정 정보를 수정(= usermod)
            2)일반 소속된 그룹 변경 > 사용자 계정 정보를 수정(= usermod)
                                    > gpasswd 명령어 사용
        
        -gpasswd
            -그룹에 소속된 일반 사용자 목록을 제어

            -사용 형식
                gpasswd 옵션 사용자명 그룹명

            -옵션들 :
                a : 그룹에 사용자를 일반 소속 
                d : 그룹의 일반 사용자 목록에서 특정 사용자 제거

            -예시 :
                gpasswd -a user12 test_group (*user12를 test_group에 소속시킴)
                gpasswd -d user12 test_group (*user12를 test_group에 소속제외시킴)

        
        -id
            -사용자의 UID와 GID, 소속된 그룹의 목록 확인
            - 사용 형식
                id <사용자명>

        문제 예시 :
            아래 조건에 맞는 사용자 생성해보기
            user    : testuser
            UID     : 1200
            GID     : tg
            shell   : csh
            home directory 생성 위치    : /hosting
            skel    : /kgskel
            자동생성 디렉토리           : public_html
            자동생성 파일               : .kg

            조건 1. 모든 작업은 기본정보(useradd -D, /etc/default/useradd)를 수정하지 않고 옵션만 사용
            조건 2. 사용자 생성 후 다른 명령어를 사용하여 정보 수정 X (usermod 등등)

            groupadd tg

            cp -r /etc/skel /kgskel

            touch /kgskel/.kg

            mkdir /kgskel/public_html /hosting

            useradd -u 1200 -g tg -s /bin/csh -d /hosting/testuser -mk /kgskel testuser

            tail -1 /etc/passwd

            id testuser

            

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------





-gpasswd
        -그룹에 소속된 일반 사용자 목록을 제어

        -사용 형식
            gpasswd 옵션 사용자명 그룹명

        -옵션들 :
            a : 그룹에 사용자를 일반 소속 
            d : 그룹의 일반 사용자 목록에서 특정 사용자 제거

        -예시 :
            gpasswd -a user12 test_group (*user12를 test_group에 소속시킴)
            gpasswd -d user12 test_group (*user12를 test_group에 소속제외시킴)



            
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



grub2 boot loader
    - boot loader : 부팅 과정에서 어느 OS로 부팅할 것인지 선택하여 그 OS로 부팅을 시작시키는 역할
        > CentOS는 6.X 버전까지는 grub 사용, 7.0 버전부터 grub2 사용

    - boot loader 화면에서 특정 방식의 제어를 통하여 root 암호를 모르는 상태로 root 접근 가능
    1. 부팅 시 kernel 목록이 나오는 화면(5초 유지)에서 아래 방향키를 한 번만 내려도 자동 진행이 멈춤

    2. 가장 위에 있는 kernel(최신 버전 kernel) 선택한 상태에서 e 눌러서 편집 화면으로 이동

    3. 편집 화면에서 아래 방향키를 꾹 눌러서 마지막 줄 까지 이동 후 linux16으로 시작하는 줄의 내용 수정
        * 수정 내용 : ro -> rw, rhgb quiet -> init=/bin/bash, LANG=ko_KR.UTF-8 내용은 삭제
        * 수정 내용 중 rhgb quiet를 rhgb single로 바꿔주면 single user mode 부팅

    4. 수정된 내용으로 부팅(일회성)을 하기 위해 ctrl + x 눌러주기

    5. 각종 메세지가 출력되다가 bash-4.2# 이 출력되면 root 사용자로 부팅이 완료된 상태(확인 : whoami)
        * 이 환경에서 동작이 안되는 명령어들이 있다

    6. 필요한 작업이 다 끝난 후에는 exec /sbin/init 입력하여 정상 부팅

    - grub2 boot loader에서 kernel 편집 막는 방법(인증 통과 후 편집)
        1. /etc/grub.d/00_header 파일 마지막 줄 아래로 다음 내용 추가
        <내용>
        cat << EOF
        set superusers='인증ID'
        password 인증ID 인증암호
        EOF

        2. grub2-mkconfig -o /boot/grub2/grub.cfg   명령 입력하여 적용



        
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


하드디스크의 물리적 구조
    -플래터와 헤드로 구성되어 있다
    
    -플래터(platter)
        실제 자료가 저장되는 매채
        하나의 디스크에는 여러 장의 플래터가 들어있고, 하나로 묶여서 한 방향으로 회전
        플래터가 손상되면 배드 섹터(bad sector)가 발생하거나 플래터 전체를 사용할 수 없음
    
    -헤드(head)
        플래터에 자료를 기록하는 펜
        플래터에 데이터를 입력/수정/삭제 할 수 있도록 만들어주는 도구

하드디스크의 논리적 구조
    -플래터는 트랙과 실린더라는 개념으로 나누고 트랙과 실린더가 교차되는 영역을 섹터라고 한다.

    -하나의 하드디스크를 논리적으로 여러 개의 영역으로 분할한 개념을 파티션이라고 한다
        >실제로 사용되는 장치 영역이 파티션(예시. C: , D: , F: 등이 각각 하나의 파티션)

    - 트랙(track)
        플래터 전체 면적을 동심원 기준으로 나눴을 때 나오는 영역

    -실린더(cylinder)
        플래터 전체 면적을 반지름 선을 기준으로 나눴을 떄 나오는 영역

    -섹터(sector)
        트랙과 실린더가 교차되면서 나오는 영역
        실제 자료가 저장되는 영역(1 sector = 512byte)

파티션 종류
    -primary partition(주 파티션)
    일반적으로 사용하는 파티션
    자료 저장 가능, 운영체제 설치 가능
    하나의 디스크에 최대 4개까지 생성 가능
    4개보다 많은 파티션을 사용하기 위해서 extended/logical partition 사용

    -extended partition
        파티션의 개수를 4개 넘게 확장하기 위해 사용하는 파티션
        확장 파티션을 생성한 후 확장 파티션을 분할하여 논리 파티션 생서 
        자료 저장 불가능, 운영채제 설치 불가능.
        하나의 디스크에 단 1개만 생성 가능(primary와 extended를 합쳐서 4개까지 생성)
        logical partition 생성을 위한 용도 말고는 사용하지 않는다.

    -logical partition(논리 파티션)
        확장 파티션을 분할하여 생성
        BIOS가 읽어내지 못하는 파티션(partition table에 logical 정보 없음, 저장되지 않음)
        (*  MBR(Master Boot Record)
                MBR area (1MB)
                partition table(64byte)
                primary/extended
                (16byte))
        자료 저장 가능, 운영체제 설치 불가능
        생성 개수 제한 없음
        (단, 하나의 디스크에 있는 모든 logical partition의 용량의 합은 extended partition의 용량을 넘을 수 없다.)

디스크/파티션의 이름이 붙는 방식
    -디스크가 추가되거나 파티션이 생성되면 /dev 디렉터리 내부에 장치 파일이 자동으로 생성

    -디스크
        ~CentOs 5.X : hd<?> or sd<?>    >> hd<?> : IDE 연결, sc<?> : SCSI 연결

        CentOs 6.0  : hd<?>             >> IDE가 단종되면서 hd<?> 제거, IDE 연결도 sd<?>로 처리함(단, CentOs는 IDE가 섞이면 부팅 시 장치 이름이 마음대로 변경됨)

        hd 혹은 sd 뒤에 알파벳 한 글자 붙어서 디스크의 이름 구성
        (알파벳 붙은 순서는 메인보드 슬롯 번호를 따라감, system이 자동으로 할당)
            예시>
                sba, sdb, sdc ...
            
            *CD-ROM
                ~ CentoOS 5.X : hdc
                CentOs 6.0 ~  : sr0

    -파티션
        HDD 이름<?>
        디스크 이름 뒤에 숫자라 붙어서 파티션의 이름 구성
            >primary/extended : 1 ~ 4, logical : 5 ~
            1 ~ 4 번은 파티션 생성 과정에서 사용자가 지정함
            5번부터는 파티션 생성 과정에서 system이 순차적으로 자동 할당
            ex >
                sba1, sba2, sbd5 ...





---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


head
    -파일의 첫 줄부터 10줄 출력
    
    -옵션
        -숫자 : 숫자만큼의 줄 출력

    -예시
    head hello.txt
    head -20 hello.txt
    head -30 hello.txt
    


---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

    hello world
here is dir for save linux note files
thx a lot for visit
have a nice day



---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------




index.html 허가권을 바꾸고 인터넷 창 새로고침
(*변경자 : root(관리자))
(*사용자 : itbank(일반 사용자))

644 : 가능
244 : 가능
444 : 가능
604 : 가능
640 : 불가능


itbank 홈 디렉터리 허가권을
(*변경자 : root(관리자))
(*사용자 : itbank(일반 사용자))

700 : 가능
600 : 불가능    원격 호스트에 의해 연결이 닫혔습니다.
500 : 불가능    접속은 가능하지만 파일 주기 가져오기가 안된다
400 : 불가능    원격 호스트에 의해 연결이 닫혔습니다.
300 : 가능
200 : 불가능    원격 호스트에 의해 연결이 닫혔습니다.
100 : 불가능    접속은 가능하지만 파일 주기 가져오기가 안된다
000 : 불가능    원격 호스트에 의해 연결이 닫혔습니다.




---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


http
    - web server : client의 요청에 web page를 제공해주는 서버
        > httpd- 로 시작하는 web server는 apache web server
    
    - 설치 및 사용 준비
        yum -y install httpd-*                      : apache web server 설치
        systemctl restart httpd                     : web server 동작
        systemctl enable httpd                      : 부팅 시 web server 자동으로 동작
        firewall-cmd --permanent --add-service=http : 방화벽 예외 규칙에 http 추가
        firewall-cmd --reload                       : 방화벽 다시 실행

    - 사용 방법
        web browser에 web server의 IP를입력
        


        
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


less
    -more와 동일한 기능 + 지나간 내용을 다시 볼 수 있다.
    -more와 비슷하게, 일반적으로는 다른 명령어와 함께 사용한다.
    -동작 후 추가 입력 키
        enter       : 한 줄 아래가기(= j , 아래 방향키)
        k           : 한 줄 위로가기(= 위 방향키)
        spacebar    : 한 화면 아래가기(= page down 키)
        page up     : 한 화면 위로가기(= page up 키)
        g           : 처음으로 이동
        g           : 마지막으로 이동

        q           : less 중간에 종료
    
    -예시
    ls -alR / | less
    less hello.txt


    
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



ln
    - hard link 생성

    - 사용 형식
        ln [옵션] 원본 링크이름

    * 옵션
        -s	: hard link 대신에 symbolic link 생성
        -f	: 기존 link 파일에 덮어쓰기
        (이미 존재하는 link 파일로는 link 생성이 불가능해서 사용하는 옵션)

    > hard link	: 원본 파일과 inode 값이 같은 파일 생성(= 같은 sector에 저장된 데이터로 연결하는 파일 생성)
        symbolic link	: 원본 파일로 연결되는 link 파일(= windows의 바로가기 개념)


        
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



ls
-대상
    생략    : 현재 위치한 디렉토리 내부의 목록을 확인
    파일    : 파일 자체에 정보를 확인
    디렉토리: 디렉토리 내부의 목록을 확인
-옵션
    l  :(L , 엘)자세한 정보 출력
    a  :숨겨진 항목들 출력
    d  :대상이 디렉터리(directory)인 경우에 대상 자체의 정보를 출력함(디렉터리가 아닌 대상으로는 적용되지 않는다.)
    * l(엘)옵션 정보 예시
    R  :(대문자)대상이 디렉터리(directory)인 경우에 하위 디렉토리가 있다면 하위 디렉토리의 내부까지 출력함

    drwx------.  3 itbank itbank  78  9월 16 23:20 itbank

    d           : 대상 객체의 형식(- : 일반 파일 , d : 디렉터리(directory), l : 바로가기(Symbolic link file ... ))
    rwx------.  : 허가권
    3           : 링크(link) 개수
    itbank itbank   : 소유권
    78              : 크기(byte 단위, 디렉토리(directory는 정확한 크기 X))
    9월 9 20:24     :마지막으로 수정된 날짜와 시간



---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

man
    -명령어 / 파일에 대한 자세한 설명(매뉴얼) 확인

    -예시 :
    man ls
    man mkdir

    -동작 후 추가 입력 키
    enter       : 한 줄 아래가기
    k           : 한 줄 위로가기
    spacebar    : 한 화면 아래가기
    page down   : 한 화면 아래가기
    page up     : 한 화면 위로가기
    g           : 처음으로 이동
    G           : 마지막으로 이동
    /pattern    : pattern(패턴) 검색(검색 후 n 눌러서 다음 찾기)
    q           : man 종료



---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


mkdir
    - make directory 디렉토리 생성
    - 생성할 디렉토리 경로가 존재하지 않으면 생성이 불가능하다(다만 옵션을 사용하여 경로까지 함께 생성할 수 있다.)
    - 옵션
        -p : 생성할 디렉토리의 경로까지 함께 생성(상위 디렉토리까지 생성)
    - 예시
        mkdir itbank3
        mkdir -p ./itbank4/itbank5
        



---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

more
    -출력되는 내용이 너무 많을 때 화면 높이에 맞춰서 내용을 나누어 출력함

    -동작 후 추가 입력 키

    -지나간 내용을 다시 볼 수는 없다.

    -일반적으로는 다른 명령어와 (파이프 기호(|)를 통해)함께 사용하는게 보편적이다.

    enter       : 한 줄 넘어가기
    spacebar    : 한 화면 넘어가기
    q           : more 중간에 종료

    -예시 
    more hello.txt
    ls -al /etc/ | more
    



    
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



mv
    -move , 이동(잘라내기 + 붙혀넣기)
    -파일과 디렉토리 전부 이동 가능
    -원본 파일과 같은 이름으로 이동하거나 원본 파일과 다른 이름으로 이동하는게 가능하다. (다만, 이름을 바꿔서 이동할때는 원본을 하나만 입력할 수 있다.)
    -형식
    mv [옵션] 원본 [원본] ... [원본] 이동할위치[이름]
    -예시
    mv ./*.txt ./itbank/
    mv ./hello.txt ./itbank/hellooo123.txt
    

    
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
nl
    -출력 내용에 줄 번호 붙여주는 명령어
    -일반적으로는 다른 명령어와 함께 사용한다.
    -예시:
    (*ls -l /etc/ , less , nl 총 3가지 명령어를 한 줄로 작성하여 /etc/ 내부 목록에 줄 번호 붙여서 less 적용시켜보기)
    ls -l /etc/ | nl | less
    


---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

압축
    - 파일의 용량을 줄이기 위해 사용
    - 원본 파일 자체가 압축 된다(복사본 생성 후 압축하는 작업 X)
    - 여러 파일 동시에 압축하면 각각의 파일 개별 압축
    - 디렉토리 압축 X

    - 명령어
    압축형식		압축		압축해제

    .zip		    zip		    unzip
    .gz		        gzip		gunzip (gzip -d)
    .bz2		    bzip2		bunzip2 (bzip2 -d)

    tar
        - Tape ARchive; 초창기에는 여러 파일을 하나의 파일로 묶어서 백업하는 용도로 사용
        - 여러 파일을 하나의 tar 파일로 묶어주기 때문에 압축 가능

        - 파일을 담을 공간을 만들고 거기에 파일을 담아주는 개념
            > 하나의 tar 파일로 묶을 대상들의 용량이 커질수록 tar 파일의 용량이 커진다
        + tar 파일의 크기는 정해져 있다

        - 사용 형식
            tar 파일 생성	    : tar cvf 생성할이름.tar 대상 [대상] ... [대상]
                (* tar cvf test.tar ./vim-*
                ./test.tar 이라는 압축 파일 안에 '파일 이름 앞에 ./vim-이 붙은 파일 전부'를 넣는다. )
            tar 파일 내부 확인	: tar tvf <tar 파일명>
                (*      tar tvf test.tar
                        ./test.tar 이라는 압출 파일 안에 뭐가 있는지 본다.

                    출력 예시 :
                    -rw-r--r-- itbank/itbank 1239584 2021-10-06 20:03 ./vim-X11-7.4.629-7.el7.x86_64.rpm
                    -rw-r--r-- itbank/itbank 6205496 2021-10-06 20:03 ./vim-common-7.4.629-7.el7.x86_64.rpm
                    -rw-r--r-- itbank/itbank 1105904 2021-10-06 20:03 ./vim-enhanced-7.4.629-7.el7.x86_64.rpm
                    -rw-r--r-- itbank/itbank   11144 2021-10-06 20:03 ./vim-filesystem-7.4.629-7.el7.x86_64.rpm
                    -rw-r--r-- itbank/itbank  453600 2021-10-06 19:18 ./vim-minimal-7.4.629-7.el7.x86_64.rpm    )
            tar 파일 해체	    : tar xvf <tar 파일명>
                (*
                    tar xvf /home/itbank/test.tar
                    지금 현재 위치한 디렉터리에 /home/itbank/test.tar 를 푼다.
                )

        * 옵션
            z	: gzip 압축/압축해제를 함께 진행
                (* 예시 : 
                tar zcvf test_test.tar.gz ./vim-*
                ./test_test.tar.gz 이라는 압축 파일 안에 '파일 이름 앞에 ./vim-이 붙은 파일 전부'를 넣는다. 

                zcvf 와 앞서 사용했던 cvf와 다른점은 '크기'이다. z옵션이 붙어 gzip을 이용한다면 압축률이 좋다.
                zcvf을 이용할 시 파일 크기 : 8833647
                cvf 를 이용할 시 파일 크기 : 9021440
                )
            j	: bzip2 압축/압축해제를 함께 진행
                (*예시 : 
                tar jcvf ./test_test2.tar.bz2 ./vim-*
                ./test_test.tar.bz2 이라는 압축 파일 안에 '파일 이름 앞에 ./vim-이 붙은 파일 전부'를 넣는다. 

                줄리안 시워드가 Burrows-Wheeler transform 블록 정렬 알고리즘과 Huffman coding 을 사용해 만든 압축 프로그램 
                gzip과 일반 tar 압축에 비해 효율이 좋을 때도 있다. 그만큼 시간이 오래 걸린다.
                항상 효율이 좋은건 아닌거같다.
                )

    rpm
        - redhat package manager; 패키지를 이용한 프로그램/서비스 관리

        * 패키지 : 프로그램을 나눠놓은 조각

        - Linux는 kernel부터 시작하여 모든 구성이 패키지로 이루어져 있고, 패키지는 다른 패키지와 의존 관계에 놓여 있는 경우가 많다
            > 패키지 설치/삭제 과정에서 의존성 관련 오류가 굉장히 많이 나온다

        - rpm은 redhat에서 처음 만들어서 도입했고, redhat 기반의 모든 Linux에서는 rpm 명령어 사용
            > devian 기반의 Linux에서는 rpm이 아닌 dpkg 명령어 사용

        - 사용 형식
            설치	: rpm -ivh 패키지명-버전.아키텍처.rpm
                    (*
                    입력 예시 : rpm -ivh vim-minimal-7.4.629-7.el7.x86_64.rpm
                    'vim-minimal-7.4.629-7.el7.x86_64.rpm'을 설치한다.
                    )
            
            확인	: rpm -qa | grep 패키지명
                    (*
                    입력 예시 : rpm -qa | grep vim-
                    설치된 rpm 패키지들중에 'vim-'라는 글자가 들어간 패키지가 뭔지 알려준다.

                    출력 예시 :
                        vim-filesystem-7.4.629-7.el7.x86_64
                        vim-minimal-7.4.629-7.el7.x86_64
                        vim-common-7.4.629-7.el7.x86_64
                        vim-enhanced-7.4.629-7.el7.x86_64
                        vim-X11-7.4.629-7.el7.x86_64
                    )


            삭제	: rpm -e 패키지명[-버전.아키텍처]
                    (*
                    입력 예시 : rpm -e vim
                    vim과 관련된 패키지들을 전부 삭제한다.
                    )

        - 패키지 이름 구조

            vim-filesystem-7.4.629-7.el7.x86_64
            <------------>|<----------->|<---->
            패키지명	    버전	     아키텍처

            1. 패키지명
            패키지명은 한 단어이거나 - 기호를 이용하여 여러 단어의 조합으로 구성되어 있다
            (이때 숫자만 단독으로 나오는 경우가 없기 때문에 버전과 구별이 가능)

            패키지명 영역이 한 단어로 구성되어 있으면 해당 패키지로 설치되는 프로그램 or 서비스 이름을 나타낸다

            패키지명 영역이 여러 단어로 구성되어 있으면 첫 단어가 설치되는 프로그램 or 서비스 이름을 나타내고
            뒤에 이어지는 단어들이 세부 역할을 의미한다

            2. 버전
            버전은 여러가지 세부 버전으로 구성

                7	: major
                4	: minor
                629	: patch
                7	: release
                el7	: OS

                * 운영체제 버전 예시
                el7	= centos 7.X
                el7_9	= centos 7.9
                centos	= centos all version
                <생략>	= all OS

            3. 아키텍처
            CPU의 bit와 관련되어서 특정 수준의 CPU 이상에서 사용 가능하다 라는 의미
                > CPU의 bit수는 한 번에 처리 가능한 데이터의 bit 수
                32bit	: i386, i586, i686
                64bit	: x86_64
                noarch	: 32bit CPU와 64bit CPU 혼용

        - 의존성 오류
            1. 확인 방법
                A is needed by B	: B에게 A가 필요하다

                1) 설치 할 때
                    B를 설치하기 위해 A가 먼저 설치되어야 한다

                2) 삭제 할 때
                    B에게 A가 필요하기 때문에 A를 지울 수 없다

            2. 해결 방법
                1) 설치 할 때
                A를 먼저 설치하고 다시 B를 설치
                (단, 버전이 함께 나오는 경우에 의존성 오류 메세지에 나오는 버전에 맞춰서 설치)

                2) 삭제 할 때
                B를 먼저 삭제하고 다시 A를 삭제
                (단, B가 다른 프로그램 or 시스템의 중요 요소인 경우에는 B는 삭제 X, 의존성 오류 무시)

       

            3. 의존성 오류 메세지에 패키지명이 아닌 다른 내용이 출력되면?
                1) 파일의 절대경로
                > 패키지에 해당 파일이 포함되어 있는 경우(일반적으로 삭제 할 때 출력)
                파일명을 패키지 이름으로 대체해서 메세지를 읽어 준다

                2) lib~~~.so.숫자(~~~)
                > ~~~ 부분이 패키지를 의미(설치/삭제 할 때 전부 출력)
                해당 의존성 오류 메세지를 검색하여 패키지명 확인

                3) pkgconfig(~~~)
                > ~~~ 부분이 패키지를 의미(일반적으로 설치 할 때 출력)
                해당 의존성 오류 메세지를 검색하여 패키지명 확인

            * 의존성 오류 무시 --nodeps

                보조옵션 nodeps를 사용하면 의존성 오류를 무시할 수 있다

                nodeps 보조옵션을 남용하면 다른 프로그램 or 시스템에 오류가 발생할 수 있다
                > 패키지를 확인했을 때 중요 패키지이거나(삭제 할 때) 찾을 수 없는 패키지라면(설치 할 때) 의존성 오류 무시



                
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

프로세스
    - CPU의 리소스(연산 능력)를 사용하는 프로그램

    - 프로세스 분류
        1) 종류
            대화형 프로세스	: 사용자가 입력장치를 통하여 전달한 명령의 결과를 출력장치를 통해 돌려주는 프로세스
            배치 프로세스	: 정해진 시간에 정해진 동작을 수행하는 프로세스
            데몬 프로세스	: 서비스의 동작을 제어하는 프로세스

        2) 동작 위치
            포그라운드 프로세스	: 내가 현재 사용 중인 프로세스
            백그라운드 프로세스	: 그 외 모든 동작 중인 프로세스

    - 프로세스 확인
        ps -ef | grep <프로세스명>

        * 출력 내용 보는 방법
            UID	: 해당 프로세스를 동작시킨 사용자(system이 동작시킨 프로세스는 root로 출력)
            PID	: Process ID, 프로세스에 붙는 관리(식별) 번호, 이미 사용된 번호는 재부팅 전에는 다시 사용 X
            PPID	: Parents PID, 해당 프로세스의 상위 프로세스 PID(프로세스도 tree 구조로 구성되어 있다)
            C	: CPU 점유율(0으로 출력되는 내용은 1% 미만의 점유율)
            STIME	: Start TIME, 프로세스가 동작을 시작한 시간 정보
            TTY	: TeleTYpe writer = terminal, 해당 프로세스를 제어하는 Terminal
            > ? : system, tty/숫자 : real terminal, pts/숫자 : virtual terminal(putty 등)
            TIME	: 프로세스가 동작하는데 걸린 시간
            CMD	: CoMmanD, 프로세스를 동작시킨 명령

    - 프로세스 종료
        kill <PID>

* 종료되지 않는 프로세스는 상위 프로세스를 확인하여 종료
(종료하면 안되는 프로세스인지 반드시 확인




---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



rdate
    -인터넷에 존재하는 time 서버의 날짜와 시간을 출력함

    -형식
        radte [옵션] <time 서버 주소>

    -옵션
        s : time 서버의 날짜와 시간을 현재 장치에 적용시킴

    -예시
    rdate time.bora.net
    rdate -s time.bora.net


    
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

rm
    -remove 삭제
    -기본적으로 파일 삭제 가능(디렉토리를 삭제하고싶은 경우 옵션을 이용하여 삭제한다.)
    -옵션
        r : 디렉토리까지 삭제
        f : 확인과정을 생략하고 삭제
    -예시
    rm -rf ./itbank/*
    rm -rf ./*



---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


rmdir
    -remove directory 디렉토리 샂게
    -디렉토리 내부에 다른 파일 / 디렉토리가 있다면 삭제가 불가능하다
    -옵션
        -p : 디렉토리 삭제 시도 후 상위 디렉토리가 비어 있는 경우 함께 삭제
        
    -예시
    rmdir ./itbank4/itbank5
    rmdir ./*


    
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


run-level
    - 시스템 부팅 과정에서 동작하는 각종 프로세스들을 단계별로 구분해놓은 개념
        런레벨에 따라 동작하는 프로세스들이 추가되는 방식으로 구성

    - unix 기반의 운영체제는 부팅 시 어느 run-level 단계로 부팅을 할 것인지 설정
        > 운영체제에 따라 런레벨이 다르기 때문에 미리 확인이 필요하다

    - CentOS 7 버전으로 기준으로 런레벨 방식이 변경
        ~ CentOS 6 : 부팅 시 initd 메인 프로세스가 동작 -> /etc/inittab 파일 내부 내용을 확인하여 부팅한 런레벨 결정
    ( /etc/inittab 내부 id:숫자:initdefault: 설정의 숫자에 따라 런레벨 결정)

    runlevel 0 : halt(시스템 종료)
    runlevel 1 : single user mode(CLI, only root, 최소한의 service 동작, 백업/복구용 사용)
    runlevel 2 : multi user mode without NFS(CLI, all user, GUI+network 관련 service 제외하고 동작)
    runlevel 3 : full multi user mode(CLI, all user, GUI 관련 service 제외하고 동작)
    runlevel 4 : unused
    runlevel 5 : X11(GUI, all user, all service 동작)
    runlevel 6 : reboot(시스템 재부팅)

    CentOS 7 : 부팅 시 systemd 메이니 프로세스 동작 -> default.target 링크 파일에 연결된 런레벨로 부팅
    ( /etc/systemd/system/default.target 링크파일이
    /usr/lib/systemd/system/ 디렉토리 내부 런레벨 타겟에 연결되어 있다)

    poweroff.target	  : runlevel 0
    rescue.target	  : runlevel 1
    multi-user.target : runlevel 3
    graphical.target  : runlevel 5
    reboot.target	  : runlevel 6

    - 런레벨 확인
        systemctl get-default
        ls -l /etc/systemd/system/default.target

    - 부팅 시 참조하는 런레벨 변경
        systemctl set-default <런레벨 타겟>
        ln -sf /usr/lib/systemd/system/<런레벨 타겟> /etc/systemd/system/default.target


---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



파이션 생성 후 사용을 위해 해야하는 작업
    1. 파일 시스템 형식 설정
        -파일 시스템 형식 : 장치에 자료를 저장하는 형힉

        -운영체제와 버전에 따라 다를 수 있다.
            > 사전에 확인 필요
        
        -현재 시스템에서 제공하는 파일 시스템 형식은 명령어를 통해 확인이 가능하다.
            > ls -l /usr/sbin/mkfs*

        -filesystem(partition)을 처음 생성하면 형식 지정을 하지 않는다.
            >명령어를 이용하여 파일 시스템 형식을 지정해야한다.

        -파일 시스템 형식 지정 명령어 : mkfs
            mkfs -t <FStype> <partition>
            (*예시 : mkfs -t xfs /dev/sdb1
                    /dev/sdb1 파티션의 파일 시스템 형식을 xfs로 지정한다.)
            mkfs.<FStype> <partition>
            (*예시 : mkfs.xfs /dev/sdb1
                    /dev/sdb1 파티션의 파일 시스템 형식을 xfs로 지정한다.)
            (*CentOS 7 버전에서는 xfs를 기본 파일 시스템 형식으로 적용한다.)
            명령어 옵션 : 
            f : 덮어쓴다.
            (*예시 : mkfs.xfs -f /dev/sdb1
                    /dev/sdb1 파티션의 파일 시스템 형식을 xfs로 지정한다.)

        -파일 시스템 형식 확인 명령어 : blkid
            blkid <partition>
            (*예시 : blkid /dev/sdb1
                    /dev/sdb1파티션의 파일 시스템 등등의 정보를 확인한다.)

        -파일 시스템 형식 지정은 빠른 포캣과 비슷한 역할을 수행한다.
            >장치 내부에 있는 자료들의 사용이 불가능 할 수 있다.
        
        -파일 시스템 형식은 자료를 넣을 장치에만 지정한다
            >primary/logical : 반드시 지정, extended : 지정 안함


    2. 접근 경로 할당
        -장치에 접근하여 사용할 수 있도록 장치를 디렉토리에 덮어씌우는 작업
            >장치파일을 직접적으로 사용할 수 없기 대문에 장치를 사용하기 위해 반드시 해야하는 작업

        -마운트 명령

            장치 출력   : mount (*현재 운영체제에 연결된 모든 장치 출력)
            (*예시 : mount
            출력 예시 : 
                pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
                cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)
                cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)
                cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)
                cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)
                cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)
                cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
                cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)
                cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)
                cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
                cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
                configfs on /sys/kernel/config type configfs (rw,relatime)
                /dev/sda3 on / type xfs (rw,relatime,attr2,inode64,noquota)
                systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=34,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=13806)
                debugfs on /sys/kernel/debug type debugfs (rw,relatime)
                mqueue on /dev/mqueue type mqueue (rw,relatime)
                hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime)
                fusectl on /sys/fs/fuse/connections type fusectl (rw,relatime)
                /dev/sda1 on /boot type xfs (rw,relatime,attr2,inode64,noquota)
                sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw,relatime)
                tmpfs on /run/user/42 type tmpfs (rw,nosuid,nodev,relatime,size=99568k,mode=700,uid=42,gid=42)
                tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,size=99568k,mode=700)
                /dev/sda1 on /mnt/cdrom type xfs (rw,relatime,attr2,inode64,noquota)

            이 중에서 잠시 '/dev/sda1 on /mnt/cdrom type xfs (rw,relatime,attr2,inode64,noquota)' 이 구문에 집중해보자면
            /dev/sda1 이 /mnt/cdrom 에 연결되어있으며
            type xfs 로 파일 시스템 형식이 xfs인것을 알 수 있다.
            )
            
            장치 용량 출력 : df -h (*현재 운영체제에 연결된 모든 장치에 관한 내용)
            (*
            출력 예시 :
                Filesystem      Size  Used Avail Use% Mounted on
                devtmpfs        471M     0  471M   0% /dev
                tmpfs           487M     0  487M   0% /dev/shm
                tmpfs           487M  8.2M  478M   2% /run
                tmpfs           487M     0  487M   0% /sys/fs/cgroup
                /dev/sda3        17G  4.6G   13G  27% /
                /dev/sda1      1014M  169M  846M  17% /boot
                tmpfs            98M   12K   98M   1% /run/user/42
                tmpfs            98M     0   98M   0% /run/user/0

            )
            
            마운트      : mount <장치명> <마운트포인트>
            (*
            입력 : mount /dev/sdb1 /mnt/cdrom
            /mnt/cdrom 파일에 /dev/sdb1 파티션을 마운트한다.

            입력 : mount /dev/sda1 /mnt/cdrom
            /mnt/cdrom 파일에 /dev/sda1 파티션을 마운트한다.

            )

            마운트 헤제 : umount <장치명> or umount <마운트포인트>

            (*여기서 말하는 단어 주의점
                장치명  : 장치의 이름을 절대경로로 작성
                마운트포인트 : 디렉토리의 이름을 절대경로로 작성    )

        -모든 마운트 된 장치는 시스템이 종료되면서 마운트가 헤제된다.
            >부팅 과넞ㅇ에서 자동으로 마운트 되도록 설정 된 장치만 마운트가 된다(오토 마운트)

        -마운트 작업 시 주의사항

        1) 마운트, 마운트 헤제는 마운트포인트의 밖에서 진행하는것을 극히 권장한다.
        2) 장치와 마운트포인트는 1:1로 마운트한다.
            >하나의 장치를 여러 마운트포인트에 마운트 하지 않아야 한다.
            >여러 개의 장치를 하나의 마운트포인트에 마운트 하지 않아야 한다.


        (*문제
        <partition>     <mount point>
        1번 500M(b)     /kg
        2번 300M        /mp
        5번 1G          /sp
        6번 200M        /hp

        풀이:

        fdisk /dev/sdb
        입력해서 /dev/sdb 장치관리 진입

        Command (m for help):
        출력되면
        n
        입력하고 엔터 눌러서 '파티션 생성'하기

        p primary (0 primary, 0 extended, 4 free)
        e extended
        Select (default p) :
        이렇게 되는데
        (0 primary, 0 extended, 4 free)
        이 부분은 0 extended만 확인되면 크게 신경쓰지 않아도 된다.
        그냥 엔터를 누르거나 p 를 입력해서
        primary 파티션을 생성해준다.
        
        Last sector, +sector or +size{K,M,G} (2048-4194303, default 4194303):
        여기에서 용량을 적어준다.
        우리는 1번 파티션에 500M(byte)를 지정해줘야하니 +500M을 적고서 엔터를 눌러 선택확정을 한다.

        다시
        p primary (0 primary, 0 extended, 4 free)
        e extended
        Select (default p) :
        이 부분이 나오는데, 그냥 엔터를 누르거나 p 를 입력해서 primary 파티션을 또 설정해준다.
        Last sector, +sector or +size{K,M,G} (2048-4194303, default 4194303):
        이런 문장이 또 나온다면, 이번에는 2번째 파티션의 300M를 넣어야하니 +300M을 적어준다.
        
        다시
        p primary (0 primary, 0 extended, 4 free)
        e extended
        Select (default p) :
        이 부분이 나오면, 이제는 extended로 처리를 해줘서 3,4번을 처리(?)해준다.

        그 다음에 
        Command (m for help):
        이 문장이 다시 나오게 된다면 5,6번을 처리해줄 때가 됐으니
        다시 n 을 입력하고 엔터를 친다.

        아까와는 다르게
        Partition type :
            p   primary (2 primary, 1 extended, 1 free)
            l   logical (numbered from 5)
        Select (default p) :
        이러한 구문이 나오는데
        이제는 primary 말고 logical 로 설정해주기 위해 l을 넣고서 엔터를 친다.

        Last sector, +sector or +size{K,M,G} (2048-4194303, default 4194303):
        다시 이런 구문이 나오면 5번 파티션(l   logical (numbered from 5))에 대한 용량을 넣어야 하니
        +1G를 넣고서 엔터를 친다.

        
        Command (m for help):
        n을 넣고
        Partition type :
            p   primary (2 primary, 1 extended, 1 free)
            l   logical (numbered from 5)
        Select (default p) :
        l을 넣고
        +200M를 친다.

        Command (m for help):
        이제 파티션 관련해서 직접수행해야할 작업들은 끝이 났으니

        p를 입력하고 끝낸다.

        mkfs.xfs /dev/sdb1
        mkfs.xfs /dev/sdb2
        mkfs.xfs /dev/sdb5
        mkfs.xfs /dev/sdb6
        을 넣어서 파일 시스템 형식을 지정해주고

        mkdir /kg /mp /sp /hp
        를 넣어서 마운트시킬 파일을 만들고

        mount /dev/sdb1 /kg
        mount /dev/sdb2 /mp
        mount /dev/sdb5 /sp
        mount /dev/sdb6 /hp
        를 입력해서 각 파일에 파티션을 설정해준다.
        
        )



---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------




기호
.   :현재 디렉토리 (단, 파일/디렉토리 이름 앞에 붙어있으면 숨김 처리가 된다.)
cat ./hello.txt
cd ./test_dir



..  :상위 디렉토리
cd ../test_dir2
cd ../../
cat ../test1.txt



~   :사용자의 홈 디렉토리
cd ~



*   :모든 것(모든 종류와 길이의 문자를 표현할 수 있음.)
cp ./*.txt ../test_dir2
cp ./* ../


>   :기호 왼쪽 명령어가 동작하여 나오는 출력 내용을 기호 오른쪽에 저장함(> : 덮어쓰기, >> : 내용 추가)


|   :(파이프(pipe), shift + \)CLI, CUI의 단점인 '한 줄에 명령어 하나'를 보완하는 기오로써 하나의 대상에 여러 명령어를 적용시킬 수 있다.

ls -al /etc/ | more
more (ls -l /etc/)

위의 두 문장은 같은 뜻을 가진다.


---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

shutdown -r now
reboot
init 6




---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

shutdown -h new
poweroff
init 0



---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

tail
    -파일의 마지막 줄부터 10줄 출력
    -옵션
        -숫자 : 숫자만큼 줄 출력
    -예시
    tail hello.txt
    tail -30 hello.txt
    



---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
touch
    -빈 파일 생성. 디렉터리를 생성하지 않는다.(디렉터리 생성 명령어 : mkidr)
    -파일/디렉토리를 대상으로 하여 최종 수정된 날짜와 시간을 갱신한다.

    -예시
    touch hello.txt
    
    
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


vi
    -Linux 에서 기본적으로 제공하는 문서 편집기(CLI,CUI 황경에서 사용함)
    -사용환경
        명령 모드 : 기본 사용 환경, 커서 이동, 복사/잘라내기/붙혀넣기, 삭제, 입력/실행 모드 전환
        입력 모드 : 문서의 내용을 변경하기 위한 환경, 내용 추가/수정/삭제, 명령 모드 전환 가능
        실행 모드 : 그 위 대부분의 기능들을 사용하기 위한 환경, 명령 모드 전환

        -입력 모드와 실행 코드 간의 전환은 불가능
    -vi 에디터 실행
        vi
        (*빈 파일 열기)
        vi 파일명
        (*파일 명 열기. 예시 : vi hello.txt)
    
    -명령 모드 사용 방법
        -입력 모드 전환
            i : 커서 왼쪽으로 내용 입력 
            I : 커서가 있는 줄 왼쪽으로 내용 입력

            a : 커서 오른쪽으로 내용 입력
            A : 커서가 있는 줄 오른쪽으로 내용 입력

            o : 커서 아래로 빈 줄 삽입 후 내용 입력
            O : 커서 위로 빈 줄 삽입 후 내용 입력

            s : 커서가 있던 글자를 지우고 내용 입력
            S : 커서가 있던 줄을 지우고 내용 입력
        
        -실행 취소(undo) , 다시 실행(redo)
            u        : 실행 취소(되돌리기)
            ctrl + r : 다시 실행

        -삭제
            x : 커서 오른쪽 글자 삭제(delete키와 같은 일을 하나, 커서 오른쪽에 지울 글자가 더 없다면 커서 왼쪽 글자 삭제(backspace 키와 동일))
            X : 커서 왼쪽 글자 삭제(backspace키와 같은 일을 하며, 지울 글자가 더 없다면 작동하지 않는다.)

        -복사 , 잘라내기 ,붙혀넣기
        yy : 커서가 있는 줄 복사
        숫자 + yy : 커서가 있는 줄 부터 숫자만큼의 줄 복사
        dd : 커서가 있는 줄 잘라내기
        숫자 + dd : 커서가 있는 줄 부터 숫자만큼 줄 잘라내기
        p(소문자) : 커서 아래로 붙혀넣기
        P(대문자) : 커서 위로 붙혀넣기

        -글자 단위 커서 이동
            k : 상
            j : 하
            h : 좌
            l : 우

        -단위 단위 커서 이동
            w : 다음 단어의 첫 글자로 이동
            b : 이전 단어의 첫 글자로 이동
            e : 다음 단어의 마지막 글자로 이동

        -줄 내부 커서 이동
            0 : 줄의 첫 글자로 이동
            $ : 줄의 마지막 글자로 이동

        -화면 내부 커서 이동
            H : 화면의 첫 줄로 이동
            M : 화면의 가운데 줄로 이동
            L : 화면의 마지막 줄로 이동

        -문서 내부 커서 이동
            gg : 문서의 첫 줄로 이동(= [[)
            G : 문서의 마지막 줄로 이동(= ]])
    -실행 모드 사용 방법
        -검색
            /Pattern : 위에서 아래로 Pattern 검색
            ?Pattern : 아래에서 위로 Pattern 검색
            (*
            /user : 위에서 아래로 user 이라는 단어 검색
            ?user : 아래에서 위로 user 이라는 단어 검색
            )
            

            n : 검색 방향으로 다음 찾기
            N : 검색 방향의 반대로 다음 찾기
            (Windows 의 메모장처럼 위에서 아래로, 아래에서 위로 검색이 다 끝난다면 끝내는게 아니라, chrome과 vs code의 F3 , ctrl + f 처럼 계속 누르다보면 문서의 끝으로 이동해서 다시 키워드를 검색해준다. 좀 더 편리한점은, Windows의 메모장처럼 '더이상 없다'라는 신호도 보내준다는거다.)

        -줄 번호 출력 / 숨기기
            :set nu    (*줄 번호 보이기)
            :set nonu  (*줄 번호 숨기기)
        
        -찾아서 바꾸기(치환)(*찾아서 바꾸게 된다면, 범위내에서 나오는 모든 것을 바꾼다.(한 줄에 여러개일경우 문제가 생길 수 있다.))
            
            :[범위]s/찾을내용/바꿀내용/[범위]

            [범위]의 종류
                생략    : 커서가 있는 줄에서 내용을 찾아서 변경함
                n       : n번째 줄에 있는 내용을 찾아서 변경함
                :3s/home/user       (*3번쨰 줄 home이 있다면 home을 지우고 user로 바꾸기)
                n1,n2   : n1번째 줄부터 n2번째 줄에 있는 내용을 찾아서 변경
                :3,17s/home/user    (*3번째 줄부터 17번째 줄까지 home이 있다면 home을 지우고 user로 바꾸기)
                %       : 문서 전체에 있는 내용을 찾아서 변경
                :%/home/user        (*문서 전체에 home이 있다면 home을 지우고 user로 바꿈)
                :5,%/home/user      (*5번째 줄부터 문서 끝까지 home이 있다면, home을 지우고 user로 바꿈)

            옵션의 종류
                g : 한 줄에 찾는 내용이 여러개 있는 경우에 전부 변경
            
        -현재 사용 중인 파일 확인
            :f  : 현재의 파일명과 커서 위치 확인
        
        -리눅스 명령어 임시 사용
            :! <명령어>     (*vi를 잠시 멈추고 Linux 명령어 동작)
            :! ll (*vi를 잠시 멈추고 ls -al동작)

        -문서에 내용 삽입 (*:r, :r! 는 ':'와 r 사이에 숫자를 넣어서 특정 줄 아래로 삽입이 가능하기도 하다.)

            :.! <명령어>    (*커서가 있는 줄 내용을 지우고 Linux 명령어 동작 결과를 삽입(*화면에 결과가 출력되는 명령어를 사용))
            :.! ll (*vi의 커서가 위치한 줄의 내용을 지우고 ls -al 동작함)

            :r! <명령어>    (*커서가 있는 아래쪽에 Linux 명령어 동작 결과를 삽입 (*화면에 결과가 출력되는 명령어를 사용))
            :r! ll (*vi의 커서가 위치한 줄의 내용을 남기고, 그 아랫줄에 ls -al 동작함)
            :3r! hello.txt   (*3번째 줄 내용을 지우고 hello.txt내용을 삽입함)

            :r <파일명>     (*커서 아래쪽에 파일의 내용을 삽입함)
            :r hello.txt    (*커서 아래쪽에 hello.txt내용을 삽입함.)
            :3r hello.txt   (*3번째 줄 아래에 hello.txt내용을 삽입함)
        
        -저장 , 종료, 불러오기
            :w                  (*저장)
            :w inittab.txt      (*inittab.txt로 저장)
            :q                  (*종료)
            :wq                 (*저장하고 종료)
            :wq inittab.txt     (*inittab.txt로 저장하고 종료)
            :e hello.txt      (*기존 문서를 종료하고 hello.txt파일 불러오기)
            :enew               (*기존 문서를 종료하고 새 파일 편집 시작)

        -화면 분할
            ctrl + w + n : vi 화면 분할
            ctrl + w + w : 분할 화면 간 커서 이동






---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


wc
    -파일의 내용이 몇 줄, 몇 단어, 몇 글자인지 출력함
    -예시
        l : 몇 줄인지 출력(줄은 enter를 기준으로 구분)
        w : 몇 단어인지 출력(단어는 spacebar , enter를 기준으로 구분. enter또한 하나의 단어로써 취급한다.)
        c : 몇 글자인지 출력(공백문자=sapcebar, 개행문자=enter 각각 한 글자로 취급)


    
    
    예시:
    wc hello.txt

    출력 예시:
     34 99   511  hello.txt
     줄 단어 글자 검사한 파일

    
    
    
    추가예시 :
        wc -l hello.txt
        wc -w hello.txt
        wc -c hello.txt



---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

yum
    -Internet을 이용한 자동 패키지 관리
        >반드시 Internet이 연결되어 있어야 사용 가능

    -의존성 오류를 알아서 처리

    -사용 형식
        you [옵션] {install | update | remove} 패키지명
            install : 설치
            update  : 업데이트
            remove  : 삭제
    
    *옵션
        y : y/N 물어볼 때 자동으로 y 입력하여 진행

    예시 :
        yum -y remove vim-*
        'vim-'이 패키지 이름 앞에 붙은 경우 전부 삭제하기

        yum -y install vim-*
        'vim-'이 패키지 이름 앞에 붙은 경우 전부 다운받기

        yum -y update
        모든 패키지 업데이트




---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------



